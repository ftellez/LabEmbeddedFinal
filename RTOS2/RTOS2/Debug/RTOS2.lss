
RTOS2.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002698  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  00002698  00002698  00012698  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     00000474  20000000  000026a0  00020000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00003c64  20000474  00002b14  00020474  2**2
                  ALLOC
  4 .stack        00002000  200040d8  00006778  00020474  2**0
                  ALLOC
  5 .ARM.attributes 00000028  00000000  00000000  00020474  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  0002049c  2**0
                  CONTENTS, READONLY
  7 .debug_info   000183a6  00000000  00000000  000204f5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001e36  00000000  00000000  0003889b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00004776  00000000  00000000  0003a6d1  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00000510  00000000  00000000  0003ee47  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000630  00000000  00000000  0003f357  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  00013981  00000000  00000000  0003f987  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   000056c5  00000000  00000000  00053308  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0007853a  00000000  00000000  000589cd  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00000f48  00000000  00000000  000d0f08  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	d8 60 00 20 19 01 00 00 15 01 00 00 15 01 00 00     .`. ............
	...
      2c:	15 01 00 00 00 00 00 00 00 00 00 00 c1 0c 00 00     ................
      3c:	05 0d 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      4c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      5c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      6c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      7c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      8c:	15 01 00 00 15 01 00 00 00 00 00 00 00 00 00 00     ................
      9c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      ac:	15 01 00 00 00 00 00 00                             ........

000000b4 <__do_global_dtors_aux>:
      b4:	b510      	push	{r4, lr}
      b6:	4c06      	ldr	r4, [pc, #24]	; (d0 <__do_global_dtors_aux+0x1c>)
      b8:	7823      	ldrb	r3, [r4, #0]
      ba:	2b00      	cmp	r3, #0
      bc:	d107      	bne.n	ce <__do_global_dtors_aux+0x1a>
      be:	4b05      	ldr	r3, [pc, #20]	; (d4 <__do_global_dtors_aux+0x20>)
      c0:	2b00      	cmp	r3, #0
      c2:	d002      	beq.n	ca <__do_global_dtors_aux+0x16>
      c4:	4804      	ldr	r0, [pc, #16]	; (d8 <__do_global_dtors_aux+0x24>)
      c6:	e000      	b.n	ca <__do_global_dtors_aux+0x16>
      c8:	bf00      	nop
      ca:	2301      	movs	r3, #1
      cc:	7023      	strb	r3, [r4, #0]
      ce:	bd10      	pop	{r4, pc}
      d0:	20000474 	.word	0x20000474
      d4:	00000000 	.word	0x00000000
      d8:	000026a0 	.word	0x000026a0

000000dc <frame_dummy>:
      dc:	4b08      	ldr	r3, [pc, #32]	; (100 <frame_dummy+0x24>)
      de:	b510      	push	{r4, lr}
      e0:	2b00      	cmp	r3, #0
      e2:	d003      	beq.n	ec <frame_dummy+0x10>
      e4:	4907      	ldr	r1, [pc, #28]	; (104 <frame_dummy+0x28>)
      e6:	4808      	ldr	r0, [pc, #32]	; (108 <frame_dummy+0x2c>)
      e8:	e000      	b.n	ec <frame_dummy+0x10>
      ea:	bf00      	nop
      ec:	4807      	ldr	r0, [pc, #28]	; (10c <frame_dummy+0x30>)
      ee:	6803      	ldr	r3, [r0, #0]
      f0:	2b00      	cmp	r3, #0
      f2:	d100      	bne.n	f6 <frame_dummy+0x1a>
      f4:	bd10      	pop	{r4, pc}
      f6:	4b06      	ldr	r3, [pc, #24]	; (110 <frame_dummy+0x34>)
      f8:	2b00      	cmp	r3, #0
      fa:	d0fb      	beq.n	f4 <frame_dummy+0x18>
      fc:	4798      	blx	r3
      fe:	e7f9      	b.n	f4 <frame_dummy+0x18>
     100:	00000000 	.word	0x00000000
     104:	20000478 	.word	0x20000478
     108:	000026a0 	.word	0x000026a0
     10c:	000026a0 	.word	0x000026a0
     110:	00000000 	.word	0x00000000

00000114 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     114:	e7fe      	b.n	114 <Dummy_Handler>
	...

00000118 <Reset_Handler>:
{
     118:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        if (pSrc != pDest) {
     11a:	4a2a      	ldr	r2, [pc, #168]	; (1c4 <Reset_Handler+0xac>)
     11c:	4b2a      	ldr	r3, [pc, #168]	; (1c8 <Reset_Handler+0xb0>)
     11e:	429a      	cmp	r2, r3
     120:	d011      	beq.n	146 <Reset_Handler+0x2e>
                for (; pDest < &_erelocate;) {
     122:	001a      	movs	r2, r3
     124:	4b29      	ldr	r3, [pc, #164]	; (1cc <Reset_Handler+0xb4>)
     126:	429a      	cmp	r2, r3
     128:	d20d      	bcs.n	146 <Reset_Handler+0x2e>
     12a:	4a29      	ldr	r2, [pc, #164]	; (1d0 <Reset_Handler+0xb8>)
     12c:	3303      	adds	r3, #3
     12e:	1a9b      	subs	r3, r3, r2
     130:	089b      	lsrs	r3, r3, #2
     132:	3301      	adds	r3, #1
     134:	009b      	lsls	r3, r3, #2
     136:	2200      	movs	r2, #0
                        *pDest++ = *pSrc++;
     138:	4823      	ldr	r0, [pc, #140]	; (1c8 <Reset_Handler+0xb0>)
     13a:	4922      	ldr	r1, [pc, #136]	; (1c4 <Reset_Handler+0xac>)
     13c:	588c      	ldr	r4, [r1, r2]
     13e:	5084      	str	r4, [r0, r2]
     140:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
     142:	429a      	cmp	r2, r3
     144:	d1fa      	bne.n	13c <Reset_Handler+0x24>
        for (pDest = &_szero; pDest < &_ezero;) {
     146:	4a23      	ldr	r2, [pc, #140]	; (1d4 <Reset_Handler+0xbc>)
     148:	4b23      	ldr	r3, [pc, #140]	; (1d8 <Reset_Handler+0xc0>)
     14a:	429a      	cmp	r2, r3
     14c:	d20a      	bcs.n	164 <Reset_Handler+0x4c>
     14e:	43d3      	mvns	r3, r2
     150:	4921      	ldr	r1, [pc, #132]	; (1d8 <Reset_Handler+0xc0>)
     152:	185b      	adds	r3, r3, r1
     154:	2103      	movs	r1, #3
     156:	438b      	bics	r3, r1
     158:	3304      	adds	r3, #4
     15a:	189b      	adds	r3, r3, r2
                *pDest++ = 0;
     15c:	2100      	movs	r1, #0
     15e:	c202      	stmia	r2!, {r1}
        for (pDest = &_szero; pDest < &_ezero;) {
     160:	4293      	cmp	r3, r2
     162:	d1fc      	bne.n	15e <Reset_Handler+0x46>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     164:	4a1d      	ldr	r2, [pc, #116]	; (1dc <Reset_Handler+0xc4>)
     166:	21ff      	movs	r1, #255	; 0xff
     168:	4b1d      	ldr	r3, [pc, #116]	; (1e0 <Reset_Handler+0xc8>)
     16a:	438b      	bics	r3, r1
     16c:	6093      	str	r3, [r2, #8]
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
     16e:	39fd      	subs	r1, #253	; 0xfd
     170:	2390      	movs	r3, #144	; 0x90
     172:	005b      	lsls	r3, r3, #1
     174:	4a1b      	ldr	r2, [pc, #108]	; (1e4 <Reset_Handler+0xcc>)
     176:	50d1      	str	r1, [r2, r3]
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
     178:	4a1b      	ldr	r2, [pc, #108]	; (1e8 <Reset_Handler+0xd0>)
     17a:	78d3      	ldrb	r3, [r2, #3]
     17c:	2503      	movs	r5, #3
     17e:	43ab      	bics	r3, r5
     180:	2402      	movs	r4, #2
     182:	4323      	orrs	r3, r4
     184:	70d3      	strb	r3, [r2, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
     186:	78d3      	ldrb	r3, [r2, #3]
     188:	270c      	movs	r7, #12
     18a:	43bb      	bics	r3, r7
     18c:	2608      	movs	r6, #8
     18e:	4333      	orrs	r3, r6
     190:	70d3      	strb	r3, [r2, #3]
        DMAC->QOSCTRL.bit.DQOS = 2;
     192:	4b16      	ldr	r3, [pc, #88]	; (1ec <Reset_Handler+0xd4>)
     194:	7b98      	ldrb	r0, [r3, #14]
     196:	2230      	movs	r2, #48	; 0x30
     198:	4390      	bics	r0, r2
     19a:	2220      	movs	r2, #32
     19c:	4310      	orrs	r0, r2
     19e:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
     1a0:	7b99      	ldrb	r1, [r3, #14]
     1a2:	43b9      	bics	r1, r7
     1a4:	4331      	orrs	r1, r6
     1a6:	7399      	strb	r1, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
     1a8:	7b9a      	ldrb	r2, [r3, #14]
     1aa:	43aa      	bics	r2, r5
     1ac:	4322      	orrs	r2, r4
     1ae:	739a      	strb	r2, [r3, #14]
        NVMCTRL->CTRLB.bit.MANW = 1;
     1b0:	4a0f      	ldr	r2, [pc, #60]	; (1f0 <Reset_Handler+0xd8>)
     1b2:	6853      	ldr	r3, [r2, #4]
     1b4:	2180      	movs	r1, #128	; 0x80
     1b6:	430b      	orrs	r3, r1
     1b8:	6053      	str	r3, [r2, #4]
        __libc_init_array();
     1ba:	4b0e      	ldr	r3, [pc, #56]	; (1f4 <Reset_Handler+0xdc>)
     1bc:	4798      	blx	r3
        main();
     1be:	4b0e      	ldr	r3, [pc, #56]	; (1f8 <Reset_Handler+0xe0>)
     1c0:	4798      	blx	r3
     1c2:	e7fe      	b.n	1c2 <Reset_Handler+0xaa>
     1c4:	000026a0 	.word	0x000026a0
     1c8:	20000000 	.word	0x20000000
     1cc:	20000474 	.word	0x20000474
     1d0:	20000004 	.word	0x20000004
     1d4:	20000474 	.word	0x20000474
     1d8:	200040d8 	.word	0x200040d8
     1dc:	e000ed00 	.word	0xe000ed00
     1e0:	00000000 	.word	0x00000000
     1e4:	41007000 	.word	0x41007000
     1e8:	41005000 	.word	0x41005000
     1ec:	41004800 	.word	0x41004800
     1f0:	41004000 	.word	0x41004000
     1f4:	00002399 	.word	0x00002399
     1f8:	000005c1 	.word	0x000005c1

000001fc <SystemInit>:
 *         Initialize the System and update the SystemCoreClock variable.
 */
void SystemInit(void)
{
        // Keep the default device state after reset
        SystemCoreClock = __SYSTEM_CLOCK;
     1fc:	4a01      	ldr	r2, [pc, #4]	; (204 <SystemInit+0x8>)
     1fe:	4b02      	ldr	r3, [pc, #8]	; (208 <SystemInit+0xc>)
     200:	601a      	str	r2, [r3, #0]
        return;
}
     202:	4770      	bx	lr
     204:	000f4240 	.word	0x000f4240
     208:	20000000 	.word	0x20000000

0000020c <printStamp>:
	sendI2CDataArray(SLAVE_ADDR,tx_buf , BUF_SIZE,SEC_ADDR);
	StopCond();

}

void printStamp(){
     20c:	b5f0      	push	{r4, r5, r6, r7, lr}
     20e:	b085      	sub	sp, #20
	
	while(1){
	//Date/Month/Year/Hours/Minutes/Seconds
	myprintf("%d%d/%d%d/20%d%d/", DATE.field.dec_date,DATE.field.un_date,MON.field.dec_mont,MON.field.un_month,YEAR.field.dec_year,YEAR.field.un_year);
     210:	4d3b      	ldr	r5, [pc, #236]	; (300 <printStamp+0xf4>)
     212:	4e3c      	ldr	r6, [pc, #240]	; (304 <printStamp+0xf8>)
     214:	e01d      	b.n	252 <printStamp+0x46>
	if(HOU.field.h1224 == 1){
		if(HOU.field.am_pm==1){
			myprintf("%d%d:%d%d:%d%d PM\n",HOU.field.dec_hour,HOU.field.un_hour,MIN.field.dec_min,MIN.field.un_min,SEG.field.dec_sec,SEG.field.un_sec);
		}
		else{
			myprintf("%d%d:%d%d:%d%d AM\n",HOU.field.dec_hour,HOU.field.un_hour,MIN.field.dec_min,MIN.field.un_min,SEG.field.dec_sec,SEG.field.un_sec);
     216:	4f3c      	ldr	r7, [pc, #240]	; (308 <printStamp+0xfc>)
     218:	783b      	ldrb	r3, [r7, #0]
     21a:	065b      	lsls	r3, r3, #25
     21c:	0f5b      	lsrs	r3, r3, #29
     21e:	4a3b      	ldr	r2, [pc, #236]	; (30c <printStamp+0x100>)
     220:	7811      	ldrb	r1, [r2, #0]
     222:	070a      	lsls	r2, r1, #28
     224:	0f12      	lsrs	r2, r2, #28
     226:	06c9      	lsls	r1, r1, #27
     228:	0fc9      	lsrs	r1, r1, #31
     22a:	4c39      	ldr	r4, [pc, #228]	; (310 <printStamp+0x104>)
     22c:	7820      	ldrb	r0, [r4, #0]
     22e:	0700      	lsls	r0, r0, #28
     230:	0f00      	lsrs	r0, r0, #28
     232:	9002      	str	r0, [sp, #8]
     234:	7820      	ldrb	r0, [r4, #0]
     236:	0640      	lsls	r0, r0, #25
     238:	0f40      	lsrs	r0, r0, #29
     23a:	9001      	str	r0, [sp, #4]
     23c:	7838      	ldrb	r0, [r7, #0]
     23e:	0700      	lsls	r0, r0, #28
     240:	0f00      	lsrs	r0, r0, #28
     242:	9000      	str	r0, [sp, #0]
     244:	4833      	ldr	r0, [pc, #204]	; (314 <printStamp+0x108>)
     246:	4f34      	ldr	r7, [pc, #208]	; (318 <printStamp+0x10c>)
     248:	47b8      	blx	r7
	}
	else{
		
		myprintf("%d%d:%d%d:%d%d/\n",HOU.field.dec_hour|(HOU.field.am_pm<<1),HOU.field.un_hour,MIN.field.dec_min,MIN.field.un_min,SEG.field.dec_sec,SEG.field.un_sec);
	}
	vTaskDelay(1000);
     24a:	20fa      	movs	r0, #250	; 0xfa
     24c:	0080      	lsls	r0, r0, #2
     24e:	4b33      	ldr	r3, [pc, #204]	; (31c <printStamp+0x110>)
     250:	4798      	blx	r3
	myprintf("%d%d/%d%d/20%d%d/", DATE.field.dec_date,DATE.field.un_date,MON.field.dec_mont,MON.field.un_month,YEAR.field.dec_year,YEAR.field.un_year);
     252:	782b      	ldrb	r3, [r5, #0]
     254:	06db      	lsls	r3, r3, #27
     256:	0fdb      	lsrs	r3, r3, #31
     258:	7831      	ldrb	r1, [r6, #0]
     25a:	070a      	lsls	r2, r1, #28
     25c:	0f12      	lsrs	r2, r2, #28
     25e:	0689      	lsls	r1, r1, #26
     260:	0f89      	lsrs	r1, r1, #30
     262:	4f2f      	ldr	r7, [pc, #188]	; (320 <printStamp+0x114>)
     264:	7838      	ldrb	r0, [r7, #0]
     266:	0700      	lsls	r0, r0, #28
     268:	0f00      	lsrs	r0, r0, #28
     26a:	9002      	str	r0, [sp, #8]
     26c:	7838      	ldrb	r0, [r7, #0]
     26e:	0900      	lsrs	r0, r0, #4
     270:	9001      	str	r0, [sp, #4]
     272:	7828      	ldrb	r0, [r5, #0]
     274:	0700      	lsls	r0, r0, #28
     276:	0f00      	lsrs	r0, r0, #28
     278:	9000      	str	r0, [sp, #0]
     27a:	482a      	ldr	r0, [pc, #168]	; (324 <printStamp+0x118>)
     27c:	4f26      	ldr	r7, [pc, #152]	; (318 <printStamp+0x10c>)
     27e:	47b8      	blx	r7
	if(HOU.field.h1224 == 1){
     280:	4b22      	ldr	r3, [pc, #136]	; (30c <printStamp+0x100>)
     282:	781b      	ldrb	r3, [r3, #0]
     284:	065a      	lsls	r2, r3, #25
     286:	d51c      	bpl.n	2c2 <printStamp+0xb6>
		if(HOU.field.am_pm==1){
     288:	069b      	lsls	r3, r3, #26
     28a:	d5c4      	bpl.n	216 <printStamp+0xa>
			myprintf("%d%d:%d%d:%d%d PM\n",HOU.field.dec_hour,HOU.field.un_hour,MIN.field.dec_min,MIN.field.un_min,SEG.field.dec_sec,SEG.field.un_sec);
     28c:	4f1e      	ldr	r7, [pc, #120]	; (308 <printStamp+0xfc>)
     28e:	783b      	ldrb	r3, [r7, #0]
     290:	065b      	lsls	r3, r3, #25
     292:	0f5b      	lsrs	r3, r3, #29
     294:	4a1d      	ldr	r2, [pc, #116]	; (30c <printStamp+0x100>)
     296:	7811      	ldrb	r1, [r2, #0]
     298:	070a      	lsls	r2, r1, #28
     29a:	0f12      	lsrs	r2, r2, #28
     29c:	06c9      	lsls	r1, r1, #27
     29e:	0fc9      	lsrs	r1, r1, #31
     2a0:	4c1b      	ldr	r4, [pc, #108]	; (310 <printStamp+0x104>)
     2a2:	7820      	ldrb	r0, [r4, #0]
     2a4:	0700      	lsls	r0, r0, #28
     2a6:	0f00      	lsrs	r0, r0, #28
     2a8:	9002      	str	r0, [sp, #8]
     2aa:	7820      	ldrb	r0, [r4, #0]
     2ac:	0640      	lsls	r0, r0, #25
     2ae:	0f40      	lsrs	r0, r0, #29
     2b0:	9001      	str	r0, [sp, #4]
     2b2:	7838      	ldrb	r0, [r7, #0]
     2b4:	0700      	lsls	r0, r0, #28
     2b6:	0f00      	lsrs	r0, r0, #28
     2b8:	9000      	str	r0, [sp, #0]
     2ba:	481b      	ldr	r0, [pc, #108]	; (328 <printStamp+0x11c>)
     2bc:	4f16      	ldr	r7, [pc, #88]	; (318 <printStamp+0x10c>)
     2be:	47b8      	blx	r7
     2c0:	e7c3      	b.n	24a <printStamp+0x3e>
		myprintf("%d%d:%d%d:%d%d/\n",HOU.field.dec_hour|(HOU.field.am_pm<<1),HOU.field.un_hour,MIN.field.dec_min,MIN.field.un_min,SEG.field.dec_sec,SEG.field.un_sec);
     2c2:	4f11      	ldr	r7, [pc, #68]	; (308 <printStamp+0xfc>)
     2c4:	783b      	ldrb	r3, [r7, #0]
     2c6:	065b      	lsls	r3, r3, #25
     2c8:	0f5b      	lsrs	r3, r3, #29
     2ca:	4a10      	ldr	r2, [pc, #64]	; (30c <printStamp+0x100>)
     2cc:	7810      	ldrb	r0, [r2, #0]
     2ce:	0702      	lsls	r2, r0, #28
     2d0:	0f12      	lsrs	r2, r2, #28
     2d2:	0681      	lsls	r1, r0, #26
     2d4:	0fc9      	lsrs	r1, r1, #31
     2d6:	0049      	lsls	r1, r1, #1
     2d8:	06c0      	lsls	r0, r0, #27
     2da:	0fc0      	lsrs	r0, r0, #31
     2dc:	4301      	orrs	r1, r0
     2de:	4c0c      	ldr	r4, [pc, #48]	; (310 <printStamp+0x104>)
     2e0:	7820      	ldrb	r0, [r4, #0]
     2e2:	0700      	lsls	r0, r0, #28
     2e4:	0f00      	lsrs	r0, r0, #28
     2e6:	9002      	str	r0, [sp, #8]
     2e8:	7820      	ldrb	r0, [r4, #0]
     2ea:	0640      	lsls	r0, r0, #25
     2ec:	0f40      	lsrs	r0, r0, #29
     2ee:	9001      	str	r0, [sp, #4]
     2f0:	7838      	ldrb	r0, [r7, #0]
     2f2:	0700      	lsls	r0, r0, #28
     2f4:	0f00      	lsrs	r0, r0, #28
     2f6:	9000      	str	r0, [sp, #0]
     2f8:	480c      	ldr	r0, [pc, #48]	; (32c <printStamp+0x120>)
     2fa:	4f07      	ldr	r7, [pc, #28]	; (318 <printStamp+0x10c>)
     2fc:	47b8      	blx	r7
     2fe:	e7a4      	b.n	24a <printStamp+0x3e>
     300:	200040a8 	.word	0x200040a8
     304:	200040a0 	.word	0x200040a0
     308:	200040ac 	.word	0x200040ac
     30c:	2000409c 	.word	0x2000409c
     310:	20004094 	.word	0x20004094
     314:	000025e4 	.word	0x000025e4
     318:	00000729 	.word	0x00000729
     31c:	000019f1 	.word	0x000019f1
     320:	200040b0 	.word	0x200040b0
     324:	000025bc 	.word	0x000025bc
     328:	000025d0 	.word	0x000025d0
     32c:	000025f8 	.word	0x000025f8

00000330 <UART_SendChar>:

   /* synchronization busy */
   while(SERCOM2->USART.SYNCBUSY.reg & SERCOM_USART_SYNCBUSY_ENABLE);
}

void UART_SendChar(void) {
     330:	b5f0      	push	{r4, r5, r6, r7, lr}
     332:	46ce      	mov	lr, r9
     334:	b500      	push	{lr}
	// Wait until buffer is available
	static char TxBuff[18] ;
	while(1){
		
		TxBuff[0] = SEG.field.un_sec + '0';
     336:	4d2e      	ldr	r5, [pc, #184]	; (3f0 <UART_SendChar+0xc0>)
		TxBuff[1] = SEG.field.dec_sec + '0';
		TxBuff[2] = ':';
     338:	233a      	movs	r3, #58	; 0x3a
     33a:	4699      	mov	r9, r3
     33c:	e003      	b.n	346 <UART_SendChar+0x16>
			while (! ( SERCOM5->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE ) );
			// Send data
			SERCOM5->USART.DATA.reg = (char)TxBuff[i]; //TxBuff[i];
			myprintf("%d",i);
		}
		vTaskDelay(1000);
     33e:	20fa      	movs	r0, #250	; 0xfa
     340:	0080      	lsls	r0, r0, #2
     342:	4b2c      	ldr	r3, [pc, #176]	; (3f4 <UART_SendChar+0xc4>)
     344:	4798      	blx	r3
		TxBuff[0] = SEG.field.un_sec + '0';
     346:	4b2c      	ldr	r3, [pc, #176]	; (3f8 <UART_SendChar+0xc8>)
     348:	781b      	ldrb	r3, [r3, #0]
     34a:	071a      	lsls	r2, r3, #28
     34c:	0f12      	lsrs	r2, r2, #28
     34e:	3230      	adds	r2, #48	; 0x30
     350:	702a      	strb	r2, [r5, #0]
		TxBuff[1] = SEG.field.dec_sec + '0';
     352:	065b      	lsls	r3, r3, #25
     354:	0f5b      	lsrs	r3, r3, #29
     356:	3330      	adds	r3, #48	; 0x30
     358:	706b      	strb	r3, [r5, #1]
		TxBuff[2] = ':';
     35a:	464b      	mov	r3, r9
     35c:	70ab      	strb	r3, [r5, #2]
		TxBuff[3] = MIN.field.un_min + '0';
     35e:	4b27      	ldr	r3, [pc, #156]	; (3fc <UART_SendChar+0xcc>)
     360:	781b      	ldrb	r3, [r3, #0]
     362:	071a      	lsls	r2, r3, #28
     364:	0f12      	lsrs	r2, r2, #28
     366:	3230      	adds	r2, #48	; 0x30
     368:	70ea      	strb	r2, [r5, #3]
		TxBuff[4] = MIN.field.dec_min + '0';
     36a:	065b      	lsls	r3, r3, #25
     36c:	0f5b      	lsrs	r3, r3, #29
     36e:	3330      	adds	r3, #48	; 0x30
     370:	712b      	strb	r3, [r5, #4]
		TxBuff[5] = ':';
     372:	464b      	mov	r3, r9
     374:	716b      	strb	r3, [r5, #5]
		TxBuff[6] = HOU.field.un_hour + '0';
     376:	4b22      	ldr	r3, [pc, #136]	; (400 <UART_SendChar+0xd0>)
     378:	781b      	ldrb	r3, [r3, #0]
     37a:	071a      	lsls	r2, r3, #28
     37c:	0f12      	lsrs	r2, r2, #28
     37e:	3230      	adds	r2, #48	; 0x30
     380:	71aa      	strb	r2, [r5, #6]
		TxBuff[7] = HOU.field.dec_hour + '0';
     382:	06db      	lsls	r3, r3, #27
     384:	0fdb      	lsrs	r3, r3, #31
     386:	3330      	adds	r3, #48	; 0x30
     388:	71eb      	strb	r3, [r5, #7]
		TxBuff[8] = '__';
     38a:	235f      	movs	r3, #95	; 0x5f
     38c:	722b      	strb	r3, [r5, #8]
		TxBuff[9] = YEAR.field.un_year + '0';
     38e:	4b1d      	ldr	r3, [pc, #116]	; (404 <UART_SendChar+0xd4>)
     390:	781b      	ldrb	r3, [r3, #0]
     392:	071a      	lsls	r2, r3, #28
     394:	0f12      	lsrs	r2, r2, #28
     396:	3230      	adds	r2, #48	; 0x30
     398:	726a      	strb	r2, [r5, #9]
		TxBuff[10] = YEAR.field.dec_year + '0'; 
     39a:	091b      	lsrs	r3, r3, #4
     39c:	3330      	adds	r3, #48	; 0x30
     39e:	72ab      	strb	r3, [r5, #10]
		TxBuff[11] = '-';
     3a0:	212d      	movs	r1, #45	; 0x2d
     3a2:	72e9      	strb	r1, [r5, #11]
		TxBuff[12] = MON.field.un_month + '0';
     3a4:	4b18      	ldr	r3, [pc, #96]	; (408 <UART_SendChar+0xd8>)
     3a6:	781b      	ldrb	r3, [r3, #0]
     3a8:	071a      	lsls	r2, r3, #28
     3aa:	0f12      	lsrs	r2, r2, #28
     3ac:	3230      	adds	r2, #48	; 0x30
     3ae:	732a      	strb	r2, [r5, #12]
		TxBuff[13] = MON.field.dec_mont + '0';
     3b0:	06db      	lsls	r3, r3, #27
     3b2:	0fdb      	lsrs	r3, r3, #31
     3b4:	3330      	adds	r3, #48	; 0x30
     3b6:	736b      	strb	r3, [r5, #13]
		TxBuff[14] = '-';
     3b8:	73a9      	strb	r1, [r5, #14]
		TxBuff[15] =  DAY.field.day + '0';
     3ba:	4b14      	ldr	r3, [pc, #80]	; (40c <UART_SendChar+0xdc>)
     3bc:	781b      	ldrb	r3, [r3, #0]
     3be:	075b      	lsls	r3, r3, #29
     3c0:	0f5b      	lsrs	r3, r3, #29
     3c2:	3330      	adds	r3, #48	; 0x30
     3c4:	73eb      	strb	r3, [r5, #15]
		TxBuff[16] = '\n';
     3c6:	230a      	movs	r3, #10
     3c8:	742b      	strb	r3, [r5, #16]
		TxBuff[17] = '\r';
     3ca:	3303      	adds	r3, #3
     3cc:	746b      	strb	r3, [r5, #17]
		for (int i = 17; i>=0 ; i--){	
     3ce:	2611      	movs	r6, #17
			while (! ( SERCOM5->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE ) );
     3d0:	4c0f      	ldr	r4, [pc, #60]	; (410 <UART_SendChar+0xe0>)
			SERCOM5->USART.DATA.reg = (char)TxBuff[i]; //TxBuff[i];
     3d2:	4f07      	ldr	r7, [pc, #28]	; (3f0 <UART_SendChar+0xc0>)
			while (! ( SERCOM5->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE ) );
     3d4:	2201      	movs	r2, #1
     3d6:	7e23      	ldrb	r3, [r4, #24]
     3d8:	4213      	tst	r3, r2
     3da:	d0fc      	beq.n	3d6 <UART_SendChar+0xa6>
			SERCOM5->USART.DATA.reg = (char)TxBuff[i]; //TxBuff[i];
     3dc:	5dbb      	ldrb	r3, [r7, r6]
     3de:	8523      	strh	r3, [r4, #40]	; 0x28
			myprintf("%d",i);
     3e0:	0031      	movs	r1, r6
     3e2:	480c      	ldr	r0, [pc, #48]	; (414 <UART_SendChar+0xe4>)
     3e4:	4b0c      	ldr	r3, [pc, #48]	; (418 <UART_SendChar+0xe8>)
     3e6:	4798      	blx	r3
		for (int i = 17; i>=0 ; i--){	
     3e8:	3e01      	subs	r6, #1
     3ea:	d2f3      	bcs.n	3d4 <UART_SendChar+0xa4>
     3ec:	e7a7      	b.n	33e <UART_SendChar+0xe>
     3ee:	46c0      	nop			; (mov r8, r8)
     3f0:	20000490 	.word	0x20000490
     3f4:	000019f1 	.word	0x000019f1
     3f8:	20004094 	.word	0x20004094
     3fc:	200040ac 	.word	0x200040ac
     400:	2000409c 	.word	0x2000409c
     404:	200040b0 	.word	0x200040b0
     408:	200040a8 	.word	0x200040a8
     40c:	20004098 	.word	0x20004098
     410:	42001c00 	.word	0x42001c00
     414:	0000260c 	.word	0x0000260c
     418:	00000729 	.word	0x00000729

0000041c <escrtTiempo>:
void escrtTiempo(){
     41c:	b570      	push	{r4, r5, r6, lr}
	ptrReloc(SEC_ADDR, SLAVE_ADDR);
     41e:	4e15      	ldr	r6, [pc, #84]	; (474 <escrtTiempo+0x58>)
	receiveI2CDataArray(SLAVE_ADDR,rx_buf,BUF_SIZE);
     420:	4c15      	ldr	r4, [pc, #84]	; (478 <escrtTiempo+0x5c>)
     422:	4d16      	ldr	r5, [pc, #88]	; (47c <escrtTiempo+0x60>)
	ptrReloc(SEC_ADDR, SLAVE_ADDR);
     424:	2168      	movs	r1, #104	; 0x68
     426:	2000      	movs	r0, #0
     428:	47b0      	blx	r6
	receiveI2CDataArray(SLAVE_ADDR,rx_buf,BUF_SIZE);
     42a:	2207      	movs	r2, #7
     42c:	0021      	movs	r1, r4
     42e:	2068      	movs	r0, #104	; 0x68
     430:	47a8      	blx	r5
	SEG.reg=SEGR;
     432:	4b13      	ldr	r3, [pc, #76]	; (480 <escrtTiempo+0x64>)
     434:	781a      	ldrb	r2, [r3, #0]
     436:	4b13      	ldr	r3, [pc, #76]	; (484 <escrtTiempo+0x68>)
     438:	701a      	strb	r2, [r3, #0]
	MIN.reg=MINR;
     43a:	4b13      	ldr	r3, [pc, #76]	; (488 <escrtTiempo+0x6c>)
     43c:	781a      	ldrb	r2, [r3, #0]
     43e:	4b13      	ldr	r3, [pc, #76]	; (48c <escrtTiempo+0x70>)
     440:	701a      	strb	r2, [r3, #0]
	HOU.reg=HOUR;
     442:	4b13      	ldr	r3, [pc, #76]	; (490 <escrtTiempo+0x74>)
     444:	781a      	ldrb	r2, [r3, #0]
     446:	4b13      	ldr	r3, [pc, #76]	; (494 <escrtTiempo+0x78>)
     448:	701a      	strb	r2, [r3, #0]
	DAY.reg=DAYR;
     44a:	4b13      	ldr	r3, [pc, #76]	; (498 <escrtTiempo+0x7c>)
     44c:	781a      	ldrb	r2, [r3, #0]
     44e:	4b13      	ldr	r3, [pc, #76]	; (49c <escrtTiempo+0x80>)
     450:	701a      	strb	r2, [r3, #0]
	DATE.reg=DATER;
     452:	4b13      	ldr	r3, [pc, #76]	; (4a0 <escrtTiempo+0x84>)
     454:	781a      	ldrb	r2, [r3, #0]
     456:	4b13      	ldr	r3, [pc, #76]	; (4a4 <escrtTiempo+0x88>)
     458:	701a      	strb	r2, [r3, #0]
	MON.reg=MOR;
     45a:	4b13      	ldr	r3, [pc, #76]	; (4a8 <escrtTiempo+0x8c>)
     45c:	781a      	ldrb	r2, [r3, #0]
     45e:	4b13      	ldr	r3, [pc, #76]	; (4ac <escrtTiempo+0x90>)
     460:	701a      	strb	r2, [r3, #0]
	YEAR.reg=YEARR;
     462:	4b13      	ldr	r3, [pc, #76]	; (4b0 <escrtTiempo+0x94>)
     464:	781a      	ldrb	r2, [r3, #0]
     466:	4b13      	ldr	r3, [pc, #76]	; (4b4 <escrtTiempo+0x98>)
     468:	701a      	strb	r2, [r3, #0]
	vTaskDelay(250);
     46a:	20fa      	movs	r0, #250	; 0xfa
     46c:	4b12      	ldr	r3, [pc, #72]	; (4b8 <escrtTiempo+0x9c>)
     46e:	4798      	blx	r3
     470:	e7d8      	b.n	424 <escrtTiempo+0x8>
     472:	46c0      	nop			; (mov r8, r8)
     474:	00000ab9 	.word	0x00000ab9
     478:	20000004 	.word	0x20000004
     47c:	00000a41 	.word	0x00000a41
     480:	2000409d 	.word	0x2000409d
     484:	20004094 	.word	0x20004094
     488:	2000409b 	.word	0x2000409b
     48c:	200040ac 	.word	0x200040ac
     490:	200040a4 	.word	0x200040a4
     494:	2000409c 	.word	0x2000409c
     498:	20004090 	.word	0x20004090
     49c:	20004098 	.word	0x20004098
     4a0:	200040a7 	.word	0x200040a7
     4a4:	200040a0 	.word	0x200040a0
     4a8:	20004091 	.word	0x20004091
     4ac:	200040a8 	.word	0x200040a8
     4b0:	200040a2 	.word	0x200040a2
     4b4:	200040b0 	.word	0x200040b0
     4b8:	000019f1 	.word	0x000019f1

000004bc <ClockInit>:
void ClockInit(){
     4bc:	b5f0      	push	{r4, r5, r6, r7, lr}
     4be:	46c6      	mov	lr, r8
     4c0:	b500      	push	{lr}
	SEG.field.un_sec = 0x0;
     4c2:	4b2e      	ldr	r3, [pc, #184]	; (57c <ClockInit+0xc0>)
     4c4:	7819      	ldrb	r1, [r3, #0]
     4c6:	200f      	movs	r0, #15
	SEG.field.dec_sec= 0x0;
     4c8:	4381      	bics	r1, r0
     4ca:	2470      	movs	r4, #112	; 0x70
     4cc:	43a1      	bics	r1, r4
     4ce:	7019      	strb	r1, [r3, #0]
	MIN.field.un_min= 0x3;
     4d0:	4a2b      	ldr	r2, [pc, #172]	; (580 <ClockInit+0xc4>)
     4d2:	7813      	ldrb	r3, [r2, #0]
     4d4:	4383      	bics	r3, r0
     4d6:	2503      	movs	r5, #3
     4d8:	432b      	orrs	r3, r5
	MIN.field.dec_min= 0x2;
     4da:	b2db      	uxtb	r3, r3
     4dc:	43a3      	bics	r3, r4
     4de:	2620      	movs	r6, #32
     4e0:	4333      	orrs	r3, r6
     4e2:	7013      	strb	r3, [r2, #0]
	HOU.field.un_hour=0x4;
     4e4:	4d27      	ldr	r5, [pc, #156]	; (584 <ClockInit+0xc8>)
     4e6:	782c      	ldrb	r4, [r5, #0]
     4e8:	4384      	bics	r4, r0
     4ea:	2204      	movs	r2, #4
     4ec:	4322      	orrs	r2, r4
	HOU.field.am_pm= 0x1;
     4ee:	24ef      	movs	r4, #239	; 0xef
     4f0:	4014      	ands	r4, r2
     4f2:	4334      	orrs	r4, r6
	HOU.field.h1224=0x1 ;
     4f4:	b2e4      	uxtb	r4, r4
     4f6:	2240      	movs	r2, #64	; 0x40
     4f8:	4314      	orrs	r4, r2
     4fa:	702c      	strb	r4, [r5, #0]
	DAY.field.day= 0x2;
     4fc:	4a22      	ldr	r2, [pc, #136]	; (588 <ClockInit+0xcc>)
     4fe:	7816      	ldrb	r6, [r2, #0]
     500:	2507      	movs	r5, #7
     502:	43ae      	bics	r6, r5
     504:	2502      	movs	r5, #2
     506:	432e      	orrs	r6, r5
     508:	7016      	strb	r6, [r2, #0]
	DATE.field.un_date= 0x6 ;
     50a:	4d20      	ldr	r5, [pc, #128]	; (58c <ClockInit+0xd0>)
     50c:	782a      	ldrb	r2, [r5, #0]
     50e:	4382      	bics	r2, r0
     510:	2706      	movs	r7, #6
     512:	433a      	orrs	r2, r7
	DATE.field.dec_date= 0x1;
     514:	27cf      	movs	r7, #207	; 0xcf
     516:	403a      	ands	r2, r7
     518:	2710      	movs	r7, #16
     51a:	46bc      	mov	ip, r7
     51c:	4667      	mov	r7, ip
     51e:	433a      	orrs	r2, r7
     520:	702a      	strb	r2, [r5, #0]
	MON.field.un_month= 0x0;
     522:	4d1b      	ldr	r5, [pc, #108]	; (590 <ClockInit+0xd4>)
     524:	46a8      	mov	r8, r5
     526:	782d      	ldrb	r5, [r5, #0]
	MON.field.dec_mont= 0x1;
     528:	4385      	bics	r5, r0
     52a:	433d      	orrs	r5, r7
     52c:	4647      	mov	r7, r8
     52e:	703d      	strb	r5, [r7, #0]
	YEAR.field.un_year= 0x8;
     530:	4f18      	ldr	r7, [pc, #96]	; (594 <ClockInit+0xd8>)
     532:	46b8      	mov	r8, r7
     534:	783f      	ldrb	r7, [r7, #0]
     536:	4387      	bics	r7, r0
     538:	2008      	movs	r0, #8
     53a:	4307      	orrs	r7, r0
	YEAR.field.dec_year= 0x1;
     53c:	200f      	movs	r0, #15
     53e:	4038      	ands	r0, r7
     540:	4667      	mov	r7, ip
     542:	4338      	orrs	r0, r7
     544:	4647      	mov	r7, r8
     546:	7038      	strb	r0, [r7, #0]
	SEGT= SEG.reg;
     548:	4f13      	ldr	r7, [pc, #76]	; (598 <ClockInit+0xdc>)
     54a:	7039      	strb	r1, [r7, #0]
	MINT= MIN.reg;
     54c:	4913      	ldr	r1, [pc, #76]	; (59c <ClockInit+0xe0>)
     54e:	700b      	strb	r3, [r1, #0]
	HOUT= HOU.reg;
     550:	4b13      	ldr	r3, [pc, #76]	; (5a0 <ClockInit+0xe4>)
     552:	701c      	strb	r4, [r3, #0]
	DAYT= DAY.reg;
     554:	4b13      	ldr	r3, [pc, #76]	; (5a4 <ClockInit+0xe8>)
     556:	701e      	strb	r6, [r3, #0]
	DATET= DATE.reg;
     558:	4b13      	ldr	r3, [pc, #76]	; (5a8 <ClockInit+0xec>)
     55a:	701a      	strb	r2, [r3, #0]
	MOT= MON.reg;
     55c:	4b13      	ldr	r3, [pc, #76]	; (5ac <ClockInit+0xf0>)
     55e:	701d      	strb	r5, [r3, #0]
	YEART= YEAR.reg;
     560:	4b13      	ldr	r3, [pc, #76]	; (5b0 <ClockInit+0xf4>)
     562:	7018      	strb	r0, [r3, #0]
	sendI2CDataArray(SLAVE_ADDR,tx_buf , BUF_SIZE,SEC_ADDR);
     564:	2300      	movs	r3, #0
     566:	2207      	movs	r2, #7
     568:	4912      	ldr	r1, [pc, #72]	; (5b4 <ClockInit+0xf8>)
     56a:	311c      	adds	r1, #28
     56c:	2068      	movs	r0, #104	; 0x68
     56e:	4c12      	ldr	r4, [pc, #72]	; (5b8 <ClockInit+0xfc>)
     570:	47a0      	blx	r4
	StopCond();
     572:	4b12      	ldr	r3, [pc, #72]	; (5bc <ClockInit+0x100>)
     574:	4798      	blx	r3
}
     576:	bc04      	pop	{r2}
     578:	4690      	mov	r8, r2
     57a:	bdf0      	pop	{r4, r5, r6, r7, pc}
     57c:	20004094 	.word	0x20004094
     580:	200040ac 	.word	0x200040ac
     584:	2000409c 	.word	0x2000409c
     588:	20004098 	.word	0x20004098
     58c:	200040a0 	.word	0x200040a0
     590:	200040a8 	.word	0x200040a8
     594:	200040b0 	.word	0x200040b0
     598:	20004095 	.word	0x20004095
     59c:	200040a5 	.word	0x200040a5
     5a0:	20004099 	.word	0x20004099
     5a4:	2000409a 	.word	0x2000409a
     5a8:	200040a3 	.word	0x200040a3
     5ac:	200040a6 	.word	0x200040a6
     5b0:	200040a1 	.word	0x200040a1
     5b4:	20000004 	.word	0x20000004
     5b8:	000009bd 	.word	0x000009bd
     5bc:	00000a2d 	.word	0x00000a2d

000005c0 <main>:
{
     5c0:	b5f0      	push	{r4, r5, r6, r7, lr}
     5c2:	b085      	sub	sp, #20
    SystemInit();
     5c4:	4b1c      	ldr	r3, [pc, #112]	; (638 <main+0x78>)
     5c6:	4798      	blx	r3
		SYSCTRL->OSC8M.bit.PRESC = 0;
     5c8:	4a1c      	ldr	r2, [pc, #112]	; (63c <main+0x7c>)
     5ca:	6a13      	ldr	r3, [r2, #32]
     5cc:	491c      	ldr	r1, [pc, #112]	; (640 <main+0x80>)
     5ce:	400b      	ands	r3, r1
     5d0:	6213      	str	r3, [r2, #32]
		PORT->Group[0].WRCONFIG.reg = LCD_PINCFG;
     5d2:	4a1c      	ldr	r2, [pc, #112]	; (644 <main+0x84>)
     5d4:	4b1c      	ldr	r3, [pc, #112]	; (648 <main+0x88>)
     5d6:	629a      	str	r2, [r3, #40]	; 0x28
	initUART();
     5d8:	4b1c      	ldr	r3, [pc, #112]	; (64c <main+0x8c>)
     5da:	4798      	blx	r3
	UART_Initialize(Baud);
     5dc:	20e1      	movs	r0, #225	; 0xe1
     5de:	0200      	lsls	r0, r0, #8
     5e0:	4b1b      	ldr	r3, [pc, #108]	; (650 <main+0x90>)
     5e2:	4798      	blx	r3
	initI2C();
     5e4:	4b1b      	ldr	r3, [pc, #108]	; (654 <main+0x94>)
     5e6:	4798      	blx	r3
	ClockInit();	
     5e8:	4b1b      	ldr	r3, [pc, #108]	; (658 <main+0x98>)
     5ea:	4798      	blx	r3
	xTaskCreate(escrtTiempo, (signed char *) "RTCpull", 1024, NULL, 1, NULL );
     5ec:	2680      	movs	r6, #128	; 0x80
     5ee:	00f6      	lsls	r6, r6, #3
     5f0:	2400      	movs	r4, #0
     5f2:	9403      	str	r4, [sp, #12]
     5f4:	9402      	str	r4, [sp, #8]
     5f6:	9401      	str	r4, [sp, #4]
     5f8:	2301      	movs	r3, #1
     5fa:	9300      	str	r3, [sp, #0]
     5fc:	2300      	movs	r3, #0
     5fe:	0032      	movs	r2, r6
     600:	4916      	ldr	r1, [pc, #88]	; (65c <main+0x9c>)
     602:	4817      	ldr	r0, [pc, #92]	; (660 <main+0xa0>)
     604:	4d17      	ldr	r5, [pc, #92]	; (664 <main+0xa4>)
     606:	47a8      	blx	r5
	xTaskCreate(UART_SendChar, (signed char *) "Timestampsend", 1024, NULL, 2, NULL );
     608:	9403      	str	r4, [sp, #12]
     60a:	9402      	str	r4, [sp, #8]
     60c:	9401      	str	r4, [sp, #4]
     60e:	2702      	movs	r7, #2
     610:	9700      	str	r7, [sp, #0]
     612:	2300      	movs	r3, #0
     614:	0032      	movs	r2, r6
     616:	4914      	ldr	r1, [pc, #80]	; (668 <main+0xa8>)
     618:	4814      	ldr	r0, [pc, #80]	; (66c <main+0xac>)
     61a:	47a8      	blx	r5
	xTaskCreate(printStamp, (signed char *) "Serialprint", 1024, NULL, 2, NULL );
     61c:	9403      	str	r4, [sp, #12]
     61e:	9402      	str	r4, [sp, #8]
     620:	9401      	str	r4, [sp, #4]
     622:	9700      	str	r7, [sp, #0]
     624:	2300      	movs	r3, #0
     626:	0032      	movs	r2, r6
     628:	4911      	ldr	r1, [pc, #68]	; (670 <main+0xb0>)
     62a:	4812      	ldr	r0, [pc, #72]	; (674 <main+0xb4>)
     62c:	47a8      	blx	r5
	vTaskStartScheduler();
     62e:	4b12      	ldr	r3, [pc, #72]	; (678 <main+0xb8>)
     630:	4798      	blx	r3
}
     632:	2000      	movs	r0, #0
     634:	b005      	add	sp, #20
     636:	bdf0      	pop	{r4, r5, r6, r7, pc}
     638:	000001fd 	.word	0x000001fd
     63c:	40000800 	.word	0x40000800
     640:	fffffcff 	.word	0xfffffcff
     644:	50000fc8 	.word	0x50000fc8
     648:	41004400 	.word	0x41004400
     64c:	00000afd 	.word	0x00000afd
     650:	00000b99 	.word	0x00000b99
     654:	00000925 	.word	0x00000925
     658:	000004bd 	.word	0x000004bd
     65c:	00002610 	.word	0x00002610
     660:	0000041d 	.word	0x0000041d
     664:	00001589 	.word	0x00001589
     668:	00002618 	.word	0x00002618
     66c:	00000331 	.word	0x00000331
     670:	00002628 	.word	0x00002628
     674:	0000020d 	.word	0x0000020d
     678:	00001761 	.word	0x00001761

0000067c <out>:
    //return 0;
//}


static void out(char c) {
    *bf++ = c;
     67c:	4a02      	ldr	r2, [pc, #8]	; (688 <out+0xc>)
     67e:	6813      	ldr	r3, [r2, #0]
     680:	1c59      	adds	r1, r3, #1
     682:	6011      	str	r1, [r2, #0]
     684:	7018      	strb	r0, [r3, #0]
    }
     686:	4770      	bx	lr
     688:	200004a4 	.word	0x200004a4

0000068c <outDgt>:

static void outDgt(char dgt) {
     68c:	b510      	push	{r4, lr}
	out(dgt+(dgt<10 ? '0' : (uc ? 'A' : 'a')-10));
     68e:	2330      	movs	r3, #48	; 0x30
     690:	2809      	cmp	r0, #9
     692:	d905      	bls.n	6a0 <outDgt+0x14>
     694:	4b06      	ldr	r3, [pc, #24]	; (6b0 <outDgt+0x24>)
     696:	791a      	ldrb	r2, [r3, #4]
     698:	2337      	movs	r3, #55	; 0x37
     69a:	2a00      	cmp	r2, #0
     69c:	d100      	bne.n	6a0 <outDgt+0x14>
     69e:	3320      	adds	r3, #32
     6a0:	1818      	adds	r0, r3, r0
     6a2:	b2c0      	uxtb	r0, r0
     6a4:	4b03      	ldr	r3, [pc, #12]	; (6b4 <outDgt+0x28>)
     6a6:	4798      	blx	r3
	zs=1;
     6a8:	2201      	movs	r2, #1
     6aa:	4b01      	ldr	r3, [pc, #4]	; (6b0 <outDgt+0x24>)
     6ac:	715a      	strb	r2, [r3, #5]
    }
     6ae:	bd10      	pop	{r4, pc}
     6b0:	200004a4 	.word	0x200004a4
     6b4:	0000067d 	.word	0x0000067d

000006b8 <divOut>:
	
static void divOut(unsigned int div) {
     6b8:	b510      	push	{r4, lr}
    unsigned char dgt=0;
	num &= 0xffff; // just for testing the code  with 32 bit ints
     6ba:	4b0e      	ldr	r3, [pc, #56]	; (6f4 <divOut+0x3c>)
     6bc:	891a      	ldrh	r2, [r3, #8]
     6be:	609a      	str	r2, [r3, #8]
	while (num>=div) {
     6c0:	4282      	cmp	r2, r0
     6c2:	d310      	bcc.n	6e6 <divOut+0x2e>
     6c4:	2300      	movs	r3, #0
		num -= div;
     6c6:	1a12      	subs	r2, r2, r0
		dgt++;
     6c8:	3301      	adds	r3, #1
     6ca:	b2db      	uxtb	r3, r3
	while (num>=div) {
     6cc:	4290      	cmp	r0, r2
     6ce:	d9fa      	bls.n	6c6 <divOut+0xe>
     6d0:	4908      	ldr	r1, [pc, #32]	; (6f4 <divOut+0x3c>)
     6d2:	608a      	str	r2, [r1, #8]
		}
	if (zs || dgt>0) 
     6d4:	794a      	ldrb	r2, [r1, #5]
     6d6:	2a00      	cmp	r2, #0
     6d8:	d101      	bne.n	6de <divOut+0x26>
     6da:	2b00      	cmp	r3, #0
     6dc:	d002      	beq.n	6e4 <divOut+0x2c>
		outDgt(dgt);
     6de:	0018      	movs	r0, r3
     6e0:	4b05      	ldr	r3, [pc, #20]	; (6f8 <divOut+0x40>)
     6e2:	4798      	blx	r3
    }	
     6e4:	bd10      	pop	{r4, pc}
	if (zs || dgt>0) 
     6e6:	4b03      	ldr	r3, [pc, #12]	; (6f4 <divOut+0x3c>)
     6e8:	795b      	ldrb	r3, [r3, #5]
     6ea:	2b00      	cmp	r3, #0
     6ec:	d0fa      	beq.n	6e4 <divOut+0x2c>
    unsigned char dgt=0;
     6ee:	2300      	movs	r3, #0
     6f0:	e7f5      	b.n	6de <divOut+0x26>
     6f2:	46c0      	nop			; (mov r8, r8)
     6f4:	200004a4 	.word	0x200004a4
     6f8:	0000068d 	.word	0x0000068d

000006fc <myputchar>:
    if(c=='\n')
     6fc:	280a      	cmp	r0, #10
     6fe:	d008      	beq.n	712 <myputchar+0x16>
    while (!(SERCOM0->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE));
     700:	4908      	ldr	r1, [pc, #32]	; (724 <myputchar+0x28>)
     702:	2201      	movs	r2, #1
     704:	7e0b      	ldrb	r3, [r1, #24]
     706:	4213      	tst	r3, r2
     708:	d0fc      	beq.n	704 <myputchar+0x8>
    SERCOM0->USART.DATA.reg = s;
     70a:	b280      	uxth	r0, r0
     70c:	4b05      	ldr	r3, [pc, #20]	; (724 <myputchar+0x28>)
     70e:	8518      	strh	r0, [r3, #40]	; 0x28
}
     710:	4770      	bx	lr
    while (!(SERCOM0->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE));
     712:	4904      	ldr	r1, [pc, #16]	; (724 <myputchar+0x28>)
     714:	2201      	movs	r2, #1
     716:	7e0b      	ldrb	r3, [r1, #24]
     718:	4213      	tst	r3, r2
     71a:	d0fc      	beq.n	716 <myputchar+0x1a>
    SERCOM0->USART.DATA.reg = s;
     71c:	220d      	movs	r2, #13
     71e:	4b01      	ldr	r3, [pc, #4]	; (724 <myputchar+0x28>)
     720:	851a      	strh	r2, [r3, #40]	; 0x28
     722:	e7ed      	b.n	700 <myputchar+0x4>
     724:	42000800 	.word	0x42000800

00000728 <tfp_printf>:

void tfp_printf(char *fmt, ...)
	{
     728:	b40f      	push	{r0, r1, r2, r3}
     72a:	b5f0      	push	{r4, r5, r6, r7, lr}
     72c:	46de      	mov	lr, fp
     72e:	4657      	mov	r7, sl
     730:	464e      	mov	r6, r9
     732:	4645      	mov	r5, r8
     734:	b5e0      	push	{r5, r6, r7, lr}
     736:	b087      	sub	sp, #28
     738:	ab10      	add	r3, sp, #64	; 0x40
     73a:	cb80      	ldmia	r3!, {r7}
	va_list va;
	char ch;
	char* p;
	
	va_start(va,fmt);
     73c:	9305      	str	r3, [sp, #20]
				while (ch>='0' && ch<='9') {
					w=(((w<<2)+w)<<1)+ch-'0';
					ch=*fmt++;
					}
				}
			bf=buf;
     73e:	4b73      	ldr	r3, [pc, #460]	; (90c <tfp_printf+0x1e4>)
     740:	330c      	adds	r3, #12
     742:	9302      	str	r3, [sp, #8]
				case '%' :
					out('%');
				default:
					break;
				}
			*bf=0;
     744:	4b71      	ldr	r3, [pc, #452]	; (90c <tfp_printf+0x1e4>)
     746:	469a      	mov	sl, r3
			while (*bf++ && w > 0)
				w--;
			while (w-- > 0) 
				myputchar(lz ? '0' : ' ');
			while ((ch= *p++))
				myputchar(ch);
     748:	4b71      	ldr	r3, [pc, #452]	; (910 <tfp_printf+0x1e8>)
     74a:	4698      	mov	r8, r3
			p=bf;
     74c:	4653      	mov	r3, sl
     74e:	330c      	adds	r3, #12
     750:	9303      	str	r3, [sp, #12]
	while ((ch=*(fmt++))) {
     752:	e08c      	b.n	86e <tfp_printf+0x146>
			ch=*(fmt++);
     754:	787b      	ldrb	r3, [r7, #1]
			if (ch=='0') {
     756:	2b30      	cmp	r3, #48	; 0x30
     758:	d029      	beq.n	7ae <tfp_printf+0x86>
			ch=*(fmt++);
     75a:	3702      	adds	r7, #2
			char lz=0;
     75c:	2200      	movs	r2, #0
     75e:	4693      	mov	fp, r2
			char w=0;
     760:	2400      	movs	r4, #0
			if (ch>='0' && ch<='9') {
     762:	001a      	movs	r2, r3
     764:	3a30      	subs	r2, #48	; 0x30
     766:	2a09      	cmp	r2, #9
     768:	d80c      	bhi.n	784 <tfp_printf+0x5c>
					w=(((w<<2)+w)<<1)+ch-'0';
     76a:	00a2      	lsls	r2, r4, #2
     76c:	18a4      	adds	r4, r4, r2
     76e:	0064      	lsls	r4, r4, #1
     770:	3c30      	subs	r4, #48	; 0x30
     772:	18e4      	adds	r4, r4, r3
     774:	b2e4      	uxtb	r4, r4
					ch=*fmt++;
     776:	1c7a      	adds	r2, r7, #1
     778:	783b      	ldrb	r3, [r7, #0]
     77a:	0017      	movs	r7, r2
				while (ch>='0' && ch<='9') {
     77c:	0019      	movs	r1, r3
     77e:	3930      	subs	r1, #48	; 0x30
     780:	2909      	cmp	r1, #9
     782:	d9f2      	bls.n	76a <tfp_printf+0x42>
			bf=buf;
     784:	4a61      	ldr	r2, [pc, #388]	; (90c <tfp_printf+0x1e4>)
     786:	9902      	ldr	r1, [sp, #8]
     788:	6011      	str	r1, [r2, #0]
			zs=0;
     78a:	2200      	movs	r2, #0
     78c:	495f      	ldr	r1, [pc, #380]	; (90c <tfp_printf+0x1e4>)
     78e:	714a      	strb	r2, [r1, #5]
			switch (ch) {
     790:	2b63      	cmp	r3, #99	; 0x63
     792:	d100      	bne.n	796 <tfp_printf+0x6e>
     794:	e07d      	b.n	892 <tfp_printf+0x16a>
     796:	d80f      	bhi.n	7b8 <tfp_printf+0x90>
     798:	2b25      	cmp	r3, #37	; 0x25
     79a:	d100      	bne.n	79e <tfp_printf+0x76>
     79c:	e086      	b.n	8ac <tfp_printf+0x184>
     79e:	2b58      	cmp	r3, #88	; 0x58
     7a0:	d011      	beq.n	7c6 <tfp_printf+0x9e>
     7a2:	2b00      	cmp	r3, #0
     7a4:	d100      	bne.n	7a8 <tfp_printf+0x80>
     7a6:	e0a6      	b.n	8f6 <tfp_printf+0x1ce>
			p=bf;
     7a8:	4d58      	ldr	r5, [pc, #352]	; (90c <tfp_printf+0x1e4>)
     7aa:	350c      	adds	r5, #12
     7ac:	e03c      	b.n	828 <tfp_printf+0x100>
				ch=*(fmt++);
     7ae:	78bb      	ldrb	r3, [r7, #2]
     7b0:	3703      	adds	r7, #3
				lz=1;
     7b2:	2201      	movs	r2, #1
     7b4:	4693      	mov	fp, r2
     7b6:	e7d3      	b.n	760 <tfp_printf+0x38>
			switch (ch) {
     7b8:	2b73      	cmp	r3, #115	; 0x73
     7ba:	d072      	beq.n	8a2 <tfp_printf+0x17a>
     7bc:	d91b      	bls.n	7f6 <tfp_printf+0xce>
     7be:	2b75      	cmp	r3, #117	; 0x75
     7c0:	d01b      	beq.n	7fa <tfp_printf+0xd2>
     7c2:	2b78      	cmp	r3, #120	; 0x78
     7c4:	d1f0      	bne.n	7a8 <tfp_printf+0x80>
				    uc= ch=='X';
     7c6:	4d51      	ldr	r5, [pc, #324]	; (90c <tfp_printf+0x1e4>)
     7c8:	3b58      	subs	r3, #88	; 0x58
     7ca:	4259      	negs	r1, r3
     7cc:	4159      	adcs	r1, r3
     7ce:	7129      	strb	r1, [r5, #4]
					num=va_arg(va, unsigned int);
     7d0:	9b05      	ldr	r3, [sp, #20]
     7d2:	1d1a      	adds	r2, r3, #4
     7d4:	9205      	str	r2, [sp, #20]
     7d6:	681b      	ldr	r3, [r3, #0]
     7d8:	60ab      	str	r3, [r5, #8]
					divOut(0x1000);
     7da:	2080      	movs	r0, #128	; 0x80
     7dc:	0140      	lsls	r0, r0, #5
     7de:	4e4d      	ldr	r6, [pc, #308]	; (914 <tfp_printf+0x1ec>)
     7e0:	47b0      	blx	r6
					divOut(0x100);
     7e2:	2080      	movs	r0, #128	; 0x80
     7e4:	0040      	lsls	r0, r0, #1
     7e6:	47b0      	blx	r6
					divOut(0x10);
     7e8:	2010      	movs	r0, #16
     7ea:	47b0      	blx	r6
					outDgt(num);
     7ec:	7a28      	ldrb	r0, [r5, #8]
     7ee:	4b4a      	ldr	r3, [pc, #296]	; (918 <tfp_printf+0x1f0>)
     7f0:	4798      	blx	r3
			p=bf;
     7f2:	350c      	adds	r5, #12
					break;
     7f4:	e018      	b.n	828 <tfp_printf+0x100>
			switch (ch) {
     7f6:	2b64      	cmp	r3, #100	; 0x64
     7f8:	d1d6      	bne.n	7a8 <tfp_printf+0x80>
					num=va_arg(va, unsigned int);
     7fa:	9a05      	ldr	r2, [sp, #20]
     7fc:	1d11      	adds	r1, r2, #4
     7fe:	9105      	str	r1, [sp, #20]
     800:	6812      	ldr	r2, [r2, #0]
     802:	4942      	ldr	r1, [pc, #264]	; (90c <tfp_printf+0x1e4>)
     804:	608a      	str	r2, [r1, #8]
					if (ch=='d' && (int)num<0) {
     806:	2b64      	cmp	r3, #100	; 0x64
     808:	d03b      	beq.n	882 <tfp_printf+0x15a>
					divOut(10000);
     80a:	4844      	ldr	r0, [pc, #272]	; (91c <tfp_printf+0x1f4>)
     80c:	4d41      	ldr	r5, [pc, #260]	; (914 <tfp_printf+0x1ec>)
     80e:	47a8      	blx	r5
					divOut(1000);
     810:	20fa      	movs	r0, #250	; 0xfa
     812:	0080      	lsls	r0, r0, #2
     814:	47a8      	blx	r5
					divOut(100);
     816:	2064      	movs	r0, #100	; 0x64
     818:	47a8      	blx	r5
					divOut(10);
     81a:	200a      	movs	r0, #10
     81c:	47a8      	blx	r5
					outDgt(num);
     81e:	4d3b      	ldr	r5, [pc, #236]	; (90c <tfp_printf+0x1e4>)
     820:	7a28      	ldrb	r0, [r5, #8]
     822:	4b3d      	ldr	r3, [pc, #244]	; (918 <tfp_printf+0x1f0>)
     824:	4798      	blx	r3
			p=bf;
     826:	350c      	adds	r5, #12
			*bf=0;
     828:	2300      	movs	r3, #0
     82a:	4652      	mov	r2, sl
     82c:	6812      	ldr	r2, [r2, #0]
     82e:	7013      	strb	r3, [r2, #0]
			while (*bf++ && w > 0)
     830:	1c6b      	adds	r3, r5, #1
     832:	4699      	mov	r9, r3
     834:	4653      	mov	r3, sl
     836:	464a      	mov	r2, r9
     838:	601a      	str	r2, [r3, #0]
     83a:	7828      	ldrb	r0, [r5, #0]
     83c:	2800      	cmp	r0, #0
     83e:	d055      	beq.n	8ec <tfp_printf+0x1c4>
     840:	2c00      	cmp	r4, #0
     842:	d00c      	beq.n	85e <tfp_printf+0x136>
     844:	1caa      	adds	r2, r5, #2
				w--;
     846:	1e63      	subs	r3, r4, #1
     848:	b2db      	uxtb	r3, r3
			while (*bf++ && w > 0)
     84a:	0011      	movs	r1, r2
     84c:	1e56      	subs	r6, r2, #1
     84e:	7836      	ldrb	r6, [r6, #0]
     850:	2e00      	cmp	r6, #0
     852:	d03c      	beq.n	8ce <tfp_printf+0x1a6>
     854:	3201      	adds	r2, #1
				w--;
     856:	1e1c      	subs	r4, r3, #0
			while (*bf++ && w > 0)
     858:	d1f5      	bne.n	846 <tfp_printf+0x11e>
     85a:	4b2c      	ldr	r3, [pc, #176]	; (90c <tfp_printf+0x1e4>)
     85c:	6019      	str	r1, [r3, #0]
			while ((ch= *p++))
     85e:	7828      	ldrb	r0, [r5, #0]
     860:	464d      	mov	r5, r9
				myputchar(ch);
     862:	47c0      	blx	r8
     864:	3501      	adds	r5, #1
			while ((ch= *p++))
     866:	1e6b      	subs	r3, r5, #1
     868:	7818      	ldrb	r0, [r3, #0]
     86a:	2800      	cmp	r0, #0
     86c:	d1f9      	bne.n	862 <tfp_printf+0x13a>
	while ((ch=*(fmt++))) {
     86e:	7838      	ldrb	r0, [r7, #0]
     870:	2800      	cmp	r0, #0
     872:	d040      	beq.n	8f6 <tfp_printf+0x1ce>
		if (ch!='%') {
     874:	2825      	cmp	r0, #37	; 0x25
     876:	d100      	bne.n	87a <tfp_printf+0x152>
     878:	e76c      	b.n	754 <tfp_printf+0x2c>
	while ((ch=*(fmt++))) {
     87a:	3701      	adds	r7, #1
			myputchar(ch);
     87c:	4b24      	ldr	r3, [pc, #144]	; (910 <tfp_printf+0x1e8>)
     87e:	4798      	blx	r3
     880:	e7f5      	b.n	86e <tfp_printf+0x146>
					if (ch=='d' && (int)num<0) {
     882:	2a00      	cmp	r2, #0
     884:	dac1      	bge.n	80a <tfp_printf+0xe2>
						num = -(int)num;
     886:	4252      	negs	r2, r2
     888:	608a      	str	r2, [r1, #8]
						out('-');
     88a:	202d      	movs	r0, #45	; 0x2d
     88c:	4b24      	ldr	r3, [pc, #144]	; (920 <tfp_printf+0x1f8>)
     88e:	4798      	blx	r3
     890:	e7bb      	b.n	80a <tfp_printf+0xe2>
					out((char)(va_arg(va, int)));
     892:	9b05      	ldr	r3, [sp, #20]
     894:	1d1a      	adds	r2, r3, #4
     896:	9205      	str	r2, [sp, #20]
     898:	7818      	ldrb	r0, [r3, #0]
     89a:	4b21      	ldr	r3, [pc, #132]	; (920 <tfp_printf+0x1f8>)
     89c:	4798      	blx	r3
			p=bf;
     89e:	9d03      	ldr	r5, [sp, #12]
					break;
     8a0:	e7c2      	b.n	828 <tfp_printf+0x100>
					p=va_arg(va, char*);
     8a2:	9b05      	ldr	r3, [sp, #20]
     8a4:	1d1a      	adds	r2, r3, #4
     8a6:	9205      	str	r2, [sp, #20]
     8a8:	681d      	ldr	r5, [r3, #0]
					break;
     8aa:	e7bd      	b.n	828 <tfp_printf+0x100>
					out('%');
     8ac:	2025      	movs	r0, #37	; 0x25
     8ae:	4b1c      	ldr	r3, [pc, #112]	; (920 <tfp_printf+0x1f8>)
     8b0:	4798      	blx	r3
			p=bf;
     8b2:	4d16      	ldr	r5, [pc, #88]	; (90c <tfp_printf+0x1e4>)
     8b4:	350c      	adds	r5, #12
     8b6:	e7b7      	b.n	828 <tfp_printf+0x100>
			while (w-- > 0) 
     8b8:	001e      	movs	r6, r3
				myputchar(lz ? '0' : ' ');
     8ba:	9801      	ldr	r0, [sp, #4]
     8bc:	47a0      	blx	r4
			while (w-- > 0) 
     8be:	1e73      	subs	r3, r6, #1
     8c0:	b2db      	uxtb	r3, r3
     8c2:	2e00      	cmp	r6, #0
     8c4:	d1f8      	bne.n	8b8 <tfp_printf+0x190>
			while ((ch= *p++))
     8c6:	7828      	ldrb	r0, [r5, #0]
     8c8:	2800      	cmp	r0, #0
     8ca:	d1c9      	bne.n	860 <tfp_printf+0x138>
     8cc:	e7cf      	b.n	86e <tfp_printf+0x146>
     8ce:	4a0f      	ldr	r2, [pc, #60]	; (90c <tfp_printf+0x1e4>)
     8d0:	6011      	str	r1, [r2, #0]
			while (w-- > 0) 
     8d2:	3c02      	subs	r4, #2
     8d4:	b2e6      	uxtb	r6, r4
     8d6:	2b00      	cmp	r3, #0
     8d8:	d0c2      	beq.n	860 <tfp_printf+0x138>
     8da:	2420      	movs	r4, #32
     8dc:	465b      	mov	r3, fp
     8de:	2b00      	cmp	r3, #0
     8e0:	d000      	beq.n	8e4 <tfp_printf+0x1bc>
     8e2:	2430      	movs	r4, #48	; 0x30
     8e4:	b2e3      	uxtb	r3, r4
     8e6:	9301      	str	r3, [sp, #4]
				myputchar(lz ? '0' : ' ');
     8e8:	4c09      	ldr	r4, [pc, #36]	; (910 <tfp_printf+0x1e8>)
     8ea:	e7e6      	b.n	8ba <tfp_printf+0x192>
			while (w-- > 0) 
     8ec:	1e66      	subs	r6, r4, #1
     8ee:	b2f6      	uxtb	r6, r6
     8f0:	2c00      	cmp	r4, #0
     8f2:	d1f2      	bne.n	8da <tfp_printf+0x1b2>
     8f4:	e7bb      	b.n	86e <tfp_printf+0x146>
			}
		}
	abort:;
	va_end(va);
	}
     8f6:	b007      	add	sp, #28
     8f8:	bc3c      	pop	{r2, r3, r4, r5}
     8fa:	4690      	mov	r8, r2
     8fc:	4699      	mov	r9, r3
     8fe:	46a2      	mov	sl, r4
     900:	46ab      	mov	fp, r5
     902:	bcf0      	pop	{r4, r5, r6, r7}
     904:	bc08      	pop	{r3}
     906:	b004      	add	sp, #16
     908:	4718      	bx	r3
     90a:	46c0      	nop			; (mov r8, r8)
     90c:	200004a4 	.word	0x200004a4
     910:	000006fd 	.word	0x000006fd
     914:	000006b9 	.word	0x000006b9
     918:	0000068d 	.word	0x0000068d
     91c:	00002710 	.word	0x00002710
     920:	0000067d 	.word	0x0000067d

00000924 <initI2C>:
#include "sam.h"
#include <stdio.h>

void initI2C(){
	 /* port mux configuration */
	 PORT->Group[0].PINCFG[PIN_PA22].reg = PORT_PINCFG_PMUXEN | PORT_PINCFG_INEN | PORT_PINCFG_PULLEN; /* SDA */
     924:	4b1e      	ldr	r3, [pc, #120]	; (9a0 <initI2C+0x7c>)
     926:	2207      	movs	r2, #7
     928:	2156      	movs	r1, #86	; 0x56
     92a:	545a      	strb	r2, [r3, r1]
	 PORT->Group[0].PINCFG[PIN_PA23].reg = PORT_PINCFG_PMUXEN | PORT_PINCFG_INEN | PORT_PINCFG_PULLEN; /* SCL */
     92c:	3101      	adds	r1, #1
     92e:	545a      	strb	r2, [r3, r1]
	 
	 /* PMUX: even = n/2, odd: (n-1)/2 */
	 PORT->Group[0].PMUX[11].reg |= 0x02u;
     930:	3234      	adds	r2, #52	; 0x34
     932:	5c99      	ldrb	r1, [r3, r2]
     934:	2002      	movs	r0, #2
     936:	4301      	orrs	r1, r0
     938:	5499      	strb	r1, [r3, r2]
	 PORT->Group[0].PMUX[11].reg |= 0x20u;
     93a:	5c99      	ldrb	r1, [r3, r2]
     93c:	301e      	adds	r0, #30
     93e:	4301      	orrs	r1, r0
     940:	5499      	strb	r1, [r3, r2]
	 
	 /* APBCMASK */
	 PM->APBCMASK.reg |= PM_APBCMASK_SERCOM3;
     942:	4a18      	ldr	r2, [pc, #96]	; (9a4 <initI2C+0x80>)
     944:	6a13      	ldr	r3, [r2, #32]
     946:	2120      	movs	r1, #32
     948:	430b      	orrs	r3, r1
     94a:	6213      	str	r3, [r2, #32]

	 /*GCLK configuration for sercom3 module*/
	 GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID (SERCOM3_GCLK_ID_CORE) |
     94c:	4b16      	ldr	r3, [pc, #88]	; (9a8 <initI2C+0x84>)
     94e:	4a17      	ldr	r2, [pc, #92]	; (9ac <initI2C+0x88>)
     950:	805a      	strh	r2, [r3, #2]
	 GCLK_CLKCTRL_ID (SERCOM3_GCLK_ID_SLOW) |
	 GCLK_CLKCTRL_GEN(4) |
	 GCLK_CLKCTRL_CLKEN;
	 GCLK->GENCTRL.reg |= GCLK_GENCTRL_SRC_OSC8M |
     952:	6859      	ldr	r1, [r3, #4]
     954:	4a16      	ldr	r2, [pc, #88]	; (9b0 <initI2C+0x8c>)
     956:	430a      	orrs	r2, r1
     958:	605a      	str	r2, [r3, #4]
	 GCLK_GENCTRL_GENEN|
	 GCLK_GENCTRL_ID(4);

	 /* set configuration for SERCOM3 I2C module */
	 SERCOM3->I2CM.CTRLB.reg = SERCOM_I2CM_CTRLB_SMEN; /* smart mode enable */
     95a:	2280      	movs	r2, #128	; 0x80
     95c:	0052      	lsls	r2, r2, #1
     95e:	4b15      	ldr	r3, [pc, #84]	; (9b4 <initI2C+0x90>)
     960:	605a      	str	r2, [r3, #4]
	 while (SERCOM3->I2CM.SYNCBUSY.reg); /* waiting loading */
     962:	001a      	movs	r2, r3
     964:	69d3      	ldr	r3, [r2, #28]
     966:	2b00      	cmp	r3, #0
     968:	d1fc      	bne.n	964 <initI2C+0x40>
	 /* calculate BAUDRATE */
	 uint64_t tmp_baud =((8000000/100000)-10-(8000000*250 /1000000000))/2;
	 SERCOM3->I2CM.BAUD.bit.BAUD = SERCOM_I2CM_BAUD_BAUD((uint32_t)tmp_baud);
     96a:	4a12      	ldr	r2, [pc, #72]	; (9b4 <initI2C+0x90>)
     96c:	68d3      	ldr	r3, [r2, #12]
     96e:	21ff      	movs	r1, #255	; 0xff
     970:	438b      	bics	r3, r1
     972:	39dd      	subs	r1, #221	; 0xdd
     974:	430b      	orrs	r3, r1
     976:	60d3      	str	r3, [r2, #12]
	 while (SERCOM3->I2CM.SYNCBUSY.reg); // waiting loading
     978:	69d3      	ldr	r3, [r2, #28]
     97a:	2b00      	cmp	r3, #0
     97c:	d1fc      	bne.n	978 <initI2C+0x54>
	 /* value equals 0x22 or decimal 34 */
	 
	 SERCOM3->I2CM.CTRLA.reg = SERCOM_I2CM_CTRLA_ENABLE   |/* enable module */
     97e:	4a0e      	ldr	r2, [pc, #56]	; (9b8 <initI2C+0x94>)
     980:	4b0c      	ldr	r3, [pc, #48]	; (9b4 <initI2C+0x90>)
     982:	601a      	str	r2, [r3, #0]
	 SERCOM_I2CM_CTRLA_MODE_I2C_MASTER |		/* i2c master mode */
	 SERCOM_I2CM_CTRLA_SDAHOLD(3);		 /* SDA hold time to 600ns */
	 while (SERCOM3->I2CM.SYNCBUSY.reg);  /* waiting loading */
     984:	001a      	movs	r2, r3
     986:	69d3      	ldr	r3, [r2, #28]
     988:	2b00      	cmp	r3, #0
     98a:	d1fc      	bne.n	986 <initI2C+0x62>

	 SERCOM3->I2CM.STATUS.reg |= SERCOM_I2CM_STATUS_BUSSTATE(1); /*set idle */
     98c:	4a09      	ldr	r2, [pc, #36]	; (9b4 <initI2C+0x90>)
     98e:	8b53      	ldrh	r3, [r2, #26]
     990:	2110      	movs	r1, #16
     992:	430b      	orrs	r3, r1
     994:	8353      	strh	r3, [r2, #26]
	 while (SERCOM3->I2CM.SYNCBUSY.reg);
     996:	69d3      	ldr	r3, [r2, #28]
     998:	2b00      	cmp	r3, #0
     99a:	d1fc      	bne.n	996 <initI2C+0x72>
	
	
	
}
     99c:	4770      	bx	lr
     99e:	46c0      	nop			; (mov r8, r8)
     9a0:	41004400 	.word	0x41004400
     9a4:	40000400 	.word	0x40000400
     9a8:	40000c00 	.word	0x40000c00
     9ac:	00004417 	.word	0x00004417
     9b0:	00010604 	.word	0x00010604
     9b4:	42001400 	.word	0x42001400
     9b8:	00300016 	.word	0x00300016

000009bc <sendI2CDataArray>:



void sendI2CDataArray(int SlAddr,uint8_t **ptrData, int Size,uint8_t RTCPtr){
     9bc:	b570      	push	{r4, r5, r6, lr}
     9be:	b082      	sub	sp, #8
	/*writes the data located in the array to the RTC
	SlAddr is the slave address, ptrData is a pointer to the 8-bit data array and
	Size is the number of elements in the array */
	volatile int i;
	 /* Acknowledge section is set as ACK signal by writing 0 in ACKACT bit */
	 SERCOM3->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
     9c0:	4d18      	ldr	r5, [pc, #96]	; (a24 <sendI2CDataArray+0x68>)
     9c2:	686c      	ldr	r4, [r5, #4]
     9c4:	4e18      	ldr	r6, [pc, #96]	; (a28 <sendI2CDataArray+0x6c>)
     9c6:	4034      	ands	r4, r6
     9c8:	606c      	str	r4, [r5, #4]
	 while(SERCOM3->I2CM.SYNCBUSY.reg);  // waiting loading
     9ca:	69ec      	ldr	r4, [r5, #28]
     9cc:	2c00      	cmp	r4, #0
     9ce:	d1fc      	bne.n	9ca <sendI2CDataArray+0xe>
	 
	 /* slave address with write signal (0) */
	 SERCOM3->I2CM.ADDR.reg = (SlAddr << 1) | 0;
     9d0:	0040      	lsls	r0, r0, #1
     9d2:	4c14      	ldr	r4, [pc, #80]	; (a24 <sendI2CDataArray+0x68>)
     9d4:	6260      	str	r0, [r4, #36]	; 0x24
	 while(SERCOM3->I2CM.INTFLAG.bit.MB ==0){}; /* MB=1 if slave NACKS address */
     9d6:	7e20      	ldrb	r0, [r4, #24]
     9d8:	07c0      	lsls	r0, r0, #31
     9da:	d5fc      	bpl.n	9d6 <sendI2CDataArray+0x1a>
	SERCOM3->I2CM.DATA.reg = RTCPtr;
     9dc:	2028      	movs	r0, #40	; 0x28
     9de:	4c11      	ldr	r4, [pc, #68]	; (a24 <sendI2CDataArray+0x68>)
     9e0:	5423      	strb	r3, [r4, r0]
	while(SERCOM3->I2CM.INTFLAG.bit.MB ==0){};
     9e2:	0020      	movs	r0, r4
     9e4:	7e03      	ldrb	r3, [r0, #24]
     9e6:	07db      	lsls	r3, r3, #31
     9e8:	d5fc      	bpl.n	9e4 <sendI2CDataArray+0x28>

	for(i=0; i< Size; i++) {
     9ea:	2300      	movs	r3, #0
     9ec:	9301      	str	r3, [sp, #4]
     9ee:	9b01      	ldr	r3, [sp, #4]
     9f0:	429a      	cmp	r2, r3
     9f2:	dd0f      	ble.n	a14 <sendI2CDataArray+0x58>
		/* placing the data from transmitting buffer to DATA register*/
		SERCOM3->I2CM.DATA.reg = *ptrData[i];
     9f4:	480b      	ldr	r0, [pc, #44]	; (a24 <sendI2CDataArray+0x68>)
     9f6:	2428      	movs	r4, #40	; 0x28
     9f8:	9b01      	ldr	r3, [sp, #4]
     9fa:	009b      	lsls	r3, r3, #2
     9fc:	585b      	ldr	r3, [r3, r1]
     9fe:	781b      	ldrb	r3, [r3, #0]
     a00:	5503      	strb	r3, [r0, r4]
		while(SERCOM3->I2CM.INTFLAG.bit.MB ==0){};/*MB=1 if slave NACKS address */
     a02:	7e03      	ldrb	r3, [r0, #24]
     a04:	07db      	lsls	r3, r3, #31
     a06:	d5fc      	bpl.n	a02 <sendI2CDataArray+0x46>
	for(i=0; i< Size; i++) {
     a08:	9b01      	ldr	r3, [sp, #4]
     a0a:	3301      	adds	r3, #1
     a0c:	9301      	str	r3, [sp, #4]
     a0e:	9b01      	ldr	r3, [sp, #4]
     a10:	4293      	cmp	r3, r2
     a12:	dbf1      	blt.n	9f8 <sendI2CDataArray+0x3c>
	}
	 
	 /* After transferring the last byte stop condition will be sent */
	 SERCOM3->I2CM.CTRLB.bit.CMD = 0x3;
     a14:	4a03      	ldr	r2, [pc, #12]	; (a24 <sendI2CDataArray+0x68>)
     a16:	6851      	ldr	r1, [r2, #4]
     a18:	23c0      	movs	r3, #192	; 0xc0
     a1a:	029b      	lsls	r3, r3, #10
     a1c:	430b      	orrs	r3, r1
     a1e:	6053      	str	r3, [r2, #4]
	
	
}
     a20:	b002      	add	sp, #8
     a22:	bd70      	pop	{r4, r5, r6, pc}
     a24:	42001400 	.word	0x42001400
     a28:	fffbffff 	.word	0xfffbffff

00000a2c <StopCond>:
	}
	
void StopCond() {
//Function to generate a stop condition.

SERCOM3->I2CM.CTRLB.bit.CMD = 0x3;
     a2c:	4a03      	ldr	r2, [pc, #12]	; (a3c <StopCond+0x10>)
     a2e:	6851      	ldr	r1, [r2, #4]
     a30:	23c0      	movs	r3, #192	; 0xc0
     a32:	029b      	lsls	r3, r3, #10
     a34:	430b      	orrs	r3, r1
     a36:	6053      	str	r3, [r2, #4]
}
     a38:	4770      	bx	lr
     a3a:	46c0      	nop			; (mov r8, r8)
     a3c:	42001400 	.word	0x42001400

00000a40 <receiveI2CDataArray>:




void receiveI2CDataArray(int SlAddr, uint8_t **ptrData ,int Size){
     a40:	b5f0      	push	{r4, r5, r6, r7, lr}
	
	 SERCOM3->I2CM.ADDR.reg = (SlAddr << 1) | 1;
     a42:	0040      	lsls	r0, r0, #1
     a44:	2301      	movs	r3, #1
     a46:	4318      	orrs	r0, r3
     a48:	4b18      	ldr	r3, [pc, #96]	; (aac <receiveI2CDataArray+0x6c>)
     a4a:	6258      	str	r0, [r3, #36]	; 0x24
	 while(SERCOM3->I2CM.INTFLAG.bit.SB==0){};
     a4c:	0018      	movs	r0, r3
     a4e:	7e03      	ldrb	r3, [r0, #24]
     a50:	079b      	lsls	r3, r3, #30
     a52:	d5fc      	bpl.n	a4e <receiveI2CDataArray+0xe>

	 /* Acknowledge section is set as ACK signal by writing 0 in ACKACT bit */
	 SERCOM3->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
     a54:	4815      	ldr	r0, [pc, #84]	; (aac <receiveI2CDataArray+0x6c>)
     a56:	6843      	ldr	r3, [r0, #4]
     a58:	4c15      	ldr	r4, [pc, #84]	; (ab0 <receiveI2CDataArray+0x70>)
     a5a:	4023      	ands	r3, r4
     a5c:	6043      	str	r3, [r0, #4]

	 for(int i=0; i< Size-1; i++) {
     a5e:	1e53      	subs	r3, r2, #1
     a60:	2b00      	cmp	r3, #0
     a62:	dd0e      	ble.n	a82 <receiveI2CDataArray+0x42>
     a64:	000c      	movs	r4, r1
     a66:	4b13      	ldr	r3, [pc, #76]	; (ab4 <receiveI2CDataArray+0x74>)
     a68:	18d5      	adds	r5, r2, r3
     a6a:	00ad      	lsls	r5, r5, #2
     a6c:	194d      	adds	r5, r1, r5
		 *ptrData[i] = SERCOM3->I2CM.DATA.reg;
     a6e:	2628      	movs	r6, #40	; 0x28
     a70:	5d83      	ldrb	r3, [r0, r6]
     a72:	6827      	ldr	r7, [r4, #0]
     a74:	703b      	strb	r3, [r7, #0]
		 while(SERCOM3->I2CM.INTFLAG.bit.SB==0){};
     a76:	7e03      	ldrb	r3, [r0, #24]
     a78:	079b      	lsls	r3, r3, #30
     a7a:	d5fc      	bpl.n	a76 <receiveI2CDataArray+0x36>
     a7c:	3404      	adds	r4, #4
	 for(int i=0; i< Size-1; i++) {
     a7e:	42ac      	cmp	r4, r5
     a80:	d1f6      	bne.n	a70 <receiveI2CDataArray+0x30>
	 }
	 /* NACK should be send before reading the last byte*/
	 SERCOM3->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
     a82:	4b0a      	ldr	r3, [pc, #40]	; (aac <receiveI2CDataArray+0x6c>)
     a84:	685c      	ldr	r4, [r3, #4]
     a86:	2080      	movs	r0, #128	; 0x80
     a88:	02c0      	lsls	r0, r0, #11
     a8a:	4320      	orrs	r0, r4
     a8c:	6058      	str	r0, [r3, #4]
	 SERCOM3->I2CM.CTRLB.bit.CMD = 0x3;
     a8e:	685c      	ldr	r4, [r3, #4]
     a90:	20c0      	movs	r0, #192	; 0xc0
     a92:	0280      	lsls	r0, r0, #10
     a94:	4320      	orrs	r0, r4
     a96:	6058      	str	r0, [r3, #4]
	 *(ptrData[Size-1]) = SERCOM3->I2CM.DATA.reg;
     a98:	4806      	ldr	r0, [pc, #24]	; (ab4 <receiveI2CDataArray+0x74>)
     a9a:	4684      	mov	ip, r0
     a9c:	4462      	add	r2, ip
     a9e:	0092      	lsls	r2, r2, #2
     aa0:	5852      	ldr	r2, [r2, r1]
     aa2:	2128      	movs	r1, #40	; 0x28
     aa4:	5c5b      	ldrb	r3, [r3, r1]
     aa6:	7013      	strb	r3, [r2, #0]
	 
	
	
}
     aa8:	bdf0      	pop	{r4, r5, r6, r7, pc}
     aaa:	46c0      	nop			; (mov r8, r8)
     aac:	42001400 	.word	0x42001400
     ab0:	fffbffff 	.word	0xfffbffff
     ab4:	3fffffff 	.word	0x3fffffff

00000ab8 <ptrReloc>:

void ptrReloc(int Address,int slvAdd){
     ab8:	b510      	push	{r4, lr}
	
	 SERCOM3->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
     aba:	4a0e      	ldr	r2, [pc, #56]	; (af4 <ptrReloc+0x3c>)
     abc:	6853      	ldr	r3, [r2, #4]
     abe:	4c0e      	ldr	r4, [pc, #56]	; (af8 <ptrReloc+0x40>)
     ac0:	4023      	ands	r3, r4
     ac2:	6053      	str	r3, [r2, #4]
	 while(SERCOM3->I2CM.SYNCBUSY.reg); // waiting load
     ac4:	69d3      	ldr	r3, [r2, #28]
     ac6:	2b00      	cmp	r3, #0
     ac8:	d1fc      	bne.n	ac4 <ptrReloc+0xc>
	 /* slave address with write signal (0) */
	 SERCOM3->I2CM.ADDR.reg = (slvAdd << 1) | 0; /*Send slave addr write */
     aca:	0049      	lsls	r1, r1, #1
     acc:	4b09      	ldr	r3, [pc, #36]	; (af4 <ptrReloc+0x3c>)
     ace:	6259      	str	r1, [r3, #36]	; 0x24
	 while(SERCOM3->I2CM.INTFLAG.bit.MB ==0); /* MB=1 if slave NACKS address */
     ad0:	001a      	movs	r2, r3
     ad2:	7e13      	ldrb	r3, [r2, #24]
     ad4:	07db      	lsls	r3, r3, #31
     ad6:	d5fc      	bpl.n	ad2 <ptrReloc+0x1a>
	 SERCOM3->I2CM.DATA.reg = Address; /* Send address for internal pointer */
     ad8:	b2c0      	uxtb	r0, r0
     ada:	2328      	movs	r3, #40	; 0x28
     adc:	4a05      	ldr	r2, [pc, #20]	; (af4 <ptrReloc+0x3c>)
     ade:	54d0      	strb	r0, [r2, r3]
	 while(SERCOM3->I2CM.INTFLAG.bit.MB ==0){};/* MB=1 if slave NACKS the addr */
     ae0:	7e13      	ldrb	r3, [r2, #24]
     ae2:	07db      	lsls	r3, r3, #31
     ae4:	d5fc      	bpl.n	ae0 <ptrReloc+0x28>
	 SERCOM3->I2CM.CTRLB.bit.CMD = 0x3;     /* Sending stop condition */
     ae6:	4a03      	ldr	r2, [pc, #12]	; (af4 <ptrReloc+0x3c>)
     ae8:	6851      	ldr	r1, [r2, #4]
     aea:	23c0      	movs	r3, #192	; 0xc0
     aec:	029b      	lsls	r3, r3, #10
     aee:	430b      	orrs	r3, r1
     af0:	6053      	str	r3, [r2, #4]
	 
     af2:	bd10      	pop	{r4, pc}
     af4:	42001400 	.word	0x42001400
     af8:	fffbffff 	.word	0xfffbffff

00000afc <initUART>:
/* Replace with your library code */
void initUART(void) {

	/* APBCMASK */
   /* SERCOM 0 enable*/
	PM->APBCMASK.reg |= PM_APBCMASK_SERCOM0;
     afc:	4a1f      	ldr	r2, [pc, #124]	; (b7c <initUART+0x80>)
     afe:	6a13      	ldr	r3, [r2, #32]
     b00:	2104      	movs	r1, #4
     b02:	430b      	orrs	r3, r1
     b04:	6213      	str	r3, [r2, #32]

	/*GCLK configuration for sercom0 module: using generic clock generator 0, ID for sercom0, enable GCLK*/
    GCLK->GENCTRL.reg=GCLK_GENCTRL_SRC_OSC8M|GCLK_GENCTRL_ID(0)|
     b06:	4b1e      	ldr	r3, [pc, #120]	; (b80 <initUART+0x84>)
     b08:	2283      	movs	r2, #131	; 0x83
     b0a:	0252      	lsls	r2, r2, #9
     b0c:	605a      	str	r2, [r3, #4]
	GCLK_GENCTRL_GENEN;

	GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(SERCOM0_GCLK_ID_CORE) |
     b0e:	4a1d      	ldr	r2, [pc, #116]	; (b84 <initUART+0x88>)
     b10:	805a      	strh	r2, [r3, #2]
	GCLK_CLKCTRL_CLKEN | GCLK_CLKCTRL_GEN(0);

  /*CONFIGURAR PA10 y PA11 como salidas tipo C (SERCOM 0) */
  PORT->Group[0].PINCFG[PIN_PA10].reg= PA10_TX;
     b12:	4b1d      	ldr	r3, [pc, #116]	; (b88 <initUART+0x8c>)
     b14:	3903      	subs	r1, #3
     b16:	224a      	movs	r2, #74	; 0x4a
     b18:	5499      	strb	r1, [r3, r2]
  PORT->Group[0].PINCFG[PIN_PA11].reg= PA11_RX;
     b1a:	3106      	adds	r1, #6
     b1c:	3201      	adds	r2, #1
     b1e:	5499      	strb	r1, [r3, r2]
  PORT->Group[0].PMUX[5].bit.PMUXE=Type_C;
     b20:	312e      	adds	r1, #46	; 0x2e
     b22:	5c5a      	ldrb	r2, [r3, r1]
     b24:	200f      	movs	r0, #15
     b26:	4382      	bics	r2, r0
     b28:	2002      	movs	r0, #2
     b2a:	4302      	orrs	r2, r0
     b2c:	545a      	strb	r2, [r3, r1]
  PORT->Group[0].PMUX[5].bit.PMUXO=Type_C;
     b2e:	5c58      	ldrb	r0, [r3, r1]
     b30:	220f      	movs	r2, #15
     b32:	4002      	ands	r2, r0
     b34:	2020      	movs	r0, #32
     b36:	4302      	orrs	r2, r0
     b38:	545a      	strb	r2, [r3, r1]
	
	//desahibilitar UART para inicializacion
	SERCOM0->USART.CTRLA.bit.ENABLE=0;
     b3a:	4b14      	ldr	r3, [pc, #80]	; (b8c <initUART+0x90>)
     b3c:	681a      	ldr	r2, [r3, #0]
     b3e:	3933      	subs	r1, #51	; 0x33
     b40:	438a      	bics	r2, r1
     b42:	601a      	str	r2, [r3, #0]
   
   DEFINES:
   1)SERCOM_USART_CTRLA_DORD (_U(0x1) << SERCOM_USART_CTRLA_DORD_Pos)
   2)SERCOM_USART_CTRLA_MODE_USART_INT_CLK (0x1 << 2)
   3)SERCOM_USART_CTRLA_RXPO(value) (SERCOM_USART_CTRLA_RXPO_Msk & ((value) << SERCOM_USART_CTRLA_RXPO_Pos) */
	SERCOM0->USART.CTRLA.reg =
     b44:	4a12      	ldr	r2, [pc, #72]	; (b90 <initUART+0x94>)
     b46:	601a      	str	r2, [r3, #0]
	SERCOM_USART_CTRLA_DORD | SERCOM_USART_CTRLA_MODE_USART_INT_CLK |
	SERCOM_USART_CTRLA_RXPO(3) | SERCOM_USART_CTRLA_TXPO(1);
	
	while(SERCOM0->USART.SYNCBUSY.reg){} // waiting loading
     b48:	001a      	movs	r2, r3
     b4a:	69d3      	ldr	r3, [r2, #28]
     b4c:	2b00      	cmp	r3, #0
     b4e:	d1fc      	bne.n	b4a <initUART+0x4e>
	uint64_t br = (uint64_t)65536 * (8000000 - 16 * 9600) / 8000000;

	SERCOM0->USART.BAUD.reg = (uint16_t)br;
     b50:	4a10      	ldr	r2, [pc, #64]	; (b94 <initUART+0x98>)
     b52:	4b0e      	ldr	r3, [pc, #56]	; (b8c <initUART+0x90>)
     b54:	819a      	strh	r2, [r3, #12]
	
	while(SERCOM0->USART.SYNCBUSY.reg){} // waiting loading
     b56:	001a      	movs	r2, r3
     b58:	69d3      	ldr	r3, [r2, #28]
     b5a:	2b00      	cmp	r3, #0
     b5c:	d1fc      	bne.n	b58 <initUART+0x5c>
	SERCOM0->USART.CTRLB.reg = SERCOM_USART_CTRLB_RXEN | SERCOM_USART_CTRLB_TXEN | SERCOM_USART_CTRLB_CHSIZE(0/*8 bits*/);
     b5e:	22c0      	movs	r2, #192	; 0xc0
     b60:	0292      	lsls	r2, r2, #10
     b62:	4b0a      	ldr	r3, [pc, #40]	; (b8c <initUART+0x90>)
     b64:	605a      	str	r2, [r3, #4]
    while(SERCOM0->USART.SYNCBUSY.reg){} // waiting loading
     b66:	001a      	movs	r2, r3
     b68:	69d3      	ldr	r3, [r2, #28]
     b6a:	2b00      	cmp	r3, #0
     b6c:	d1fc      	bne.n	b68 <initUART+0x6c>
	SERCOM0->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
     b6e:	4a07      	ldr	r2, [pc, #28]	; (b8c <initUART+0x90>)
     b70:	6813      	ldr	r3, [r2, #0]
     b72:	2102      	movs	r1, #2
     b74:	430b      	orrs	r3, r1
     b76:	6013      	str	r3, [r2, #0]
}
     b78:	4770      	bx	lr
     b7a:	46c0      	nop			; (mov r8, r8)
     b7c:	40000400 	.word	0x40000400
     b80:	40000c00 	.word	0x40000c00
     b84:	00004014 	.word	0x00004014
     b88:	41004400 	.word	0x41004400
     b8c:	42000800 	.word	0x42000800
     b90:	40310004 	.word	0x40310004
     b94:	fffffb15 	.word	0xfffffb15

00000b98 <UART_Initialize>:

void UART_Initialize(uint32_t baudRate) {
     b98:	b570      	push	{r4, r5, r6, lr}
		.bit.PMUX = MUX_PB22D_SERCOM5_PAD2,
		.bit.PMUXEN = 1,
		.bit.HWSEL = 1,
		.bit.PINMASK = (uint16_t)( (PORT_PB22 | PORT_PB23 ) >> 16)
	};
	PORT->Group[1].WRCONFIG.reg = UARTWRConfig.reg;
     b9a:	4b13      	ldr	r3, [pc, #76]	; (be8 <UART_Initialize+0x50>)
     b9c:	6819      	ldr	r1, [r3, #0]
     b9e:	23a8      	movs	r3, #168	; 0xa8
     ba0:	4a12      	ldr	r2, [pc, #72]	; (bec <UART_Initialize+0x54>)
     ba2:	50d1      	str	r1, [r2, r3]
	
	// APBCMask to SERCOM5
	PM->APBCMASK.reg |= PM_APBCMASK_SERCOM5;
     ba4:	4a12      	ldr	r2, [pc, #72]	; (bf0 <UART_Initialize+0x58>)
     ba6:	6a13      	ldr	r3, [r2, #32]
     ba8:	2180      	movs	r1, #128	; 0x80
     baa:	430b      	orrs	r3, r1
     bac:	6213      	str	r3, [r2, #32]
	// Select generic clock
	GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(SERCOM5_GCLK_ID_CORE) | GCLK_CLKCTRL_CLKEN | GCLK_CLKCTRL_GEN(0);
     bae:	4a11      	ldr	r2, [pc, #68]	; (bf4 <UART_Initialize+0x5c>)
     bb0:	4b11      	ldr	r3, [pc, #68]	; (bf8 <UART_Initialize+0x60>)
     bb2:	805a      	strh	r2, [r3, #2]
	// CTRLA Config
	SERCOM5->USART.CTRLA.reg =	SERCOM_USART_CTRLA_DORD |
     bb4:	4c11      	ldr	r4, [pc, #68]	; (bfc <UART_Initialize+0x64>)
     bb6:	4b12      	ldr	r3, [pc, #72]	; (c00 <UART_Initialize+0x68>)
     bb8:	6023      	str	r3, [r4, #0]
	SERCOM_USART_CTRLA_RXPO(3) |
	SERCOM_USART_CTRLA_TXPO(1);
	// Calculate baud rate
	uint64_t calculatedBaud = (uint64_t)65535 * (8000000 - 16 * baudRate) / 8000000;
	// CTRLB Config
	SERCOM5->USART.CTRLB.reg = SERCOM_USART_CTRLB_RXEN | SERCOM_USART_CTRLB_TXEN | SERCOM_USART_CTRLB_CHSIZE(0);
     bba:	23c0      	movs	r3, #192	; 0xc0
     bbc:	029b      	lsls	r3, r3, #10
     bbe:	6063      	str	r3, [r4, #4]
	uint64_t calculatedBaud = (uint64_t)65535 * (8000000 - 16 * baudRate) / 8000000;
     bc0:	0100      	lsls	r0, r0, #4
     bc2:	4240      	negs	r0, r0
     bc4:	490f      	ldr	r1, [pc, #60]	; (c04 <UART_Initialize+0x6c>)
     bc6:	1842      	adds	r2, r0, r1
     bc8:	2300      	movs	r3, #0
     bca:	0c11      	lsrs	r1, r2, #16
     bcc:	0410      	lsls	r0, r2, #16
     bce:	1a80      	subs	r0, r0, r2
     bd0:	4199      	sbcs	r1, r3
     bd2:	4a0c      	ldr	r2, [pc, #48]	; (c04 <UART_Initialize+0x6c>)
     bd4:	2300      	movs	r3, #0
     bd6:	4d0c      	ldr	r5, [pc, #48]	; (c08 <UART_Initialize+0x70>)
     bd8:	47a8      	blx	r5
	// Set Baud
	SERCOM5->USART.BAUD.reg = (uint16_t)calculatedBaud;
     bda:	b280      	uxth	r0, r0
     bdc:	81a0      	strh	r0, [r4, #12]
	// Enable peripheral
	SERCOM5->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
     bde:	6823      	ldr	r3, [r4, #0]
     be0:	2202      	movs	r2, #2
     be2:	4313      	orrs	r3, r2
     be4:	6023      	str	r3, [r4, #0]
}
     be6:	bd70      	pop	{r4, r5, r6, pc}
     be8:	00002634 	.word	0x00002634
     bec:	41004400 	.word	0x41004400
     bf0:	40000400 	.word	0x40000400
     bf4:	00004019 	.word	0x00004019
     bf8:	40000c00 	.word	0x40000c00
     bfc:	42001c00 	.word	0x42001c00
     c00:	40310004 	.word	0x40310004
     c04:	007a1200 	.word	0x007a1200
     c08:	00002185 	.word	0x00002185

00000c0c <prvTaskExitError>:
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
     c0c:	4b03      	ldr	r3, [pc, #12]	; (c1c <prvTaskExitError+0x10>)
     c0e:	681b      	ldr	r3, [r3, #0]
     c10:	3301      	adds	r3, #1
     c12:	d001      	beq.n	c18 <prvTaskExitError+0xc>
     c14:	b672      	cpsid	i
     c16:	e7fe      	b.n	c16 <prvTaskExitError+0xa>
	portDISABLE_INTERRUPTS();
     c18:	b672      	cpsid	i
     c1a:	e7fe      	b.n	c1a <prvTaskExitError+0xe>
     c1c:	2000003c 	.word	0x2000003c

00000c20 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
	table offset register that can be used to locate the initial stack value.
	Not all M0 parts have the application vector table at address 0. */
	__asm volatile(
     c20:	4a06      	ldr	r2, [pc, #24]	; (c3c <pxCurrentTCBConst2>)
     c22:	6813      	ldr	r3, [r2, #0]
     c24:	6818      	ldr	r0, [r3, #0]
     c26:	3020      	adds	r0, #32
     c28:	f380 8809 	msr	PSP, r0
     c2c:	2002      	movs	r0, #2
     c2e:	f380 8814 	msr	CONTROL, r0
     c32:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
     c34:	46ae      	mov	lr, r5
     c36:	b662      	cpsie	i
     c38:	bd00      	pop	{pc}
     c3a:	46c0      	nop			; (mov r8, r8)

00000c3c <pxCurrentTCBConst2>:
     c3c:	20003f88 	.word	0x20003f88

00000c40 <pxPortInitialiseStack>:
{
     c40:	b510      	push	{r4, lr}
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
     c42:	1f03      	subs	r3, r0, #4
     c44:	2480      	movs	r4, #128	; 0x80
     c46:	0464      	lsls	r4, r4, #17
     c48:	601c      	str	r4, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
     c4a:	3b04      	subs	r3, #4
     c4c:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
     c4e:	3b04      	subs	r3, #4
     c50:	4902      	ldr	r1, [pc, #8]	; (c5c <pxPortInitialiseStack+0x1c>)
     c52:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
     c54:	3b14      	subs	r3, #20
     c56:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8; /* R11..R4. */
     c58:	3840      	subs	r0, #64	; 0x40
}
     c5a:	bd10      	pop	{r4, pc}
     c5c:	00000c0d 	.word	0x00000c0d

00000c60 <vPortYield>:
/*-----------------------------------------------------------*/

void vPortYield( void )
{
	/* Set a PendSV to request a context switch. */
	*( portNVIC_INT_CTRL ) = portNVIC_PENDSVSET;
     c60:	2280      	movs	r2, #128	; 0x80
     c62:	0552      	lsls	r2, r2, #21
     c64:	4b03      	ldr	r3, [pc, #12]	; (c74 <vPortYield+0x14>)
     c66:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is completely
	within the specified behaviour for the architecture. */
	__asm volatile( "dsb" );
     c68:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
     c6c:	f3bf 8f6f 	isb	sy
}
     c70:	4770      	bx	lr
     c72:	46c0      	nop			; (mov r8, r8)
     c74:	e000ed04 	.word	0xe000ed04

00000c78 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
    portDISABLE_INTERRUPTS();
     c78:	b672      	cpsid	i
    uxCriticalNesting++;
     c7a:	4a04      	ldr	r2, [pc, #16]	; (c8c <vPortEnterCritical+0x14>)
     c7c:	6813      	ldr	r3, [r2, #0]
     c7e:	3301      	adds	r3, #1
     c80:	6013      	str	r3, [r2, #0]
	__asm volatile( "dsb" );
     c82:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
     c86:	f3bf 8f6f 	isb	sy
}
     c8a:	4770      	bx	lr
     c8c:	2000003c 	.word	0x2000003c

00000c90 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	configASSERT( uxCriticalNesting );
     c90:	4b06      	ldr	r3, [pc, #24]	; (cac <vPortExitCritical+0x1c>)
     c92:	681b      	ldr	r3, [r3, #0]
     c94:	2b00      	cmp	r3, #0
     c96:	d101      	bne.n	c9c <vPortExitCritical+0xc>
     c98:	b672      	cpsid	i
     c9a:	e7fe      	b.n	c9a <vPortExitCritical+0xa>
    uxCriticalNesting--;
     c9c:	3b01      	subs	r3, #1
     c9e:	4a03      	ldr	r2, [pc, #12]	; (cac <vPortExitCritical+0x1c>)
     ca0:	6013      	str	r3, [r2, #0]
    if( uxCriticalNesting == 0 )
     ca2:	2b00      	cmp	r3, #0
     ca4:	d100      	bne.n	ca8 <vPortExitCritical+0x18>
    {
        portENABLE_INTERRUPTS();
     ca6:	b662      	cpsie	i
    }
}
     ca8:	4770      	bx	lr
     caa:	46c0      	nop			; (mov r8, r8)
     cac:	2000003c 	.word	0x2000003c

00000cb0 <ulSetInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

uint32_t ulSetInterruptMaskFromISR( void )
{
	__asm volatile(
     cb0:	f3ef 8010 	mrs	r0, PRIMASK
     cb4:	b672      	cpsid	i
     cb6:	4770      	bx	lr
					" bx lr				  "
				  );

	/* To avoid compiler warnings.  This line will never be reached. */
	return 0;
}
     cb8:	2000      	movs	r0, #0

00000cba <vClearInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

void vClearInterruptMaskFromISR( uint32_t ulMask )
{
	__asm volatile(
     cba:	f380 8810 	msr	PRIMASK, r0
     cbe:	4770      	bx	lr

00000cc0 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
     cc0:	f3ef 8009 	mrs	r0, PSP
     cc4:	4b0e      	ldr	r3, [pc, #56]	; (d00 <pxCurrentTCBConst>)
     cc6:	681a      	ldr	r2, [r3, #0]
     cc8:	3820      	subs	r0, #32
     cca:	6010      	str	r0, [r2, #0]
     ccc:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
     cce:	4644      	mov	r4, r8
     cd0:	464d      	mov	r5, r9
     cd2:	4656      	mov	r6, sl
     cd4:	465f      	mov	r7, fp
     cd6:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
     cd8:	b508      	push	{r3, lr}
     cda:	b672      	cpsid	i
     cdc:	f000 fef8 	bl	1ad0 <vTaskSwitchContext>
     ce0:	b662      	cpsie	i
     ce2:	bc0c      	pop	{r2, r3}
     ce4:	6811      	ldr	r1, [r2, #0]
     ce6:	6808      	ldr	r0, [r1, #0]
     ce8:	3010      	adds	r0, #16
     cea:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
     cec:	46a0      	mov	r8, r4
     cee:	46a9      	mov	r9, r5
     cf0:	46b2      	mov	sl, r6
     cf2:	46bb      	mov	fp, r7
     cf4:	f380 8809 	msr	PSP, r0
     cf8:	3820      	subs	r0, #32
     cfa:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
     cfc:	4718      	bx	r3
     cfe:	46c0      	nop			; (mov r8, r8)

00000d00 <pxCurrentTCBConst>:
     d00:	20003f88 	.word	0x20003f88

00000d04 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
     d04:	b510      	push	{r4, lr}
uint32_t ulPreviousMask;

	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
     d06:	4b07      	ldr	r3, [pc, #28]	; (d24 <SysTick_Handler+0x20>)
     d08:	4798      	blx	r3
     d0a:	0004      	movs	r4, r0
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
     d0c:	4b06      	ldr	r3, [pc, #24]	; (d28 <SysTick_Handler+0x24>)
     d0e:	4798      	blx	r3
     d10:	2800      	cmp	r0, #0
     d12:	d003      	beq.n	d1c <SysTick_Handler+0x18>
		{
			/* Pend a context switch. */
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
     d14:	2280      	movs	r2, #128	; 0x80
     d16:	0552      	lsls	r2, r2, #21
     d18:	4b04      	ldr	r3, [pc, #16]	; (d2c <SysTick_Handler+0x28>)
     d1a:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
     d1c:	0020      	movs	r0, r4
     d1e:	4b04      	ldr	r3, [pc, #16]	; (d30 <SysTick_Handler+0x2c>)
     d20:	4798      	blx	r3
}
     d22:	bd10      	pop	{r4, pc}
     d24:	00000cb1 	.word	0x00000cb1
     d28:	000017f1 	.word	0x000017f1
     d2c:	e000ed04 	.word	0xe000ed04
     d30:	00000cbb 	.word	0x00000cbb

00000d34 <vPortSetupTimerInterrupt>:
 * frequency.
 */
__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
{
	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_VAL)  = 0; /* Load the SysTick Counter Value */
     d34:	2200      	movs	r2, #0
     d36:	4b04      	ldr	r3, [pc, #16]	; (d48 <vPortSetupTimerInterrupt+0x14>)
     d38:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
     d3a:	4a04      	ldr	r2, [pc, #16]	; (d4c <vPortSetupTimerInterrupt+0x18>)
     d3c:	4b04      	ldr	r3, [pc, #16]	; (d50 <vPortSetupTimerInterrupt+0x1c>)
     d3e:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
     d40:	2207      	movs	r2, #7
     d42:	4b04      	ldr	r3, [pc, #16]	; (d54 <vPortSetupTimerInterrupt+0x20>)
     d44:	601a      	str	r2, [r3, #0]
}
     d46:	4770      	bx	lr
     d48:	e000e018 	.word	0xe000e018
     d4c:	00001f3f 	.word	0x00001f3f
     d50:	e000e014 	.word	0xe000e014
     d54:	e000e010 	.word	0xe000e010

00000d58 <xPortStartScheduler>:
{
     d58:	b510      	push	{r4, lr}
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
     d5a:	4b0a      	ldr	r3, [pc, #40]	; (d84 <xPortStartScheduler+0x2c>)
     d5c:	6819      	ldr	r1, [r3, #0]
     d5e:	22ff      	movs	r2, #255	; 0xff
     d60:	0412      	lsls	r2, r2, #16
     d62:	430a      	orrs	r2, r1
     d64:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
     d66:	6819      	ldr	r1, [r3, #0]
     d68:	22ff      	movs	r2, #255	; 0xff
     d6a:	0612      	lsls	r2, r2, #24
     d6c:	430a      	orrs	r2, r1
     d6e:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
     d70:	4b05      	ldr	r3, [pc, #20]	; (d88 <xPortStartScheduler+0x30>)
     d72:	4798      	blx	r3
	uxCriticalNesting = 0;
     d74:	2200      	movs	r2, #0
     d76:	4b05      	ldr	r3, [pc, #20]	; (d8c <xPortStartScheduler+0x34>)
     d78:	601a      	str	r2, [r3, #0]
	vPortStartFirstTask();
     d7a:	4b05      	ldr	r3, [pc, #20]	; (d90 <xPortStartScheduler+0x38>)
     d7c:	4798      	blx	r3
	prvTaskExitError();
     d7e:	4b05      	ldr	r3, [pc, #20]	; (d94 <xPortStartScheduler+0x3c>)
     d80:	4798      	blx	r3
     d82:	46c0      	nop			; (mov r8, r8)
     d84:	e000ed20 	.word	0xe000ed20
     d88:	00000d35 	.word	0x00000d35
     d8c:	2000003c 	.word	0x2000003c
     d90:	00000c21 	.word	0x00000c21
     d94:	00000c0d 	.word	0x00000c0d

00000d98 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     d98:	b570      	push	{r4, r5, r6, lr}
     d9a:	0004      	movs	r4, r0
void *pvReturn = NULL;
static uint8_t *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if portBYTE_ALIGNMENT != 1
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
     d9c:	0743      	lsls	r3, r0, #29
     d9e:	d002      	beq.n	da6 <pvPortMalloc+0xe>
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
     da0:	2307      	movs	r3, #7
     da2:	439c      	bics	r4, r3
     da4:	3408      	adds	r4, #8
		}
	#endif

	vTaskSuspendAll();
     da6:	4b11      	ldr	r3, [pc, #68]	; (dec <pvPortMalloc+0x54>)
     da8:	4798      	blx	r3
	{
		if( pucAlignedHeap == NULL )
     daa:	4b11      	ldr	r3, [pc, #68]	; (df0 <pvPortMalloc+0x58>)
     dac:	681b      	ldr	r3, [r3, #0]
     dae:	2b00      	cmp	r3, #0
     db0:	d010      	beq.n	dd4 <pvPortMalloc+0x3c>
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     db2:	4b10      	ldr	r3, [pc, #64]	; (df4 <pvPortMalloc+0x5c>)
     db4:	69db      	ldr	r3, [r3, #28]
     db6:	18e4      	adds	r4, r4, r3
     db8:	4a0f      	ldr	r2, [pc, #60]	; (df8 <pvPortMalloc+0x60>)
     dba:	4294      	cmp	r4, r2
     dbc:	d811      	bhi.n	de2 <pvPortMalloc+0x4a>
     dbe:	42a3      	cmp	r3, r4
     dc0:	d211      	bcs.n	de6 <pvPortMalloc+0x4e>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     dc2:	4a0b      	ldr	r2, [pc, #44]	; (df0 <pvPortMalloc+0x58>)
     dc4:	6815      	ldr	r5, [r2, #0]
     dc6:	18ed      	adds	r5, r5, r3
			xNextFreeByte += xWantedSize;
     dc8:	4b0a      	ldr	r3, [pc, #40]	; (df4 <pvPortMalloc+0x5c>)
     dca:	61dc      	str	r4, [r3, #28]
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     dcc:	4b0b      	ldr	r3, [pc, #44]	; (dfc <pvPortMalloc+0x64>)
     dce:	4798      	blx	r3
		}
	}
	#endif

	return pvReturn;
}
     dd0:	0028      	movs	r0, r5
     dd2:	bd70      	pop	{r4, r5, r6, pc}
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     dd4:	4a06      	ldr	r2, [pc, #24]	; (df0 <pvPortMalloc+0x58>)
     dd6:	0013      	movs	r3, r2
     dd8:	330c      	adds	r3, #12
     dda:	2107      	movs	r1, #7
     ddc:	438b      	bics	r3, r1
     dde:	6013      	str	r3, [r2, #0]
     de0:	e7e7      	b.n	db2 <pvPortMalloc+0x1a>
void *pvReturn = NULL;
     de2:	2500      	movs	r5, #0
     de4:	e7f2      	b.n	dcc <pvPortMalloc+0x34>
     de6:	2500      	movs	r5, #0
     de8:	e7f0      	b.n	dcc <pvPortMalloc+0x34>
     dea:	46c0      	nop			; (mov r8, r8)
     dec:	000017c1 	.word	0x000017c1
     df0:	200004bc 	.word	0x200004bc
     df4:	20003f3c 	.word	0x20003f3c
     df8:	00003a8f 	.word	0x00003a8f
     dfc:	00001901 	.word	0x00001901

00000e00 <vPortFree>:
	heap_4.c for alternative implementations, and the memory management pages of
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
     e00:	2800      	cmp	r0, #0
     e02:	d001      	beq.n	e08 <vPortFree+0x8>
     e04:	b672      	cpsid	i
     e06:	e7fe      	b.n	e06 <vPortFree+0x6>
}
     e08:	4770      	bx	lr

00000e0a <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     e0a:	0003      	movs	r3, r0
     e0c:	3308      	adds	r3, #8
     e0e:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     e10:	2201      	movs	r2, #1
     e12:	4252      	negs	r2, r2
     e14:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     e16:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     e18:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     e1a:	2300      	movs	r3, #0
     e1c:	6003      	str	r3, [r0, #0]
}
     e1e:	4770      	bx	lr

00000e20 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     e20:	2300      	movs	r3, #0
     e22:	6103      	str	r3, [r0, #16]
}
     e24:	4770      	bx	lr

00000e26 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
     e26:	6843      	ldr	r3, [r0, #4]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     e28:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     e2a:	689a      	ldr	r2, [r3, #8]
     e2c:	608a      	str	r2, [r1, #8]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     e2e:	689a      	ldr	r2, [r3, #8]
     e30:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
     e32:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     e34:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
     e36:	6803      	ldr	r3, [r0, #0]
     e38:	3301      	adds	r3, #1
     e3a:	6003      	str	r3, [r0, #0]
}
     e3c:	4770      	bx	lr

00000e3e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     e3e:	b530      	push	{r4, r5, lr}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     e40:	680c      	ldr	r4, [r1, #0]
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     e42:	0002      	movs	r2, r0
     e44:	3208      	adds	r2, #8
	if( xValueOfInsertion == portMAX_DELAY )
     e46:	1c63      	adds	r3, r4, #1
     e48:	d102      	bne.n	e50 <vListInsert+0x12>
		pxIterator = pxList->xListEnd.pxPrevious;
     e4a:	6902      	ldr	r2, [r0, #16]
     e4c:	e004      	b.n	e58 <vListInsert+0x1a>
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     e4e:	001a      	movs	r2, r3
     e50:	6853      	ldr	r3, [r2, #4]
     e52:	681d      	ldr	r5, [r3, #0]
     e54:	42ac      	cmp	r4, r5
     e56:	d2fa      	bcs.n	e4e <vListInsert+0x10>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     e58:	6853      	ldr	r3, [r2, #4]
     e5a:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     e5c:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
     e5e:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
     e60:	6051      	str	r1, [r2, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     e62:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
     e64:	6803      	ldr	r3, [r0, #0]
     e66:	3301      	adds	r3, #1
     e68:	6003      	str	r3, [r0, #0]
}
     e6a:	bd30      	pop	{r4, r5, pc}

00000e6c <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     e6c:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     e6e:	6842      	ldr	r2, [r0, #4]
     e70:	6881      	ldr	r1, [r0, #8]
     e72:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     e74:	6882      	ldr	r2, [r0, #8]
     e76:	6841      	ldr	r1, [r0, #4]
     e78:	6051      	str	r1, [r2, #4]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     e7a:	685a      	ldr	r2, [r3, #4]
     e7c:	4290      	cmp	r0, r2
     e7e:	d005      	beq.n	e8c <uxListRemove+0x20>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     e80:	2200      	movs	r2, #0
     e82:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
     e84:	681a      	ldr	r2, [r3, #0]
     e86:	1e50      	subs	r0, r2, #1
     e88:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
     e8a:	4770      	bx	lr
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     e8c:	6882      	ldr	r2, [r0, #8]
     e8e:	605a      	str	r2, [r3, #4]
     e90:	e7f6      	b.n	e80 <uxListRemove+0x14>
	...

00000e94 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     e94:	b570      	push	{r4, r5, r6, lr}
     e96:	0004      	movs	r4, r0
     e98:	0015      	movs	r5, r2
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     e9a:	6c02      	ldr	r2, [r0, #64]	; 0x40
     e9c:	2a00      	cmp	r2, #0
     e9e:	d10b      	bne.n	eb8 <prvCopyDataToQueue+0x24>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     ea0:	6803      	ldr	r3, [r0, #0]
     ea2:	2b00      	cmp	r3, #0
     ea4:	d104      	bne.n	eb0 <prvCopyDataToQueue+0x1c>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     ea6:	6840      	ldr	r0, [r0, #4]
     ea8:	4b17      	ldr	r3, [pc, #92]	; (f08 <prvCopyDataToQueue+0x74>)
     eaa:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
     eac:	2300      	movs	r3, #0
     eae:	6063      	str	r3, [r4, #4]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
     eb0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     eb2:	3301      	adds	r3, #1
     eb4:	63a3      	str	r3, [r4, #56]	; 0x38
}
     eb6:	bd70      	pop	{r4, r5, r6, pc}
	else if( xPosition == queueSEND_TO_BACK )
     eb8:	2d00      	cmp	r5, #0
     eba:	d10d      	bne.n	ed8 <prvCopyDataToQueue+0x44>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     ebc:	6880      	ldr	r0, [r0, #8]
     ebe:	4b13      	ldr	r3, [pc, #76]	; (f0c <prvCopyDataToQueue+0x78>)
     ec0:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     ec2:	68a3      	ldr	r3, [r4, #8]
     ec4:	6c22      	ldr	r2, [r4, #64]	; 0x40
     ec6:	4694      	mov	ip, r2
     ec8:	4463      	add	r3, ip
     eca:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     ecc:	6862      	ldr	r2, [r4, #4]
     ece:	4293      	cmp	r3, r2
     ed0:	d3ee      	bcc.n	eb0 <prvCopyDataToQueue+0x1c>
			pxQueue->pcWriteTo = pxQueue->pcHead;
     ed2:	6823      	ldr	r3, [r4, #0]
     ed4:	60a3      	str	r3, [r4, #8]
     ed6:	e7eb      	b.n	eb0 <prvCopyDataToQueue+0x1c>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     ed8:	68c0      	ldr	r0, [r0, #12]
     eda:	4b0c      	ldr	r3, [pc, #48]	; (f0c <prvCopyDataToQueue+0x78>)
     edc:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     ede:	6c23      	ldr	r3, [r4, #64]	; 0x40
     ee0:	425b      	negs	r3, r3
     ee2:	68e2      	ldr	r2, [r4, #12]
     ee4:	18d2      	adds	r2, r2, r3
     ee6:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     ee8:	6821      	ldr	r1, [r4, #0]
     eea:	428a      	cmp	r2, r1
     eec:	d203      	bcs.n	ef6 <prvCopyDataToQueue+0x62>
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     eee:	6862      	ldr	r2, [r4, #4]
     ef0:	4694      	mov	ip, r2
     ef2:	4463      	add	r3, ip
     ef4:	60e3      	str	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
     ef6:	2d02      	cmp	r5, #2
     ef8:	d1da      	bne.n	eb0 <prvCopyDataToQueue+0x1c>
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     efa:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     efc:	2b00      	cmp	r3, #0
     efe:	d0d7      	beq.n	eb0 <prvCopyDataToQueue+0x1c>
				--( pxQueue->uxMessagesWaiting );
     f00:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     f02:	3b01      	subs	r3, #1
     f04:	63a3      	str	r3, [r4, #56]	; 0x38
     f06:	e7d3      	b.n	eb0 <prvCopyDataToQueue+0x1c>
     f08:	00001db9 	.word	0x00001db9
     f0c:	000023e1 	.word	0x000023e1

00000f10 <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
	{
     f10:	b510      	push	{r4, lr}
     f12:	b082      	sub	sp, #8
     f14:	9001      	str	r0, [sp, #4]
     f16:	000a      	movs	r2, r1
	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
     f18:	6cc4      	ldr	r4, [r0, #76]	; 0x4c
	BaseType_t xReturn = pdFALSE;

		/* This function must be called form a critical section. */

		configASSERT( pxQueueSetContainer );
     f1a:	2c00      	cmp	r4, #0
     f1c:	d005      	beq.n	f2a <prvNotifyQueueSetContainer+0x1a>
		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
     f1e:	6ba1      	ldr	r1, [r4, #56]	; 0x38
     f20:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     f22:	4299      	cmp	r1, r3
     f24:	d303      	bcc.n	f2e <prvNotifyQueueSetContainer+0x1e>
     f26:	b672      	cpsid	i
     f28:	e7fe      	b.n	f28 <prvNotifyQueueSetContainer+0x18>
		configASSERT( pxQueueSetContainer );
     f2a:	b672      	cpsid	i
     f2c:	e7fe      	b.n	f2c <prvNotifyQueueSetContainer+0x1c>

		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
     f2e:	6ba1      	ldr	r1, [r4, #56]	; 0x38
	BaseType_t xReturn = pdFALSE;
     f30:	2000      	movs	r0, #0
		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
     f32:	428b      	cmp	r3, r1
     f34:	d801      	bhi.n	f3a <prvNotifyQueueSetContainer+0x2a>
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
     f36:	b002      	add	sp, #8
     f38:	bd10      	pop	{r4, pc}
			prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
     f3a:	a901      	add	r1, sp, #4
     f3c:	0020      	movs	r0, r4
     f3e:	4b06      	ldr	r3, [pc, #24]	; (f58 <prvNotifyQueueSetContainer+0x48>)
     f40:	4798      	blx	r3
	BaseType_t xReturn = pdFALSE;
     f42:	2000      	movs	r0, #0
			if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
     f44:	6a63      	ldr	r3, [r4, #36]	; 0x24
     f46:	2b00      	cmp	r3, #0
     f48:	d0f5      	beq.n	f36 <prvNotifyQueueSetContainer+0x26>
				if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
     f4a:	0020      	movs	r0, r4
     f4c:	3024      	adds	r0, #36	; 0x24
     f4e:	4b03      	ldr	r3, [pc, #12]	; (f5c <prvNotifyQueueSetContainer+0x4c>)
     f50:	4798      	blx	r3
	BaseType_t xReturn = pdFALSE;
     f52:	1e43      	subs	r3, r0, #1
     f54:	4198      	sbcs	r0, r3
     f56:	e7ee      	b.n	f36 <prvNotifyQueueSetContainer+0x26>
     f58:	00000e95 	.word	0x00000e95
     f5c:	00001bf9 	.word	0x00001bf9

00000f60 <prvCopyDataFromQueue>:
{
     f60:	b570      	push	{r4, r5, r6, lr}
     f62:	000c      	movs	r4, r1
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     f64:	6801      	ldr	r1, [r0, #0]
     f66:	2900      	cmp	r1, #0
     f68:	d00b      	beq.n	f82 <prvCopyDataFromQueue+0x22>
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     f6a:	6c02      	ldr	r2, [r0, #64]	; 0x40
     f6c:	68c3      	ldr	r3, [r0, #12]
     f6e:	189b      	adds	r3, r3, r2
     f70:	60c3      	str	r3, [r0, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     f72:	6845      	ldr	r5, [r0, #4]
     f74:	42ab      	cmp	r3, r5
     f76:	d300      	bcc.n	f7a <prvCopyDataFromQueue+0x1a>
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     f78:	60c1      	str	r1, [r0, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     f7a:	68c1      	ldr	r1, [r0, #12]
     f7c:	0020      	movs	r0, r4
     f7e:	4b01      	ldr	r3, [pc, #4]	; (f84 <prvCopyDataFromQueue+0x24>)
     f80:	4798      	blx	r3
}
     f82:	bd70      	pop	{r4, r5, r6, pc}
     f84:	000023e1 	.word	0x000023e1

00000f88 <prvUnlockQueue>:
{
     f88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     f8a:	0004      	movs	r4, r0
	taskENTER_CRITICAL();
     f8c:	4b25      	ldr	r3, [pc, #148]	; (1024 <prvUnlockQueue+0x9c>)
     f8e:	4798      	blx	r3
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     f90:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     f92:	2b00      	cmp	r3, #0
     f94:	dd1e      	ble.n	fd4 <prvUnlockQueue+0x4c>
					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
     f96:	4d24      	ldr	r5, [pc, #144]	; (1028 <prvUnlockQueue+0xa0>)
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     f98:	4e24      	ldr	r6, [pc, #144]	; (102c <prvUnlockQueue+0xa4>)
     f9a:	e00d      	b.n	fb8 <prvUnlockQueue+0x30>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     f9c:	6a63      	ldr	r3, [r4, #36]	; 0x24
     f9e:	2b00      	cmp	r3, #0
     fa0:	d018      	beq.n	fd4 <prvUnlockQueue+0x4c>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     fa2:	0020      	movs	r0, r4
     fa4:	3024      	adds	r0, #36	; 0x24
     fa6:	47b0      	blx	r6
     fa8:	2800      	cmp	r0, #0
     faa:	d110      	bne.n	fce <prvUnlockQueue+0x46>
			--( pxQueue->xTxLock );
     fac:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     fae:	3b01      	subs	r3, #1
     fb0:	64a3      	str	r3, [r4, #72]	; 0x48
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     fb2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     fb4:	2b00      	cmp	r3, #0
     fb6:	dd0d      	ble.n	fd4 <prvUnlockQueue+0x4c>
				if( pxQueue->pxQueueSetContainer != NULL )
     fb8:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
     fba:	2b00      	cmp	r3, #0
     fbc:	d0ee      	beq.n	f9c <prvUnlockQueue+0x14>
					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
     fbe:	2100      	movs	r1, #0
     fc0:	0020      	movs	r0, r4
     fc2:	47a8      	blx	r5
     fc4:	2801      	cmp	r0, #1
     fc6:	d1f1      	bne.n	fac <prvUnlockQueue+0x24>
						vTaskMissedYield();
     fc8:	4b19      	ldr	r3, [pc, #100]	; (1030 <prvUnlockQueue+0xa8>)
     fca:	4798      	blx	r3
     fcc:	e7ee      	b.n	fac <prvUnlockQueue+0x24>
							vTaskMissedYield();
     fce:	4b18      	ldr	r3, [pc, #96]	; (1030 <prvUnlockQueue+0xa8>)
     fd0:	4798      	blx	r3
     fd2:	e7eb      	b.n	fac <prvUnlockQueue+0x24>
		pxQueue->xTxLock = queueUNLOCKED;
     fd4:	2301      	movs	r3, #1
     fd6:	425b      	negs	r3, r3
     fd8:	64a3      	str	r3, [r4, #72]	; 0x48
	taskEXIT_CRITICAL();
     fda:	4b16      	ldr	r3, [pc, #88]	; (1034 <prvUnlockQueue+0xac>)
     fdc:	4798      	blx	r3
	taskENTER_CRITICAL();
     fde:	4b11      	ldr	r3, [pc, #68]	; (1024 <prvUnlockQueue+0x9c>)
     fe0:	4798      	blx	r3
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     fe2:	6c63      	ldr	r3, [r4, #68]	; 0x44
     fe4:	2b00      	cmp	r3, #0
     fe6:	dd16      	ble.n	1016 <prvUnlockQueue+0x8e>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     fe8:	6923      	ldr	r3, [r4, #16]
     fea:	2b00      	cmp	r3, #0
     fec:	d013      	beq.n	1016 <prvUnlockQueue+0x8e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     fee:	0025      	movs	r5, r4
     ff0:	3510      	adds	r5, #16
     ff2:	4f0e      	ldr	r7, [pc, #56]	; (102c <prvUnlockQueue+0xa4>)
					vTaskMissedYield();
     ff4:	4e0e      	ldr	r6, [pc, #56]	; (1030 <prvUnlockQueue+0xa8>)
     ff6:	e008      	b.n	100a <prvUnlockQueue+0x82>
				--( pxQueue->xRxLock );
     ff8:	6c63      	ldr	r3, [r4, #68]	; 0x44
     ffa:	3b01      	subs	r3, #1
     ffc:	6463      	str	r3, [r4, #68]	; 0x44
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     ffe:	6c63      	ldr	r3, [r4, #68]	; 0x44
    1000:	2b00      	cmp	r3, #0
    1002:	dd08      	ble.n	1016 <prvUnlockQueue+0x8e>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1004:	6923      	ldr	r3, [r4, #16]
    1006:	2b00      	cmp	r3, #0
    1008:	d005      	beq.n	1016 <prvUnlockQueue+0x8e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    100a:	0028      	movs	r0, r5
    100c:	47b8      	blx	r7
    100e:	2800      	cmp	r0, #0
    1010:	d0f2      	beq.n	ff8 <prvUnlockQueue+0x70>
					vTaskMissedYield();
    1012:	47b0      	blx	r6
    1014:	e7f0      	b.n	ff8 <prvUnlockQueue+0x70>
		pxQueue->xRxLock = queueUNLOCKED;
    1016:	2301      	movs	r3, #1
    1018:	425b      	negs	r3, r3
    101a:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
    101c:	4b05      	ldr	r3, [pc, #20]	; (1034 <prvUnlockQueue+0xac>)
    101e:	4798      	blx	r3
}
    1020:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1022:	46c0      	nop			; (mov r8, r8)
    1024:	00000c79 	.word	0x00000c79
    1028:	00000f11 	.word	0x00000f11
    102c:	00001bf9 	.word	0x00001bf9
    1030:	00001d05 	.word	0x00001d05
    1034:	00000c91 	.word	0x00000c91

00001038 <xQueueGenericReset>:
{
    1038:	b570      	push	{r4, r5, r6, lr}
    103a:	0004      	movs	r4, r0
    103c:	000d      	movs	r5, r1
	configASSERT( pxQueue );
    103e:	2800      	cmp	r0, #0
    1040:	d020      	beq.n	1084 <xQueueGenericReset+0x4c>
	taskENTER_CRITICAL();
    1042:	4b17      	ldr	r3, [pc, #92]	; (10a0 <xQueueGenericReset+0x68>)
    1044:	4798      	blx	r3
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1046:	6822      	ldr	r2, [r4, #0]
    1048:	6c21      	ldr	r1, [r4, #64]	; 0x40
    104a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    104c:	434b      	muls	r3, r1
    104e:	18d0      	adds	r0, r2, r3
    1050:	6060      	str	r0, [r4, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1052:	2000      	movs	r0, #0
    1054:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1056:	60a2      	str	r2, [r4, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    1058:	1a5b      	subs	r3, r3, r1
    105a:	18d3      	adds	r3, r2, r3
    105c:	60e3      	str	r3, [r4, #12]
		pxQueue->xRxLock = queueUNLOCKED;
    105e:	2301      	movs	r3, #1
    1060:	425b      	negs	r3, r3
    1062:	6463      	str	r3, [r4, #68]	; 0x44
		pxQueue->xTxLock = queueUNLOCKED;
    1064:	64a3      	str	r3, [r4, #72]	; 0x48
		if( xNewQueue == pdFALSE )
    1066:	2d00      	cmp	r5, #0
    1068:	d111      	bne.n	108e <xQueueGenericReset+0x56>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    106a:	6923      	ldr	r3, [r4, #16]
    106c:	2b00      	cmp	r3, #0
    106e:	d005      	beq.n	107c <xQueueGenericReset+0x44>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1070:	0020      	movs	r0, r4
    1072:	3010      	adds	r0, #16
    1074:	4b0b      	ldr	r3, [pc, #44]	; (10a4 <xQueueGenericReset+0x6c>)
    1076:	4798      	blx	r3
    1078:	2801      	cmp	r0, #1
    107a:	d005      	beq.n	1088 <xQueueGenericReset+0x50>
	taskEXIT_CRITICAL();
    107c:	4b0a      	ldr	r3, [pc, #40]	; (10a8 <xQueueGenericReset+0x70>)
    107e:	4798      	blx	r3
}
    1080:	2001      	movs	r0, #1
    1082:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT( pxQueue );
    1084:	b672      	cpsid	i
    1086:	e7fe      	b.n	1086 <xQueueGenericReset+0x4e>
					queueYIELD_IF_USING_PREEMPTION();
    1088:	4b08      	ldr	r3, [pc, #32]	; (10ac <xQueueGenericReset+0x74>)
    108a:	4798      	blx	r3
    108c:	e7f6      	b.n	107c <xQueueGenericReset+0x44>
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    108e:	0020      	movs	r0, r4
    1090:	3010      	adds	r0, #16
    1092:	4d07      	ldr	r5, [pc, #28]	; (10b0 <xQueueGenericReset+0x78>)
    1094:	47a8      	blx	r5
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1096:	0020      	movs	r0, r4
    1098:	3024      	adds	r0, #36	; 0x24
    109a:	47a8      	blx	r5
    109c:	e7ee      	b.n	107c <xQueueGenericReset+0x44>
    109e:	46c0      	nop			; (mov r8, r8)
    10a0:	00000c79 	.word	0x00000c79
    10a4:	00001bf9 	.word	0x00001bf9
    10a8:	00000c91 	.word	0x00000c91
    10ac:	00000c61 	.word	0x00000c61
    10b0:	00000e0b 	.word	0x00000e0b

000010b4 <xQueueGenericCreate>:
{
    10b4:	b570      	push	{r4, r5, r6, lr}
    10b6:	0005      	movs	r5, r0
    10b8:	000e      	movs	r6, r1
	if( uxQueueLength > ( UBaseType_t ) 0 )
    10ba:	2800      	cmp	r0, #0
    10bc:	d019      	beq.n	10f2 <xQueueGenericCreate+0x3e>
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    10be:	2050      	movs	r0, #80	; 0x50
    10c0:	4b0d      	ldr	r3, [pc, #52]	; (10f8 <xQueueGenericCreate+0x44>)
    10c2:	4798      	blx	r3
    10c4:	1e04      	subs	r4, r0, #0
		if( pxNewQueue != NULL )
    10c6:	d014      	beq.n	10f2 <xQueueGenericCreate+0x3e>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    10c8:	0030      	movs	r0, r6
    10ca:	4368      	muls	r0, r5
    10cc:	3001      	adds	r0, #1
			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    10ce:	4b0a      	ldr	r3, [pc, #40]	; (10f8 <xQueueGenericCreate+0x44>)
    10d0:	4798      	blx	r3
    10d2:	6020      	str	r0, [r4, #0]
			if( pxNewQueue->pcHead != NULL )
    10d4:	2800      	cmp	r0, #0
    10d6:	d009      	beq.n	10ec <xQueueGenericCreate+0x38>
				pxNewQueue->uxLength = uxQueueLength;
    10d8:	63e5      	str	r5, [r4, #60]	; 0x3c
				pxNewQueue->uxItemSize = uxItemSize;
    10da:	6426      	str	r6, [r4, #64]	; 0x40
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    10dc:	2101      	movs	r1, #1
    10de:	0020      	movs	r0, r4
    10e0:	4b06      	ldr	r3, [pc, #24]	; (10fc <xQueueGenericCreate+0x48>)
    10e2:	4798      	blx	r3
					pxNewQueue->pxQueueSetContainer = NULL;
    10e4:	2300      	movs	r3, #0
    10e6:	64e3      	str	r3, [r4, #76]	; 0x4c
}
    10e8:	0020      	movs	r0, r4
    10ea:	bd70      	pop	{r4, r5, r6, pc}
				vPortFree( pxNewQueue );
    10ec:	0020      	movs	r0, r4
    10ee:	4b04      	ldr	r3, [pc, #16]	; (1100 <xQueueGenericCreate+0x4c>)
    10f0:	4798      	blx	r3
	configASSERT( xReturn );
    10f2:	b672      	cpsid	i
    10f4:	e7fe      	b.n	10f4 <xQueueGenericCreate+0x40>
    10f6:	46c0      	nop			; (mov r8, r8)
    10f8:	00000d99 	.word	0x00000d99
    10fc:	00001039 	.word	0x00001039
    1100:	00000e01 	.word	0x00000e01

00001104 <xQueueGenericSend>:
{
    1104:	b5f0      	push	{r4, r5, r6, r7, lr}
    1106:	46ce      	mov	lr, r9
    1108:	4647      	mov	r7, r8
    110a:	b580      	push	{r7, lr}
    110c:	b085      	sub	sp, #20
    110e:	0004      	movs	r4, r0
    1110:	000f      	movs	r7, r1
    1112:	9201      	str	r2, [sp, #4]
    1114:	001d      	movs	r5, r3
	configASSERT( pxQueue );
    1116:	2800      	cmp	r0, #0
    1118:	d00c      	beq.n	1134 <xQueueGenericSend+0x30>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    111a:	2900      	cmp	r1, #0
    111c:	d00c      	beq.n	1138 <xQueueGenericSend+0x34>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    111e:	2d02      	cmp	r5, #2
    1120:	d00f      	beq.n	1142 <xQueueGenericSend+0x3e>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    1122:	4b48      	ldr	r3, [pc, #288]	; (1244 <xQueueGenericSend+0x140>)
    1124:	4798      	blx	r3
    1126:	2800      	cmp	r0, #0
    1128:	d110      	bne.n	114c <xQueueGenericSend+0x48>
    112a:	9b01      	ldr	r3, [sp, #4]
    112c:	2b00      	cmp	r3, #0
    112e:	d011      	beq.n	1154 <xQueueGenericSend+0x50>
    1130:	b672      	cpsid	i
    1132:	e7fe      	b.n	1132 <xQueueGenericSend+0x2e>
	configASSERT( pxQueue );
    1134:	b672      	cpsid	i
    1136:	e7fe      	b.n	1136 <xQueueGenericSend+0x32>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    1138:	6c03      	ldr	r3, [r0, #64]	; 0x40
    113a:	2b00      	cmp	r3, #0
    113c:	d0ef      	beq.n	111e <xQueueGenericSend+0x1a>
    113e:	b672      	cpsid	i
    1140:	e7fe      	b.n	1140 <xQueueGenericSend+0x3c>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    1142:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    1144:	2b01      	cmp	r3, #1
    1146:	d0ec      	beq.n	1122 <xQueueGenericSend+0x1e>
    1148:	b672      	cpsid	i
    114a:	e7fe      	b.n	114a <xQueueGenericSend+0x46>
    114c:	2600      	movs	r6, #0
		taskENTER_CRITICAL();
    114e:	4b3e      	ldr	r3, [pc, #248]	; (1248 <xQueueGenericSend+0x144>)
    1150:	4698      	mov	r8, r3
    1152:	e047      	b.n	11e4 <xQueueGenericSend+0xe0>
    1154:	2600      	movs	r6, #0
    1156:	e7fa      	b.n	114e <xQueueGenericSend+0x4a>
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1158:	002a      	movs	r2, r5
    115a:	0039      	movs	r1, r7
    115c:	0020      	movs	r0, r4
    115e:	4b3b      	ldr	r3, [pc, #236]	; (124c <xQueueGenericSend+0x148>)
    1160:	4798      	blx	r3
					if( pxQueue->pxQueueSetContainer != NULL )
    1162:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    1164:	2b00      	cmp	r3, #0
    1166:	d00f      	beq.n	1188 <xQueueGenericSend+0x84>
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
    1168:	0029      	movs	r1, r5
    116a:	0020      	movs	r0, r4
    116c:	4b38      	ldr	r3, [pc, #224]	; (1250 <xQueueGenericSend+0x14c>)
    116e:	4798      	blx	r3
    1170:	2801      	cmp	r0, #1
    1172:	d101      	bne.n	1178 <xQueueGenericSend+0x74>
							queueYIELD_IF_USING_PREEMPTION();
    1174:	4b37      	ldr	r3, [pc, #220]	; (1254 <xQueueGenericSend+0x150>)
    1176:	4798      	blx	r3
				taskEXIT_CRITICAL();
    1178:	4b37      	ldr	r3, [pc, #220]	; (1258 <xQueueGenericSend+0x154>)
    117a:	4798      	blx	r3
				return pdPASS;
    117c:	2001      	movs	r0, #1
}
    117e:	b005      	add	sp, #20
    1180:	bc0c      	pop	{r2, r3}
    1182:	4690      	mov	r8, r2
    1184:	4699      	mov	r9, r3
    1186:	bdf0      	pop	{r4, r5, r6, r7, pc}
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1188:	6a63      	ldr	r3, [r4, #36]	; 0x24
    118a:	2b00      	cmp	r3, #0
    118c:	d0f4      	beq.n	1178 <xQueueGenericSend+0x74>
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    118e:	0020      	movs	r0, r4
    1190:	3024      	adds	r0, #36	; 0x24
    1192:	4b32      	ldr	r3, [pc, #200]	; (125c <xQueueGenericSend+0x158>)
    1194:	4798      	blx	r3
    1196:	2801      	cmp	r0, #1
    1198:	d1ee      	bne.n	1178 <xQueueGenericSend+0x74>
								queueYIELD_IF_USING_PREEMPTION();
    119a:	4b2e      	ldr	r3, [pc, #184]	; (1254 <xQueueGenericSend+0x150>)
    119c:	4798      	blx	r3
    119e:	e7eb      	b.n	1178 <xQueueGenericSend+0x74>
					taskEXIT_CRITICAL();
    11a0:	4b2d      	ldr	r3, [pc, #180]	; (1258 <xQueueGenericSend+0x154>)
    11a2:	4798      	blx	r3
					return errQUEUE_FULL;
    11a4:	2000      	movs	r0, #0
    11a6:	e7ea      	b.n	117e <xQueueGenericSend+0x7a>
		prvLockQueue( pxQueue );
    11a8:	4b2b      	ldr	r3, [pc, #172]	; (1258 <xQueueGenericSend+0x154>)
    11aa:	4798      	blx	r3
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    11ac:	a901      	add	r1, sp, #4
    11ae:	a802      	add	r0, sp, #8
    11b0:	4b2b      	ldr	r3, [pc, #172]	; (1260 <xQueueGenericSend+0x15c>)
    11b2:	4798      	blx	r3
    11b4:	2800      	cmp	r0, #0
    11b6:	d13e      	bne.n	1236 <xQueueGenericSend+0x132>
	taskENTER_CRITICAL();
    11b8:	4b23      	ldr	r3, [pc, #140]	; (1248 <xQueueGenericSend+0x144>)
    11ba:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    11bc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    11be:	4699      	mov	r9, r3
    11c0:	6be6      	ldr	r6, [r4, #60]	; 0x3c
	taskEXIT_CRITICAL();
    11c2:	4b25      	ldr	r3, [pc, #148]	; (1258 <xQueueGenericSend+0x154>)
    11c4:	4798      	blx	r3
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    11c6:	45b1      	cmp	r9, r6
    11c8:	d12f      	bne.n	122a <xQueueGenericSend+0x126>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    11ca:	0020      	movs	r0, r4
    11cc:	3010      	adds	r0, #16
    11ce:	9901      	ldr	r1, [sp, #4]
    11d0:	4b24      	ldr	r3, [pc, #144]	; (1264 <xQueueGenericSend+0x160>)
    11d2:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
    11d4:	0020      	movs	r0, r4
    11d6:	4b24      	ldr	r3, [pc, #144]	; (1268 <xQueueGenericSend+0x164>)
    11d8:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
    11da:	4b24      	ldr	r3, [pc, #144]	; (126c <xQueueGenericSend+0x168>)
    11dc:	4798      	blx	r3
    11de:	2800      	cmp	r0, #0
    11e0:	d020      	beq.n	1224 <xQueueGenericSend+0x120>
    11e2:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
    11e4:	47c0      	blx	r8
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    11e6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    11e8:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    11ea:	4293      	cmp	r3, r2
    11ec:	d3b4      	bcc.n	1158 <xQueueGenericSend+0x54>
    11ee:	2d02      	cmp	r5, #2
    11f0:	d0b2      	beq.n	1158 <xQueueGenericSend+0x54>
				if( xTicksToWait == ( TickType_t ) 0 )
    11f2:	9b01      	ldr	r3, [sp, #4]
    11f4:	2b00      	cmp	r3, #0
    11f6:	d0d3      	beq.n	11a0 <xQueueGenericSend+0x9c>
				else if( xEntryTimeSet == pdFALSE )
    11f8:	2e00      	cmp	r6, #0
    11fa:	d102      	bne.n	1202 <xQueueGenericSend+0xfe>
					vTaskSetTimeOutState( &xTimeOut );
    11fc:	a802      	add	r0, sp, #8
    11fe:	4b1c      	ldr	r3, [pc, #112]	; (1270 <xQueueGenericSend+0x16c>)
    1200:	4798      	blx	r3
		taskEXIT_CRITICAL();
    1202:	4b15      	ldr	r3, [pc, #84]	; (1258 <xQueueGenericSend+0x154>)
    1204:	4798      	blx	r3
		vTaskSuspendAll();
    1206:	4b1b      	ldr	r3, [pc, #108]	; (1274 <xQueueGenericSend+0x170>)
    1208:	4798      	blx	r3
		prvLockQueue( pxQueue );
    120a:	4b0f      	ldr	r3, [pc, #60]	; (1248 <xQueueGenericSend+0x144>)
    120c:	4798      	blx	r3
    120e:	6c63      	ldr	r3, [r4, #68]	; 0x44
    1210:	3301      	adds	r3, #1
    1212:	d101      	bne.n	1218 <xQueueGenericSend+0x114>
    1214:	2300      	movs	r3, #0
    1216:	6463      	str	r3, [r4, #68]	; 0x44
    1218:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    121a:	3301      	adds	r3, #1
    121c:	d1c4      	bne.n	11a8 <xQueueGenericSend+0xa4>
    121e:	2300      	movs	r3, #0
    1220:	64a3      	str	r3, [r4, #72]	; 0x48
    1222:	e7c1      	b.n	11a8 <xQueueGenericSend+0xa4>
					portYIELD_WITHIN_API();
    1224:	4b0b      	ldr	r3, [pc, #44]	; (1254 <xQueueGenericSend+0x150>)
    1226:	4798      	blx	r3
    1228:	e7db      	b.n	11e2 <xQueueGenericSend+0xde>
				prvUnlockQueue( pxQueue );
    122a:	0020      	movs	r0, r4
    122c:	4b0e      	ldr	r3, [pc, #56]	; (1268 <xQueueGenericSend+0x164>)
    122e:	4798      	blx	r3
				( void ) xTaskResumeAll();
    1230:	4b0e      	ldr	r3, [pc, #56]	; (126c <xQueueGenericSend+0x168>)
    1232:	4798      	blx	r3
    1234:	e7d5      	b.n	11e2 <xQueueGenericSend+0xde>
			prvUnlockQueue( pxQueue );
    1236:	0020      	movs	r0, r4
    1238:	4b0b      	ldr	r3, [pc, #44]	; (1268 <xQueueGenericSend+0x164>)
    123a:	4798      	blx	r3
			( void ) xTaskResumeAll();
    123c:	4b0b      	ldr	r3, [pc, #44]	; (126c <xQueueGenericSend+0x168>)
    123e:	4798      	blx	r3
			return errQUEUE_FULL;
    1240:	2000      	movs	r0, #0
    1242:	e79c      	b.n	117e <xQueueGenericSend+0x7a>
    1244:	00001d1d 	.word	0x00001d1d
    1248:	00000c79 	.word	0x00000c79
    124c:	00000e95 	.word	0x00000e95
    1250:	00000f11 	.word	0x00000f11
    1254:	00000c61 	.word	0x00000c61
    1258:	00000c91 	.word	0x00000c91
    125c:	00001bf9 	.word	0x00001bf9
    1260:	00001c95 	.word	0x00001c95
    1264:	00001b71 	.word	0x00001b71
    1268:	00000f89 	.word	0x00000f89
    126c:	00001901 	.word	0x00001901
    1270:	00001c75 	.word	0x00001c75
    1274:	000017c1 	.word	0x000017c1

00001278 <xQueueGenericSendFromISR>:
{
    1278:	b5f0      	push	{r4, r5, r6, r7, lr}
    127a:	b083      	sub	sp, #12
    127c:	0004      	movs	r4, r0
    127e:	000f      	movs	r7, r1
    1280:	0016      	movs	r6, r2
    1282:	001d      	movs	r5, r3
	configASSERT( pxQueue );
    1284:	2800      	cmp	r0, #0
    1286:	d011      	beq.n	12ac <xQueueGenericSendFromISR+0x34>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    1288:	2900      	cmp	r1, #0
    128a:	d011      	beq.n	12b0 <xQueueGenericSendFromISR+0x38>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    128c:	2d02      	cmp	r5, #2
    128e:	d014      	beq.n	12ba <xQueueGenericSendFromISR+0x42>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1290:	4b26      	ldr	r3, [pc, #152]	; (132c <xQueueGenericSendFromISR+0xb4>)
    1292:	4798      	blx	r3
    1294:	9001      	str	r0, [sp, #4]
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1296:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    1298:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    129a:	429a      	cmp	r2, r3
    129c:	d82e      	bhi.n	12fc <xQueueGenericSendFromISR+0x84>
			xReturn = errQUEUE_FULL;
    129e:	2500      	movs	r5, #0
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    12a0:	9801      	ldr	r0, [sp, #4]
    12a2:	4b23      	ldr	r3, [pc, #140]	; (1330 <xQueueGenericSendFromISR+0xb8>)
    12a4:	4798      	blx	r3
}
    12a6:	0028      	movs	r0, r5
    12a8:	b003      	add	sp, #12
    12aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
	configASSERT( pxQueue );
    12ac:	b672      	cpsid	i
    12ae:	e7fe      	b.n	12ae <xQueueGenericSendFromISR+0x36>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    12b0:	6c03      	ldr	r3, [r0, #64]	; 0x40
    12b2:	2b00      	cmp	r3, #0
    12b4:	d0ea      	beq.n	128c <xQueueGenericSendFromISR+0x14>
    12b6:	b672      	cpsid	i
    12b8:	e7fe      	b.n	12b8 <xQueueGenericSendFromISR+0x40>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    12ba:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    12bc:	2b01      	cmp	r3, #1
    12be:	d019      	beq.n	12f4 <xQueueGenericSendFromISR+0x7c>
    12c0:	b672      	cpsid	i
    12c2:	e7fe      	b.n	12c2 <xQueueGenericSendFromISR+0x4a>
			xReturn = pdPASS;
    12c4:	2501      	movs	r5, #1
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    12c6:	6a63      	ldr	r3, [r4, #36]	; 0x24
    12c8:	2b00      	cmp	r3, #0
    12ca:	d0e9      	beq.n	12a0 <xQueueGenericSendFromISR+0x28>
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    12cc:	0020      	movs	r0, r4
    12ce:	3024      	adds	r0, #36	; 0x24
    12d0:	4b18      	ldr	r3, [pc, #96]	; (1334 <xQueueGenericSendFromISR+0xbc>)
    12d2:	4798      	blx	r3
    12d4:	2800      	cmp	r0, #0
    12d6:	d0e3      	beq.n	12a0 <xQueueGenericSendFromISR+0x28>
								if( pxHigherPriorityTaskWoken != NULL )
    12d8:	2e00      	cmp	r6, #0
    12da:	d009      	beq.n	12f0 <xQueueGenericSendFromISR+0x78>
									*pxHigherPriorityTaskWoken = pdTRUE;
    12dc:	2301      	movs	r3, #1
    12de:	6033      	str	r3, [r6, #0]
    12e0:	e7de      	b.n	12a0 <xQueueGenericSendFromISR+0x28>
				++( pxQueue->xTxLock );
    12e2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    12e4:	3301      	adds	r3, #1
    12e6:	64a3      	str	r3, [r4, #72]	; 0x48
			xReturn = pdPASS;
    12e8:	2501      	movs	r5, #1
    12ea:	e7d9      	b.n	12a0 <xQueueGenericSendFromISR+0x28>
    12ec:	2501      	movs	r5, #1
    12ee:	e7d7      	b.n	12a0 <xQueueGenericSendFromISR+0x28>
    12f0:	2501      	movs	r5, #1
    12f2:	e7d5      	b.n	12a0 <xQueueGenericSendFromISR+0x28>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    12f4:	4b0d      	ldr	r3, [pc, #52]	; (132c <xQueueGenericSendFromISR+0xb4>)
    12f6:	4798      	blx	r3
    12f8:	9001      	str	r0, [sp, #4]
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    12fa:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    12fc:	002a      	movs	r2, r5
    12fe:	0039      	movs	r1, r7
    1300:	0020      	movs	r0, r4
    1302:	4b0d      	ldr	r3, [pc, #52]	; (1338 <xQueueGenericSendFromISR+0xc0>)
    1304:	4798      	blx	r3
			if( pxQueue->xTxLock == queueUNLOCKED )
    1306:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    1308:	3301      	adds	r3, #1
    130a:	d1ea      	bne.n	12e2 <xQueueGenericSendFromISR+0x6a>
					if( pxQueue->pxQueueSetContainer != NULL )
    130c:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    130e:	2b00      	cmp	r3, #0
    1310:	d0d8      	beq.n	12c4 <xQueueGenericSendFromISR+0x4c>
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
    1312:	0029      	movs	r1, r5
    1314:	0020      	movs	r0, r4
    1316:	4b09      	ldr	r3, [pc, #36]	; (133c <xQueueGenericSendFromISR+0xc4>)
    1318:	4798      	blx	r3
			xReturn = pdPASS;
    131a:	2501      	movs	r5, #1
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
    131c:	2801      	cmp	r0, #1
    131e:	d1bf      	bne.n	12a0 <xQueueGenericSendFromISR+0x28>
							if( pxHigherPriorityTaskWoken != NULL )
    1320:	2e00      	cmp	r6, #0
    1322:	d0e3      	beq.n	12ec <xQueueGenericSendFromISR+0x74>
								*pxHigherPriorityTaskWoken = pdTRUE;
    1324:	2301      	movs	r3, #1
    1326:	6033      	str	r3, [r6, #0]
    1328:	e7ba      	b.n	12a0 <xQueueGenericSendFromISR+0x28>
    132a:	46c0      	nop			; (mov r8, r8)
    132c:	00000cb1 	.word	0x00000cb1
    1330:	00000cbb 	.word	0x00000cbb
    1334:	00001bf9 	.word	0x00001bf9
    1338:	00000e95 	.word	0x00000e95
    133c:	00000f11 	.word	0x00000f11

00001340 <xQueueGenericReceive>:
{
    1340:	b5f0      	push	{r4, r5, r6, r7, lr}
    1342:	46c6      	mov	lr, r8
    1344:	b500      	push	{lr}
    1346:	b084      	sub	sp, #16
    1348:	0004      	movs	r4, r0
    134a:	000e      	movs	r6, r1
    134c:	9201      	str	r2, [sp, #4]
    134e:	001f      	movs	r7, r3
	configASSERT( pxQueue );
    1350:	2800      	cmp	r0, #0
    1352:	d00a      	beq.n	136a <xQueueGenericReceive+0x2a>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    1354:	2900      	cmp	r1, #0
    1356:	d00a      	beq.n	136e <xQueueGenericReceive+0x2e>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    1358:	4b4d      	ldr	r3, [pc, #308]	; (1490 <xQueueGenericReceive+0x150>)
    135a:	4798      	blx	r3
    135c:	2800      	cmp	r0, #0
    135e:	d10b      	bne.n	1378 <xQueueGenericReceive+0x38>
    1360:	9b01      	ldr	r3, [sp, #4]
    1362:	2b00      	cmp	r3, #0
    1364:	d00c      	beq.n	1380 <xQueueGenericReceive+0x40>
    1366:	b672      	cpsid	i
    1368:	e7fe      	b.n	1368 <xQueueGenericReceive+0x28>
	configASSERT( pxQueue );
    136a:	b672      	cpsid	i
    136c:	e7fe      	b.n	136c <xQueueGenericReceive+0x2c>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    136e:	6c03      	ldr	r3, [r0, #64]	; 0x40
    1370:	2b00      	cmp	r3, #0
    1372:	d0f1      	beq.n	1358 <xQueueGenericReceive+0x18>
    1374:	b672      	cpsid	i
    1376:	e7fe      	b.n	1376 <xQueueGenericReceive+0x36>
    1378:	2500      	movs	r5, #0
		taskENTER_CRITICAL();
    137a:	4b46      	ldr	r3, [pc, #280]	; (1494 <xQueueGenericReceive+0x154>)
    137c:	4698      	mov	r8, r3
    137e:	e042      	b.n	1406 <xQueueGenericReceive+0xc6>
    1380:	2500      	movs	r5, #0
    1382:	e7fa      	b.n	137a <xQueueGenericReceive+0x3a>
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1384:	68e5      	ldr	r5, [r4, #12]
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1386:	0031      	movs	r1, r6
    1388:	0020      	movs	r0, r4
    138a:	4b43      	ldr	r3, [pc, #268]	; (1498 <xQueueGenericReceive+0x158>)
    138c:	4798      	blx	r3
				if( xJustPeeking == pdFALSE )
    138e:	2f00      	cmp	r7, #0
    1390:	d11a      	bne.n	13c8 <xQueueGenericReceive+0x88>
					--( pxQueue->uxMessagesWaiting );
    1392:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    1394:	3b01      	subs	r3, #1
    1396:	63a3      	str	r3, [r4, #56]	; 0x38
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1398:	6823      	ldr	r3, [r4, #0]
    139a:	2b00      	cmp	r3, #0
    139c:	d102      	bne.n	13a4 <xQueueGenericReceive+0x64>
							pxQueue->pxMutexHolder = ( int8_t * ) xTaskGetCurrentTaskHandle(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    139e:	4b3f      	ldr	r3, [pc, #252]	; (149c <xQueueGenericReceive+0x15c>)
    13a0:	4798      	blx	r3
    13a2:	6060      	str	r0, [r4, #4]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    13a4:	6923      	ldr	r3, [r4, #16]
    13a6:	2b00      	cmp	r3, #0
    13a8:	d007      	beq.n	13ba <xQueueGenericReceive+0x7a>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    13aa:	0020      	movs	r0, r4
    13ac:	3010      	adds	r0, #16
    13ae:	4b3c      	ldr	r3, [pc, #240]	; (14a0 <xQueueGenericReceive+0x160>)
    13b0:	4798      	blx	r3
    13b2:	2801      	cmp	r0, #1
    13b4:	d101      	bne.n	13ba <xQueueGenericReceive+0x7a>
							queueYIELD_IF_USING_PREEMPTION();
    13b6:	4b3b      	ldr	r3, [pc, #236]	; (14a4 <xQueueGenericReceive+0x164>)
    13b8:	4798      	blx	r3
				taskEXIT_CRITICAL();
    13ba:	4b3b      	ldr	r3, [pc, #236]	; (14a8 <xQueueGenericReceive+0x168>)
    13bc:	4798      	blx	r3
				return pdPASS;
    13be:	2001      	movs	r0, #1
}
    13c0:	b004      	add	sp, #16
    13c2:	bc04      	pop	{r2}
    13c4:	4690      	mov	r8, r2
    13c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    13c8:	60e5      	str	r5, [r4, #12]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    13ca:	6a63      	ldr	r3, [r4, #36]	; 0x24
    13cc:	2b00      	cmp	r3, #0
    13ce:	d0f4      	beq.n	13ba <xQueueGenericReceive+0x7a>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    13d0:	0020      	movs	r0, r4
    13d2:	3024      	adds	r0, #36	; 0x24
    13d4:	4b32      	ldr	r3, [pc, #200]	; (14a0 <xQueueGenericReceive+0x160>)
    13d6:	4798      	blx	r3
    13d8:	2800      	cmp	r0, #0
    13da:	d0ee      	beq.n	13ba <xQueueGenericReceive+0x7a>
							queueYIELD_IF_USING_PREEMPTION();
    13dc:	4b31      	ldr	r3, [pc, #196]	; (14a4 <xQueueGenericReceive+0x164>)
    13de:	4798      	blx	r3
    13e0:	e7eb      	b.n	13ba <xQueueGenericReceive+0x7a>
					taskEXIT_CRITICAL();
    13e2:	4b31      	ldr	r3, [pc, #196]	; (14a8 <xQueueGenericReceive+0x168>)
    13e4:	4798      	blx	r3
					return errQUEUE_EMPTY;
    13e6:	2000      	movs	r0, #0
    13e8:	e7ea      	b.n	13c0 <xQueueGenericReceive+0x80>
						taskENTER_CRITICAL();
    13ea:	4b2a      	ldr	r3, [pc, #168]	; (1494 <xQueueGenericReceive+0x154>)
    13ec:	4798      	blx	r3
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    13ee:	6860      	ldr	r0, [r4, #4]
    13f0:	4b2e      	ldr	r3, [pc, #184]	; (14ac <xQueueGenericReceive+0x16c>)
    13f2:	4798      	blx	r3
						taskEXIT_CRITICAL();
    13f4:	4b2c      	ldr	r3, [pc, #176]	; (14a8 <xQueueGenericReceive+0x168>)
    13f6:	4798      	blx	r3
    13f8:	e033      	b.n	1462 <xQueueGenericReceive+0x122>
				prvUnlockQueue( pxQueue );
    13fa:	0020      	movs	r0, r4
    13fc:	4b2c      	ldr	r3, [pc, #176]	; (14b0 <xQueueGenericReceive+0x170>)
    13fe:	4798      	blx	r3
				( void ) xTaskResumeAll();
    1400:	4b2c      	ldr	r3, [pc, #176]	; (14b4 <xQueueGenericReceive+0x174>)
    1402:	4798      	blx	r3
    1404:	2501      	movs	r5, #1
		taskENTER_CRITICAL();
    1406:	47c0      	blx	r8
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1408:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    140a:	2b00      	cmp	r3, #0
    140c:	d1ba      	bne.n	1384 <xQueueGenericReceive+0x44>
				if( xTicksToWait == ( TickType_t ) 0 )
    140e:	9b01      	ldr	r3, [sp, #4]
    1410:	2b00      	cmp	r3, #0
    1412:	d0e6      	beq.n	13e2 <xQueueGenericReceive+0xa2>
				else if( xEntryTimeSet == pdFALSE )
    1414:	2d00      	cmp	r5, #0
    1416:	d102      	bne.n	141e <xQueueGenericReceive+0xde>
					vTaskSetTimeOutState( &xTimeOut );
    1418:	a802      	add	r0, sp, #8
    141a:	4b27      	ldr	r3, [pc, #156]	; (14b8 <xQueueGenericReceive+0x178>)
    141c:	4798      	blx	r3
		taskEXIT_CRITICAL();
    141e:	4b22      	ldr	r3, [pc, #136]	; (14a8 <xQueueGenericReceive+0x168>)
    1420:	4798      	blx	r3
		vTaskSuspendAll();
    1422:	4b26      	ldr	r3, [pc, #152]	; (14bc <xQueueGenericReceive+0x17c>)
    1424:	4798      	blx	r3
		prvLockQueue( pxQueue );
    1426:	4b1b      	ldr	r3, [pc, #108]	; (1494 <xQueueGenericReceive+0x154>)
    1428:	4798      	blx	r3
    142a:	6c63      	ldr	r3, [r4, #68]	; 0x44
    142c:	3301      	adds	r3, #1
    142e:	d101      	bne.n	1434 <xQueueGenericReceive+0xf4>
    1430:	2300      	movs	r3, #0
    1432:	6463      	str	r3, [r4, #68]	; 0x44
    1434:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    1436:	3301      	adds	r3, #1
    1438:	d101      	bne.n	143e <xQueueGenericReceive+0xfe>
    143a:	2300      	movs	r3, #0
    143c:	64a3      	str	r3, [r4, #72]	; 0x48
    143e:	4b1a      	ldr	r3, [pc, #104]	; (14a8 <xQueueGenericReceive+0x168>)
    1440:	4798      	blx	r3
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1442:	a901      	add	r1, sp, #4
    1444:	a802      	add	r0, sp, #8
    1446:	4b1e      	ldr	r3, [pc, #120]	; (14c0 <xQueueGenericReceive+0x180>)
    1448:	4798      	blx	r3
    144a:	2800      	cmp	r0, #0
    144c:	d118      	bne.n	1480 <xQueueGenericReceive+0x140>
	taskENTER_CRITICAL();
    144e:	4b11      	ldr	r3, [pc, #68]	; (1494 <xQueueGenericReceive+0x154>)
    1450:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1452:	6ba5      	ldr	r5, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
    1454:	4b14      	ldr	r3, [pc, #80]	; (14a8 <xQueueGenericReceive+0x168>)
    1456:	4798      	blx	r3
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1458:	2d00      	cmp	r5, #0
    145a:	d1ce      	bne.n	13fa <xQueueGenericReceive+0xba>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    145c:	6823      	ldr	r3, [r4, #0]
    145e:	2b00      	cmp	r3, #0
    1460:	d0c3      	beq.n	13ea <xQueueGenericReceive+0xaa>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1462:	0020      	movs	r0, r4
    1464:	3024      	adds	r0, #36	; 0x24
    1466:	9901      	ldr	r1, [sp, #4]
    1468:	4b16      	ldr	r3, [pc, #88]	; (14c4 <xQueueGenericReceive+0x184>)
    146a:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
    146c:	0020      	movs	r0, r4
    146e:	4b10      	ldr	r3, [pc, #64]	; (14b0 <xQueueGenericReceive+0x170>)
    1470:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
    1472:	4b10      	ldr	r3, [pc, #64]	; (14b4 <xQueueGenericReceive+0x174>)
    1474:	4798      	blx	r3
    1476:	2800      	cmp	r0, #0
    1478:	d1c4      	bne.n	1404 <xQueueGenericReceive+0xc4>
					portYIELD_WITHIN_API();
    147a:	4b0a      	ldr	r3, [pc, #40]	; (14a4 <xQueueGenericReceive+0x164>)
    147c:	4798      	blx	r3
    147e:	e7c1      	b.n	1404 <xQueueGenericReceive+0xc4>
			prvUnlockQueue( pxQueue );
    1480:	0020      	movs	r0, r4
    1482:	4b0b      	ldr	r3, [pc, #44]	; (14b0 <xQueueGenericReceive+0x170>)
    1484:	4798      	blx	r3
			( void ) xTaskResumeAll();
    1486:	4b0b      	ldr	r3, [pc, #44]	; (14b4 <xQueueGenericReceive+0x174>)
    1488:	4798      	blx	r3
			return errQUEUE_EMPTY;
    148a:	2000      	movs	r0, #0
    148c:	e798      	b.n	13c0 <xQueueGenericReceive+0x80>
    148e:	46c0      	nop			; (mov r8, r8)
    1490:	00001d1d 	.word	0x00001d1d
    1494:	00000c79 	.word	0x00000c79
    1498:	00000f61 	.word	0x00000f61
    149c:	00001d11 	.word	0x00001d11
    14a0:	00001bf9 	.word	0x00001bf9
    14a4:	00000c61 	.word	0x00000c61
    14a8:	00000c91 	.word	0x00000c91
    14ac:	00001d39 	.word	0x00001d39
    14b0:	00000f89 	.word	0x00000f89
    14b4:	00001901 	.word	0x00001901
    14b8:	00001c75 	.word	0x00001c75
    14bc:	000017c1 	.word	0x000017c1
    14c0:	00001c95 	.word	0x00001c95
    14c4:	00001b71 	.word	0x00001b71

000014c8 <vQueueWaitForMessageRestricted>:
	{
    14c8:	b570      	push	{r4, r5, r6, lr}
    14ca:	0004      	movs	r4, r0
    14cc:	000d      	movs	r5, r1
		prvLockQueue( pxQueue );
    14ce:	4b0e      	ldr	r3, [pc, #56]	; (1508 <vQueueWaitForMessageRestricted+0x40>)
    14d0:	4798      	blx	r3
    14d2:	6c63      	ldr	r3, [r4, #68]	; 0x44
    14d4:	3301      	adds	r3, #1
    14d6:	d00b      	beq.n	14f0 <vQueueWaitForMessageRestricted+0x28>
    14d8:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    14da:	3301      	adds	r3, #1
    14dc:	d00b      	beq.n	14f6 <vQueueWaitForMessageRestricted+0x2e>
    14de:	4b0b      	ldr	r3, [pc, #44]	; (150c <vQueueWaitForMessageRestricted+0x44>)
    14e0:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    14e2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    14e4:	2b00      	cmp	r3, #0
    14e6:	d009      	beq.n	14fc <vQueueWaitForMessageRestricted+0x34>
		prvUnlockQueue( pxQueue );
    14e8:	0020      	movs	r0, r4
    14ea:	4b09      	ldr	r3, [pc, #36]	; (1510 <vQueueWaitForMessageRestricted+0x48>)
    14ec:	4798      	blx	r3
	}
    14ee:	bd70      	pop	{r4, r5, r6, pc}
		prvLockQueue( pxQueue );
    14f0:	2300      	movs	r3, #0
    14f2:	6463      	str	r3, [r4, #68]	; 0x44
    14f4:	e7f0      	b.n	14d8 <vQueueWaitForMessageRestricted+0x10>
    14f6:	2300      	movs	r3, #0
    14f8:	64a3      	str	r3, [r4, #72]	; 0x48
    14fa:	e7f0      	b.n	14de <vQueueWaitForMessageRestricted+0x16>
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    14fc:	0020      	movs	r0, r4
    14fe:	3024      	adds	r0, #36	; 0x24
    1500:	0029      	movs	r1, r5
    1502:	4b04      	ldr	r3, [pc, #16]	; (1514 <vQueueWaitForMessageRestricted+0x4c>)
    1504:	4798      	blx	r3
    1506:	e7ef      	b.n	14e8 <vQueueWaitForMessageRestricted+0x20>
    1508:	00000c79 	.word	0x00000c79
    150c:	00000c91 	.word	0x00000c91
    1510:	00000f89 	.word	0x00000f89
    1514:	00001bc1 	.word	0x00001bc1

00001518 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1518:	4b08      	ldr	r3, [pc, #32]	; (153c <prvResetNextTaskUnblockTime+0x24>)
    151a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    151c:	681b      	ldr	r3, [r3, #0]
    151e:	2b00      	cmp	r3, #0
    1520:	d007      	beq.n	1532 <prvResetNextTaskUnblockTime+0x1a>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1522:	4b06      	ldr	r3, [pc, #24]	; (153c <prvResetNextTaskUnblockTime+0x24>)
    1524:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1526:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    1528:	68db      	ldr	r3, [r3, #12]
    152a:	685a      	ldr	r2, [r3, #4]
    152c:	4b04      	ldr	r3, [pc, #16]	; (1540 <prvResetNextTaskUnblockTime+0x28>)
    152e:	601a      	str	r2, [r3, #0]
	}
}
    1530:	4770      	bx	lr
		xNextTaskUnblockTime = portMAX_DELAY;
    1532:	2201      	movs	r2, #1
    1534:	4252      	negs	r2, r2
    1536:	4b02      	ldr	r3, [pc, #8]	; (1540 <prvResetNextTaskUnblockTime+0x28>)
    1538:	601a      	str	r2, [r3, #0]
    153a:	e7f9      	b.n	1530 <prvResetNextTaskUnblockTime+0x18>
    153c:	20003f5c 	.word	0x20003f5c
    1540:	20000040 	.word	0x20000040

00001544 <prvAddCurrentTaskToDelayedList>:
{
    1544:	b510      	push	{r4, lr}
    1546:	0004      	movs	r4, r0
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1548:	4b0c      	ldr	r3, [pc, #48]	; (157c <prvAddCurrentTaskToDelayedList+0x38>)
    154a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    154c:	6050      	str	r0, [r2, #4]
	if( xTimeToWake < xTickCount )
    154e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    1550:	4298      	cmp	r0, r3
    1552:	d30c      	bcc.n	156e <prvAddCurrentTaskToDelayedList+0x2a>
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    1554:	4b09      	ldr	r3, [pc, #36]	; (157c <prvAddCurrentTaskToDelayedList+0x38>)
    1556:	6a98      	ldr	r0, [r3, #40]	; 0x28
    1558:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
    155a:	3104      	adds	r1, #4
    155c:	4b08      	ldr	r3, [pc, #32]	; (1580 <prvAddCurrentTaskToDelayedList+0x3c>)
    155e:	4798      	blx	r3
		if( xTimeToWake < xNextTaskUnblockTime )
    1560:	4b08      	ldr	r3, [pc, #32]	; (1584 <prvAddCurrentTaskToDelayedList+0x40>)
    1562:	681b      	ldr	r3, [r3, #0]
    1564:	429c      	cmp	r4, r3
    1566:	d208      	bcs.n	157a <prvAddCurrentTaskToDelayedList+0x36>
			xNextTaskUnblockTime = xTimeToWake;
    1568:	4b06      	ldr	r3, [pc, #24]	; (1584 <prvAddCurrentTaskToDelayedList+0x40>)
    156a:	601c      	str	r4, [r3, #0]
}
    156c:	e005      	b.n	157a <prvAddCurrentTaskToDelayedList+0x36>
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    156e:	4b03      	ldr	r3, [pc, #12]	; (157c <prvAddCurrentTaskToDelayedList+0x38>)
    1570:	6b58      	ldr	r0, [r3, #52]	; 0x34
    1572:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
    1574:	3104      	adds	r1, #4
    1576:	4b02      	ldr	r3, [pc, #8]	; (1580 <prvAddCurrentTaskToDelayedList+0x3c>)
    1578:	4798      	blx	r3
}
    157a:	bd10      	pop	{r4, pc}
    157c:	20003f5c 	.word	0x20003f5c
    1580:	00000e3f 	.word	0x00000e3f
    1584:	20000040 	.word	0x20000040

00001588 <xTaskGenericCreate>:
{
    1588:	b5f0      	push	{r4, r5, r6, r7, lr}
    158a:	46de      	mov	lr, fp
    158c:	4657      	mov	r7, sl
    158e:	464e      	mov	r6, r9
    1590:	b5c0      	push	{r6, r7, lr}
    1592:	b082      	sub	sp, #8
    1594:	0005      	movs	r5, r0
    1596:	000f      	movs	r7, r1
    1598:	0016      	movs	r6, r2
    159a:	9301      	str	r3, [sp, #4]
    159c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    159e:	4699      	mov	r9, r3
	configASSERT( pxTaskCode );
    15a0:	2800      	cmp	r0, #0
    15a2:	d003      	beq.n	15ac <xTaskGenericCreate+0x24>
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
    15a4:	2b04      	cmp	r3, #4
    15a6:	d903      	bls.n	15b0 <xTaskGenericCreate+0x28>
    15a8:	b672      	cpsid	i
    15aa:	e7fe      	b.n	15aa <xTaskGenericCreate+0x22>
	configASSERT( pxTaskCode );
    15ac:	b672      	cpsid	i
    15ae:	e7fe      	b.n	15ae <xTaskGenericCreate+0x26>
	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    15b0:	2040      	movs	r0, #64	; 0x40
    15b2:	4b5f      	ldr	r3, [pc, #380]	; (1730 <xTaskGenericCreate+0x1a8>)
    15b4:	4798      	blx	r3
    15b6:	1e04      	subs	r4, r0, #0
	if( pxNewTCB != NULL )
    15b8:	d00d      	beq.n	15d6 <xTaskGenericCreate+0x4e>
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    15ba:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    15bc:	2b00      	cmp	r3, #0
    15be:	d000      	beq.n	15c2 <xTaskGenericCreate+0x3a>
    15c0:	e09d      	b.n	16fe <xTaskGenericCreate+0x176>
    15c2:	00b0      	lsls	r0, r6, #2
    15c4:	4b5a      	ldr	r3, [pc, #360]	; (1730 <xTaskGenericCreate+0x1a8>)
    15c6:	4798      	blx	r3
    15c8:	6320      	str	r0, [r4, #48]	; 0x30
		if( pxNewTCB->pxStack == NULL )
    15ca:	2800      	cmp	r0, #0
    15cc:	d000      	beq.n	15d0 <xTaskGenericCreate+0x48>
    15ce:	e098      	b.n	1702 <xTaskGenericCreate+0x17a>
			vPortFree( pxNewTCB );
    15d0:	0020      	movs	r0, r4
    15d2:	4b58      	ldr	r3, [pc, #352]	; (1734 <xTaskGenericCreate+0x1ac>)
    15d4:	4798      	blx	r3
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    15d6:	2001      	movs	r0, #1
    15d8:	4240      	negs	r0, r0
    15da:	e07e      	b.n	16da <xTaskGenericCreate+0x152>
    15dc:	3701      	adds	r7, #1
    15de:	3301      	adds	r3, #1
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    15e0:	428b      	cmp	r3, r1
    15e2:	d004      	beq.n	15ee <xTaskGenericCreate+0x66>
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    15e4:	7838      	ldrb	r0, [r7, #0]
    15e6:	7018      	strb	r0, [r3, #0]
		if( pcName[ x ] == 0x00 )
    15e8:	7838      	ldrb	r0, [r7, #0]
    15ea:	2800      	cmp	r0, #0
    15ec:	d1f6      	bne.n	15dc <xTaskGenericCreate+0x54>
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    15ee:	2200      	movs	r2, #0
    15f0:	233b      	movs	r3, #59	; 0x3b
    15f2:	54e2      	strb	r2, [r4, r3]
	pxTCB->uxPriority = uxPriority;
    15f4:	464b      	mov	r3, r9
    15f6:	62e3      	str	r3, [r4, #44]	; 0x2c
		pxTCB->uxBasePriority = uxPriority;
    15f8:	63e3      	str	r3, [r4, #60]	; 0x3c
	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    15fa:	1d23      	adds	r3, r4, #4
    15fc:	9300      	str	r3, [sp, #0]
    15fe:	0018      	movs	r0, r3
    1600:	4f4d      	ldr	r7, [pc, #308]	; (1738 <xTaskGenericCreate+0x1b0>)
    1602:	47b8      	blx	r7
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    1604:	0020      	movs	r0, r4
    1606:	3018      	adds	r0, #24
    1608:	47b8      	blx	r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    160a:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    160c:	2305      	movs	r3, #5
    160e:	464a      	mov	r2, r9
    1610:	1a9b      	subs	r3, r3, r2
    1612:	61a3      	str	r3, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    1614:	6264      	str	r4, [r4, #36]	; 0x24
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1616:	9a01      	ldr	r2, [sp, #4]
    1618:	0029      	movs	r1, r5
    161a:	0030      	movs	r0, r6
    161c:	4b47      	ldr	r3, [pc, #284]	; (173c <xTaskGenericCreate+0x1b4>)
    161e:	4798      	blx	r3
    1620:	6020      	str	r0, [r4, #0]
		if( ( void * ) pxCreatedTask != NULL )
    1622:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1624:	2b00      	cmp	r3, #0
    1626:	d000      	beq.n	162a <xTaskGenericCreate+0xa2>
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    1628:	601c      	str	r4, [r3, #0]
		taskENTER_CRITICAL();
    162a:	4b45      	ldr	r3, [pc, #276]	; (1740 <xTaskGenericCreate+0x1b8>)
    162c:	4798      	blx	r3
			uxCurrentNumberOfTasks++;
    162e:	4b45      	ldr	r3, [pc, #276]	; (1744 <xTaskGenericCreate+0x1bc>)
    1630:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    1632:	3201      	adds	r2, #1
    1634:	639a      	str	r2, [r3, #56]	; 0x38
			if( pxCurrentTCB == NULL )
    1636:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1638:	2b00      	cmp	r3, #0
    163a:	d154      	bne.n	16e6 <xTaskGenericCreate+0x15e>
				pxCurrentTCB =  pxNewTCB;
    163c:	4b41      	ldr	r3, [pc, #260]	; (1744 <xTaskGenericCreate+0x1bc>)
    163e:	62dc      	str	r4, [r3, #44]	; 0x2c
				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    1640:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    1642:	2b01      	cmp	r3, #1
    1644:	d127      	bne.n	1696 <xTaskGenericCreate+0x10e>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    1646:	4e3f      	ldr	r6, [pc, #252]	; (1744 <xTaskGenericCreate+0x1bc>)
    1648:	0030      	movs	r0, r6
    164a:	303c      	adds	r0, #60	; 0x3c
    164c:	4d3e      	ldr	r5, [pc, #248]	; (1748 <xTaskGenericCreate+0x1c0>)
    164e:	47a8      	blx	r5
    1650:	0030      	movs	r0, r6
    1652:	3050      	adds	r0, #80	; 0x50
    1654:	47a8      	blx	r5
    1656:	0030      	movs	r0, r6
    1658:	3064      	adds	r0, #100	; 0x64
    165a:	47a8      	blx	r5
    165c:	0030      	movs	r0, r6
    165e:	3078      	adds	r0, #120	; 0x78
    1660:	47a8      	blx	r5
    1662:	0030      	movs	r0, r6
    1664:	308c      	adds	r0, #140	; 0x8c
    1666:	47a8      	blx	r5
	vListInitialise( &xDelayedTaskList1 );
    1668:	4f38      	ldr	r7, [pc, #224]	; (174c <xTaskGenericCreate+0x1c4>)
    166a:	2320      	movs	r3, #32
    166c:	469b      	mov	fp, r3
    166e:	44bb      	add	fp, r7
    1670:	4658      	mov	r0, fp
    1672:	47a8      	blx	r5
	vListInitialise( &xDelayedTaskList2 );
    1674:	2334      	movs	r3, #52	; 0x34
    1676:	469a      	mov	sl, r3
    1678:	44ba      	add	sl, r7
    167a:	4650      	mov	r0, sl
    167c:	47a8      	blx	r5
	vListInitialise( &xPendingReadyList );
    167e:	0030      	movs	r0, r6
    1680:	3014      	adds	r0, #20
    1682:	47a8      	blx	r5
		vListInitialise( &xTasksWaitingTermination );
    1684:	0038      	movs	r0, r7
    1686:	3048      	adds	r0, #72	; 0x48
    1688:	47a8      	blx	r5
		vListInitialise( &xSuspendedTaskList );
    168a:	0030      	movs	r0, r6
    168c:	47a8      	blx	r5
	pxDelayedTaskList = &xDelayedTaskList1;
    168e:	465b      	mov	r3, fp
    1690:	62b3      	str	r3, [r6, #40]	; 0x28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1692:	4653      	mov	r3, sl
    1694:	6373      	str	r3, [r6, #52]	; 0x34
			uxTaskNumber++;
    1696:	4a2d      	ldr	r2, [pc, #180]	; (174c <xTaskGenericCreate+0x1c4>)
    1698:	6e13      	ldr	r3, [r2, #96]	; 0x60
    169a:	3301      	adds	r3, #1
    169c:	6613      	str	r3, [r2, #96]	; 0x60
			prvAddTaskToReadyList( pxNewTCB );
    169e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    16a0:	6e52      	ldr	r2, [r2, #100]	; 0x64
    16a2:	4293      	cmp	r3, r2
    16a4:	d901      	bls.n	16aa <xTaskGenericCreate+0x122>
    16a6:	4a29      	ldr	r2, [pc, #164]	; (174c <xTaskGenericCreate+0x1c4>)
    16a8:	6653      	str	r3, [r2, #100]	; 0x64
    16aa:	0098      	lsls	r0, r3, #2
    16ac:	18c3      	adds	r3, r0, r3
    16ae:	009b      	lsls	r3, r3, #2
    16b0:	4824      	ldr	r0, [pc, #144]	; (1744 <xTaskGenericCreate+0x1bc>)
    16b2:	303c      	adds	r0, #60	; 0x3c
    16b4:	18c0      	adds	r0, r0, r3
    16b6:	9900      	ldr	r1, [sp, #0]
    16b8:	4b25      	ldr	r3, [pc, #148]	; (1750 <xTaskGenericCreate+0x1c8>)
    16ba:	4798      	blx	r3
		taskEXIT_CRITICAL();
    16bc:	4b25      	ldr	r3, [pc, #148]	; (1754 <xTaskGenericCreate+0x1cc>)
    16be:	4798      	blx	r3
		if( xSchedulerRunning != pdFALSE )
    16c0:	4b22      	ldr	r3, [pc, #136]	; (174c <xTaskGenericCreate+0x1c4>)
    16c2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    16c4:	2001      	movs	r0, #1
    16c6:	2b00      	cmp	r3, #0
    16c8:	d007      	beq.n	16da <xTaskGenericCreate+0x152>
			if( pxCurrentTCB->uxPriority < uxPriority )
    16ca:	4b1e      	ldr	r3, [pc, #120]	; (1744 <xTaskGenericCreate+0x1bc>)
    16cc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    16ce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    16d0:	4599      	cmp	r9, r3
    16d2:	d902      	bls.n	16da <xTaskGenericCreate+0x152>
				taskYIELD_IF_USING_PREEMPTION();
    16d4:	4b20      	ldr	r3, [pc, #128]	; (1758 <xTaskGenericCreate+0x1d0>)
    16d6:	4798      	blx	r3
    16d8:	2001      	movs	r0, #1
}
    16da:	b002      	add	sp, #8
    16dc:	bc1c      	pop	{r2, r3, r4}
    16de:	4691      	mov	r9, r2
    16e0:	469a      	mov	sl, r3
    16e2:	46a3      	mov	fp, r4
    16e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
				if( xSchedulerRunning == pdFALSE )
    16e6:	4b19      	ldr	r3, [pc, #100]	; (174c <xTaskGenericCreate+0x1c4>)
    16e8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    16ea:	2b00      	cmp	r3, #0
    16ec:	d1d3      	bne.n	1696 <xTaskGenericCreate+0x10e>
					if( pxCurrentTCB->uxPriority <= uxPriority )
    16ee:	4b15      	ldr	r3, [pc, #84]	; (1744 <xTaskGenericCreate+0x1bc>)
    16f0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    16f2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    16f4:	4599      	cmp	r9, r3
    16f6:	d3ce      	bcc.n	1696 <xTaskGenericCreate+0x10e>
						pxCurrentTCB = pxNewTCB;
    16f8:	4b12      	ldr	r3, [pc, #72]	; (1744 <xTaskGenericCreate+0x1bc>)
    16fa:	62dc      	str	r4, [r3, #44]	; 0x2c
    16fc:	e7cb      	b.n	1696 <xTaskGenericCreate+0x10e>
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    16fe:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    1700:	6303      	str	r3, [r0, #48]	; 0x30
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    1702:	4b16      	ldr	r3, [pc, #88]	; (175c <xTaskGenericCreate+0x1d4>)
    1704:	18f3      	adds	r3, r6, r3
    1706:	009b      	lsls	r3, r3, #2
    1708:	6b22      	ldr	r2, [r4, #48]	; 0x30
    170a:	4694      	mov	ip, r2
    170c:	4463      	add	r3, ip
			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
    170e:	2207      	movs	r2, #7
    1710:	4393      	bics	r3, r2
    1712:	001e      	movs	r6, r3
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    1714:	783a      	ldrb	r2, [r7, #0]
    1716:	2334      	movs	r3, #52	; 0x34
    1718:	54e2      	strb	r2, [r4, r3]
		if( pcName[ x ] == 0x00 )
    171a:	783b      	ldrb	r3, [r7, #0]
    171c:	2b00      	cmp	r3, #0
    171e:	d100      	bne.n	1722 <xTaskGenericCreate+0x19a>
    1720:	e765      	b.n	15ee <xTaskGenericCreate+0x66>
    1722:	3701      	adds	r7, #1
    1724:	0023      	movs	r3, r4
    1726:	3335      	adds	r3, #53	; 0x35
    1728:	0021      	movs	r1, r4
    172a:	313c      	adds	r1, #60	; 0x3c
    172c:	e75a      	b.n	15e4 <xTaskGenericCreate+0x5c>
    172e:	46c0      	nop			; (mov r8, r8)
    1730:	00000d99 	.word	0x00000d99
    1734:	00000e01 	.word	0x00000e01
    1738:	00000e21 	.word	0x00000e21
    173c:	00000c41 	.word	0x00000c41
    1740:	00000c79 	.word	0x00000c79
    1744:	20003f5c 	.word	0x20003f5c
    1748:	00000e0b 	.word	0x00000e0b
    174c:	20003fdc 	.word	0x20003fdc
    1750:	00000e27 	.word	0x00000e27
    1754:	00000c91 	.word	0x00000c91
    1758:	00000c61 	.word	0x00000c61
    175c:	3fffffff 	.word	0x3fffffff

00001760 <vTaskStartScheduler>:
{
    1760:	b510      	push	{r4, lr}
    1762:	b084      	sub	sp, #16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    1764:	2300      	movs	r3, #0
    1766:	9303      	str	r3, [sp, #12]
    1768:	9302      	str	r3, [sp, #8]
    176a:	9301      	str	r3, [sp, #4]
    176c:	9300      	str	r3, [sp, #0]
    176e:	2264      	movs	r2, #100	; 0x64
    1770:	490c      	ldr	r1, [pc, #48]	; (17a4 <vTaskStartScheduler+0x44>)
    1772:	480d      	ldr	r0, [pc, #52]	; (17a8 <vTaskStartScheduler+0x48>)
    1774:	4c0d      	ldr	r4, [pc, #52]	; (17ac <vTaskStartScheduler+0x4c>)
    1776:	47a0      	blx	r4
		if( xReturn == pdPASS )
    1778:	2801      	cmp	r0, #1
    177a:	d003      	beq.n	1784 <vTaskStartScheduler+0x24>
		configASSERT( xReturn );
    177c:	2800      	cmp	r0, #0
    177e:	d10e      	bne.n	179e <vTaskStartScheduler+0x3e>
    1780:	b672      	cpsid	i
    1782:	e7fe      	b.n	1782 <vTaskStartScheduler+0x22>
			xReturn = xTimerCreateTimerTask();
    1784:	4b0a      	ldr	r3, [pc, #40]	; (17b0 <vTaskStartScheduler+0x50>)
    1786:	4798      	blx	r3
	if( xReturn == pdPASS )
    1788:	2801      	cmp	r0, #1
    178a:	d1f7      	bne.n	177c <vTaskStartScheduler+0x1c>
		portDISABLE_INTERRUPTS();
    178c:	b672      	cpsid	i
		xSchedulerRunning = pdTRUE;
    178e:	2201      	movs	r2, #1
    1790:	4b08      	ldr	r3, [pc, #32]	; (17b4 <vTaskStartScheduler+0x54>)
    1792:	65da      	str	r2, [r3, #92]	; 0x5c
		xTickCount = ( TickType_t ) 0U;
    1794:	2200      	movs	r2, #0
    1796:	4b08      	ldr	r3, [pc, #32]	; (17b8 <vTaskStartScheduler+0x58>)
    1798:	631a      	str	r2, [r3, #48]	; 0x30
		if( xPortStartScheduler() != pdFALSE )
    179a:	4b08      	ldr	r3, [pc, #32]	; (17bc <vTaskStartScheduler+0x5c>)
    179c:	4798      	blx	r3
}
    179e:	b004      	add	sp, #16
    17a0:	bd10      	pop	{r4, pc}
    17a2:	46c0      	nop			; (mov r8, r8)
    17a4:	00002638 	.word	0x00002638
    17a8:	00001a45 	.word	0x00001a45
    17ac:	00001589 	.word	0x00001589
    17b0:	00001ead 	.word	0x00001ead
    17b4:	20003fdc 	.word	0x20003fdc
    17b8:	20003f5c 	.word	0x20003f5c
    17bc:	00000d59 	.word	0x00000d59

000017c0 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
    17c0:	4a02      	ldr	r2, [pc, #8]	; (17cc <vTaskSuspendAll+0xc>)
    17c2:	6ed3      	ldr	r3, [r2, #108]	; 0x6c
    17c4:	3301      	adds	r3, #1
    17c6:	66d3      	str	r3, [r2, #108]	; 0x6c
}
    17c8:	4770      	bx	lr
    17ca:	46c0      	nop			; (mov r8, r8)
    17cc:	20003fdc 	.word	0x20003fdc

000017d0 <xTaskGetTickCount>:
{
    17d0:	b510      	push	{r4, lr}
	taskENTER_CRITICAL();
    17d2:	4b04      	ldr	r3, [pc, #16]	; (17e4 <xTaskGetTickCount+0x14>)
    17d4:	4798      	blx	r3
		xTicks = xTickCount;
    17d6:	4b04      	ldr	r3, [pc, #16]	; (17e8 <xTaskGetTickCount+0x18>)
    17d8:	6b1c      	ldr	r4, [r3, #48]	; 0x30
	taskEXIT_CRITICAL();
    17da:	4b04      	ldr	r3, [pc, #16]	; (17ec <xTaskGetTickCount+0x1c>)
    17dc:	4798      	blx	r3
}
    17de:	0020      	movs	r0, r4
    17e0:	bd10      	pop	{r4, pc}
    17e2:	46c0      	nop			; (mov r8, r8)
    17e4:	00000c79 	.word	0x00000c79
    17e8:	20003f5c 	.word	0x20003f5c
    17ec:	00000c91 	.word	0x00000c91

000017f0 <xTaskIncrementTick>:
{
    17f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    17f2:	46d6      	mov	lr, sl
    17f4:	464f      	mov	r7, r9
    17f6:	b580      	push	{r7, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    17f8:	4b3b      	ldr	r3, [pc, #236]	; (18e8 <xTaskIncrementTick+0xf8>)
    17fa:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    17fc:	2b00      	cmp	r3, #0
    17fe:	d163      	bne.n	18c8 <xTaskIncrementTick+0xd8>
		++xTickCount;
    1800:	4b3a      	ldr	r3, [pc, #232]	; (18ec <xTaskIncrementTick+0xfc>)
    1802:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    1804:	3201      	adds	r2, #1
    1806:	631a      	str	r2, [r3, #48]	; 0x30
			const TickType_t xConstTickCount = xTickCount;
    1808:	6b1d      	ldr	r5, [r3, #48]	; 0x30
			if( xConstTickCount == ( TickType_t ) 0U )
    180a:	2d00      	cmp	r5, #0
    180c:	d110      	bne.n	1830 <xTaskIncrementTick+0x40>
				taskSWITCH_DELAYED_LISTS();
    180e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1810:	681b      	ldr	r3, [r3, #0]
    1812:	2b00      	cmp	r3, #0
    1814:	d001      	beq.n	181a <xTaskIncrementTick+0x2a>
    1816:	b672      	cpsid	i
    1818:	e7fe      	b.n	1818 <xTaskIncrementTick+0x28>
    181a:	4b34      	ldr	r3, [pc, #208]	; (18ec <xTaskIncrementTick+0xfc>)
    181c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    181e:	6b59      	ldr	r1, [r3, #52]	; 0x34
    1820:	6299      	str	r1, [r3, #40]	; 0x28
    1822:	635a      	str	r2, [r3, #52]	; 0x34
    1824:	4a30      	ldr	r2, [pc, #192]	; (18e8 <xTaskIncrementTick+0xf8>)
    1826:	6f13      	ldr	r3, [r2, #112]	; 0x70
    1828:	3301      	adds	r3, #1
    182a:	6713      	str	r3, [r2, #112]	; 0x70
    182c:	4b30      	ldr	r3, [pc, #192]	; (18f0 <xTaskIncrementTick+0x100>)
    182e:	4798      	blx	r3
			if( xConstTickCount >= xNextTaskUnblockTime )
    1830:	4b30      	ldr	r3, [pc, #192]	; (18f4 <xTaskIncrementTick+0x104>)
    1832:	681b      	ldr	r3, [r3, #0]
BaseType_t xSwitchRequired = pdFALSE;
    1834:	2400      	movs	r4, #0
			if( xConstTickCount >= xNextTaskUnblockTime )
    1836:	429d      	cmp	r5, r3
    1838:	d337      	bcc.n	18aa <xTaskIncrementTick+0xba>
    183a:	2400      	movs	r4, #0
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    183c:	4b2b      	ldr	r3, [pc, #172]	; (18ec <xTaskIncrementTick+0xfc>)
    183e:	469a      	mov	sl, r3
						prvAddTaskToReadyList( pxTCB );
    1840:	223c      	movs	r2, #60	; 0x3c
    1842:	4694      	mov	ip, r2
    1844:	4463      	add	r3, ip
    1846:	4699      	mov	r9, r3
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1848:	4653      	mov	r3, sl
    184a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    184c:	681b      	ldr	r3, [r3, #0]
    184e:	2b00      	cmp	r3, #0
    1850:	d027      	beq.n	18a2 <xTaskIncrementTick+0xb2>
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1852:	4b26      	ldr	r3, [pc, #152]	; (18ec <xTaskIncrementTick+0xfc>)
    1854:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1856:	68db      	ldr	r3, [r3, #12]
    1858:	68df      	ldr	r7, [r3, #12]
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    185a:	687b      	ldr	r3, [r7, #4]
						if( xConstTickCount < xItemValue )
    185c:	429d      	cmp	r5, r3
    185e:	d330      	bcc.n	18c2 <xTaskIncrementTick+0xd2>
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    1860:	1d3e      	adds	r6, r7, #4
    1862:	0030      	movs	r0, r6
    1864:	4b24      	ldr	r3, [pc, #144]	; (18f8 <xTaskIncrementTick+0x108>)
    1866:	4798      	blx	r3
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1868:	6abb      	ldr	r3, [r7, #40]	; 0x28
    186a:	2b00      	cmp	r3, #0
    186c:	d003      	beq.n	1876 <xTaskIncrementTick+0x86>
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    186e:	0038      	movs	r0, r7
    1870:	3018      	adds	r0, #24
    1872:	4b21      	ldr	r3, [pc, #132]	; (18f8 <xTaskIncrementTick+0x108>)
    1874:	4798      	blx	r3
						prvAddTaskToReadyList( pxTCB );
    1876:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1878:	4a1b      	ldr	r2, [pc, #108]	; (18e8 <xTaskIncrementTick+0xf8>)
    187a:	6e52      	ldr	r2, [r2, #100]	; 0x64
    187c:	4293      	cmp	r3, r2
    187e:	d901      	bls.n	1884 <xTaskIncrementTick+0x94>
    1880:	4a19      	ldr	r2, [pc, #100]	; (18e8 <xTaskIncrementTick+0xf8>)
    1882:	6653      	str	r3, [r2, #100]	; 0x64
    1884:	0098      	lsls	r0, r3, #2
    1886:	18c0      	adds	r0, r0, r3
    1888:	0080      	lsls	r0, r0, #2
    188a:	4448      	add	r0, r9
    188c:	0031      	movs	r1, r6
    188e:	4b1b      	ldr	r3, [pc, #108]	; (18fc <xTaskIncrementTick+0x10c>)
    1890:	4798      	blx	r3
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1892:	4b16      	ldr	r3, [pc, #88]	; (18ec <xTaskIncrementTick+0xfc>)
    1894:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1896:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    1898:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    189a:	429a      	cmp	r2, r3
    189c:	d3d4      	bcc.n	1848 <xTaskIncrementTick+0x58>
								xSwitchRequired = pdTRUE;
    189e:	2401      	movs	r4, #1
    18a0:	e7d2      	b.n	1848 <xTaskIncrementTick+0x58>
						xNextTaskUnblockTime = portMAX_DELAY;
    18a2:	2201      	movs	r2, #1
    18a4:	4252      	negs	r2, r2
    18a6:	4b13      	ldr	r3, [pc, #76]	; (18f4 <xTaskIncrementTick+0x104>)
    18a8:	601a      	str	r2, [r3, #0]
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    18aa:	4a10      	ldr	r2, [pc, #64]	; (18ec <xTaskIncrementTick+0xfc>)
    18ac:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    18ae:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
    18b0:	008b      	lsls	r3, r1, #2
    18b2:	185b      	adds	r3, r3, r1
    18b4:	009b      	lsls	r3, r3, #2
    18b6:	18d3      	adds	r3, r2, r3
    18b8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    18ba:	2b01      	cmp	r3, #1
    18bc:	d909      	bls.n	18d2 <xTaskIncrementTick+0xe2>
				xSwitchRequired = pdTRUE;
    18be:	2401      	movs	r4, #1
    18c0:	e007      	b.n	18d2 <xTaskIncrementTick+0xe2>
							xNextTaskUnblockTime = xItemValue;
    18c2:	4a0c      	ldr	r2, [pc, #48]	; (18f4 <xTaskIncrementTick+0x104>)
    18c4:	6013      	str	r3, [r2, #0]
							break;
    18c6:	e7f0      	b.n	18aa <xTaskIncrementTick+0xba>
		++uxPendedTicks;
    18c8:	4a07      	ldr	r2, [pc, #28]	; (18e8 <xTaskIncrementTick+0xf8>)
    18ca:	6f53      	ldr	r3, [r2, #116]	; 0x74
    18cc:	3301      	adds	r3, #1
    18ce:	6753      	str	r3, [r2, #116]	; 0x74
BaseType_t xSwitchRequired = pdFALSE;
    18d0:	2400      	movs	r4, #0
		if( xYieldPending != pdFALSE )
    18d2:	4b05      	ldr	r3, [pc, #20]	; (18e8 <xTaskIncrementTick+0xf8>)
    18d4:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    18d6:	2b00      	cmp	r3, #0
    18d8:	d000      	beq.n	18dc <xTaskIncrementTick+0xec>
			xSwitchRequired = pdTRUE;
    18da:	2401      	movs	r4, #1
}
    18dc:	0020      	movs	r0, r4
    18de:	bc0c      	pop	{r2, r3}
    18e0:	4691      	mov	r9, r2
    18e2:	469a      	mov	sl, r3
    18e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    18e6:	46c0      	nop			; (mov r8, r8)
    18e8:	20003fdc 	.word	0x20003fdc
    18ec:	20003f5c 	.word	0x20003f5c
    18f0:	00001519 	.word	0x00001519
    18f4:	20000040 	.word	0x20000040
    18f8:	00000e6d 	.word	0x00000e6d
    18fc:	00000e27 	.word	0x00000e27

00001900 <xTaskResumeAll>:
{
    1900:	b5f0      	push	{r4, r5, r6, r7, lr}
    1902:	b083      	sub	sp, #12
	configASSERT( uxSchedulerSuspended );
    1904:	4b32      	ldr	r3, [pc, #200]	; (19d0 <xTaskResumeAll+0xd0>)
    1906:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    1908:	2b00      	cmp	r3, #0
    190a:	d101      	bne.n	1910 <xTaskResumeAll+0x10>
    190c:	b672      	cpsid	i
    190e:	e7fe      	b.n	190e <xTaskResumeAll+0xe>
	taskENTER_CRITICAL();
    1910:	4b30      	ldr	r3, [pc, #192]	; (19d4 <xTaskResumeAll+0xd4>)
    1912:	4798      	blx	r3
		--uxSchedulerSuspended;
    1914:	4b2e      	ldr	r3, [pc, #184]	; (19d0 <xTaskResumeAll+0xd0>)
    1916:	6eda      	ldr	r2, [r3, #108]	; 0x6c
    1918:	3a01      	subs	r2, #1
    191a:	66da      	str	r2, [r3, #108]	; 0x6c
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    191c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
BaseType_t xAlreadyYielded = pdFALSE;
    191e:	2400      	movs	r4, #0
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1920:	2b00      	cmp	r3, #0
    1922:	d103      	bne.n	192c <xTaskResumeAll+0x2c>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    1924:	4b2c      	ldr	r3, [pc, #176]	; (19d8 <xTaskResumeAll+0xd8>)
    1926:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    1928:	2b00      	cmp	r3, #0
    192a:	d12c      	bne.n	1986 <xTaskResumeAll+0x86>
	taskEXIT_CRITICAL();
    192c:	4b2b      	ldr	r3, [pc, #172]	; (19dc <xTaskResumeAll+0xdc>)
    192e:	4798      	blx	r3
}
    1930:	0020      	movs	r0, r4
    1932:	b003      	add	sp, #12
    1934:	bdf0      	pop	{r4, r5, r6, r7, pc}
					prvAddTaskToReadyList( pxTCB );
    1936:	0098      	lsls	r0, r3, #2
    1938:	18c0      	adds	r0, r0, r3
    193a:	0080      	lsls	r0, r0, #2
    193c:	1838      	adds	r0, r7, r0
    193e:	9901      	ldr	r1, [sp, #4]
    1940:	4b27      	ldr	r3, [pc, #156]	; (19e0 <xTaskResumeAll+0xe0>)
    1942:	4798      	blx	r3
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1944:	4b24      	ldr	r3, [pc, #144]	; (19d8 <xTaskResumeAll+0xd8>)
    1946:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1948:	6af2      	ldr	r2, [r6, #44]	; 0x2c
    194a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    194c:	429a      	cmp	r2, r3
    194e:	d215      	bcs.n	197c <xTaskResumeAll+0x7c>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    1950:	6963      	ldr	r3, [r4, #20]
    1952:	2b00      	cmp	r3, #0
    1954:	d01a      	beq.n	198c <xTaskResumeAll+0x8c>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    1956:	4b20      	ldr	r3, [pc, #128]	; (19d8 <xTaskResumeAll+0xd8>)
    1958:	6a1b      	ldr	r3, [r3, #32]
    195a:	68de      	ldr	r6, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    195c:	0030      	movs	r0, r6
    195e:	3018      	adds	r0, #24
    1960:	4d20      	ldr	r5, [pc, #128]	; (19e4 <xTaskResumeAll+0xe4>)
    1962:	47a8      	blx	r5
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    1964:	1d33      	adds	r3, r6, #4
    1966:	9301      	str	r3, [sp, #4]
    1968:	0018      	movs	r0, r3
    196a:	47a8      	blx	r5
					prvAddTaskToReadyList( pxTCB );
    196c:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    196e:	4a18      	ldr	r2, [pc, #96]	; (19d0 <xTaskResumeAll+0xd0>)
    1970:	6e52      	ldr	r2, [r2, #100]	; 0x64
    1972:	4293      	cmp	r3, r2
    1974:	d9df      	bls.n	1936 <xTaskResumeAll+0x36>
    1976:	4a16      	ldr	r2, [pc, #88]	; (19d0 <xTaskResumeAll+0xd0>)
    1978:	6653      	str	r3, [r2, #100]	; 0x64
    197a:	e7dc      	b.n	1936 <xTaskResumeAll+0x36>
						xYieldPending = pdTRUE;
    197c:	2201      	movs	r2, #1
    197e:	4b14      	ldr	r3, [pc, #80]	; (19d0 <xTaskResumeAll+0xd0>)
    1980:	679a      	str	r2, [r3, #120]	; 0x78
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    1982:	4c15      	ldr	r4, [pc, #84]	; (19d8 <xTaskResumeAll+0xd8>)
    1984:	e7e4      	b.n	1950 <xTaskResumeAll+0x50>
					prvAddTaskToReadyList( pxTCB );
    1986:	4f14      	ldr	r7, [pc, #80]	; (19d8 <xTaskResumeAll+0xd8>)
    1988:	373c      	adds	r7, #60	; 0x3c
    198a:	e7fa      	b.n	1982 <xTaskResumeAll+0x82>
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    198c:	4b10      	ldr	r3, [pc, #64]	; (19d0 <xTaskResumeAll+0xd0>)
    198e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    1990:	2b00      	cmp	r3, #0
    1992:	d013      	beq.n	19bc <xTaskResumeAll+0xbc>
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    1994:	4b0e      	ldr	r3, [pc, #56]	; (19d0 <xTaskResumeAll+0xd0>)
    1996:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    1998:	2b00      	cmp	r3, #0
    199a:	d00f      	beq.n	19bc <xTaskResumeAll+0xbc>
						if( xTaskIncrementTick() != pdFALSE )
    199c:	4e12      	ldr	r6, [pc, #72]	; (19e8 <xTaskResumeAll+0xe8>)
							xYieldPending = pdTRUE;
    199e:	4d0c      	ldr	r5, [pc, #48]	; (19d0 <xTaskResumeAll+0xd0>)
						--uxPendedTicks;
    19a0:	002c      	movs	r4, r5
    19a2:	e005      	b.n	19b0 <xTaskResumeAll+0xb0>
    19a4:	6f63      	ldr	r3, [r4, #116]	; 0x74
    19a6:	3b01      	subs	r3, #1
    19a8:	6763      	str	r3, [r4, #116]	; 0x74
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    19aa:	6f63      	ldr	r3, [r4, #116]	; 0x74
    19ac:	2b00      	cmp	r3, #0
    19ae:	d005      	beq.n	19bc <xTaskResumeAll+0xbc>
						if( xTaskIncrementTick() != pdFALSE )
    19b0:	47b0      	blx	r6
    19b2:	2800      	cmp	r0, #0
    19b4:	d0f6      	beq.n	19a4 <xTaskResumeAll+0xa4>
							xYieldPending = pdTRUE;
    19b6:	2301      	movs	r3, #1
    19b8:	67ab      	str	r3, [r5, #120]	; 0x78
    19ba:	e7f3      	b.n	19a4 <xTaskResumeAll+0xa4>
				if( xYieldPending == pdTRUE )
    19bc:	4b04      	ldr	r3, [pc, #16]	; (19d0 <xTaskResumeAll+0xd0>)
    19be:	6f9b      	ldr	r3, [r3, #120]	; 0x78
BaseType_t xAlreadyYielded = pdFALSE;
    19c0:	2400      	movs	r4, #0
				if( xYieldPending == pdTRUE )
    19c2:	2b01      	cmp	r3, #1
    19c4:	d1b2      	bne.n	192c <xTaskResumeAll+0x2c>
					taskYIELD_IF_USING_PREEMPTION();
    19c6:	4b09      	ldr	r3, [pc, #36]	; (19ec <xTaskResumeAll+0xec>)
    19c8:	4798      	blx	r3
						xAlreadyYielded = pdTRUE;
    19ca:	3401      	adds	r4, #1
    19cc:	e7ae      	b.n	192c <xTaskResumeAll+0x2c>
    19ce:	46c0      	nop			; (mov r8, r8)
    19d0:	20003fdc 	.word	0x20003fdc
    19d4:	00000c79 	.word	0x00000c79
    19d8:	20003f5c 	.word	0x20003f5c
    19dc:	00000c91 	.word	0x00000c91
    19e0:	00000e27 	.word	0x00000e27
    19e4:	00000e6d 	.word	0x00000e6d
    19e8:	000017f1 	.word	0x000017f1
    19ec:	00000c61 	.word	0x00000c61

000019f0 <vTaskDelay>:
	{
    19f0:	b510      	push	{r4, lr}
    19f2:	1e04      	subs	r4, r0, #0
		if( xTicksToDelay > ( TickType_t ) 0U )
    19f4:	d015      	beq.n	1a22 <vTaskDelay+0x32>
			configASSERT( uxSchedulerSuspended == 0 );
    19f6:	4b0c      	ldr	r3, [pc, #48]	; (1a28 <vTaskDelay+0x38>)
    19f8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    19fa:	2b00      	cmp	r3, #0
    19fc:	d001      	beq.n	1a02 <vTaskDelay+0x12>
    19fe:	b672      	cpsid	i
    1a00:	e7fe      	b.n	1a00 <vTaskDelay+0x10>
			vTaskSuspendAll();
    1a02:	4b0a      	ldr	r3, [pc, #40]	; (1a2c <vTaskDelay+0x3c>)
    1a04:	4798      	blx	r3
				xTimeToWake = xTickCount + xTicksToDelay;
    1a06:	4b0a      	ldr	r3, [pc, #40]	; (1a30 <vTaskDelay+0x40>)
    1a08:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    1a0a:	18a4      	adds	r4, r4, r2
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1a0c:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
    1a0e:	3004      	adds	r0, #4
    1a10:	4b08      	ldr	r3, [pc, #32]	; (1a34 <vTaskDelay+0x44>)
    1a12:	4798      	blx	r3
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1a14:	0020      	movs	r0, r4
    1a16:	4b08      	ldr	r3, [pc, #32]	; (1a38 <vTaskDelay+0x48>)
    1a18:	4798      	blx	r3
			xAlreadyYielded = xTaskResumeAll();
    1a1a:	4b08      	ldr	r3, [pc, #32]	; (1a3c <vTaskDelay+0x4c>)
    1a1c:	4798      	blx	r3
		if( xAlreadyYielded == pdFALSE )
    1a1e:	2800      	cmp	r0, #0
    1a20:	d101      	bne.n	1a26 <vTaskDelay+0x36>
			portYIELD_WITHIN_API();
    1a22:	4b07      	ldr	r3, [pc, #28]	; (1a40 <vTaskDelay+0x50>)
    1a24:	4798      	blx	r3
	}
    1a26:	bd10      	pop	{r4, pc}
    1a28:	20003fdc 	.word	0x20003fdc
    1a2c:	000017c1 	.word	0x000017c1
    1a30:	20003f5c 	.word	0x20003f5c
    1a34:	00000e6d 	.word	0x00000e6d
    1a38:	00001545 	.word	0x00001545
    1a3c:	00001901 	.word	0x00001901
    1a40:	00000c61 	.word	0x00000c61

00001a44 <prvIdleTask>:
{
    1a44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1a46:	46ce      	mov	lr, r9
    1a48:	4647      	mov	r7, r8
    1a4a:	b580      	push	{r7, lr}
			vTaskSuspendAll();
    1a4c:	4b17      	ldr	r3, [pc, #92]	; (1aac <prvIdleTask+0x68>)
    1a4e:	4698      	mov	r8, r3
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1a50:	4f17      	ldr	r7, [pc, #92]	; (1ab0 <prvIdleTask+0x6c>)
			( void ) xTaskResumeAll();
    1a52:	4e18      	ldr	r6, [pc, #96]	; (1ab4 <prvIdleTask+0x70>)
    1a54:	e028      	b.n	1aa8 <prvIdleTask+0x64>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    1a56:	4b18      	ldr	r3, [pc, #96]	; (1ab8 <prvIdleTask+0x74>)
    1a58:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    1a5a:	2b01      	cmp	r3, #1
    1a5c:	d822      	bhi.n	1aa4 <prvIdleTask+0x60>
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    1a5e:	6eab      	ldr	r3, [r5, #104]	; 0x68
    1a60:	2b00      	cmp	r3, #0
    1a62:	d0f8      	beq.n	1a56 <prvIdleTask+0x12>
			vTaskSuspendAll();
    1a64:	47c0      	blx	r8
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1a66:	6cbc      	ldr	r4, [r7, #72]	; 0x48
			( void ) xTaskResumeAll();
    1a68:	47b0      	blx	r6
			if( xListIsEmpty == pdFALSE )
    1a6a:	2c00      	cmp	r4, #0
    1a6c:	d0f7      	beq.n	1a5e <prvIdleTask+0x1a>
				taskENTER_CRITICAL();
    1a6e:	4b13      	ldr	r3, [pc, #76]	; (1abc <prvIdleTask+0x78>)
    1a70:	4798      	blx	r3
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    1a72:	4b0f      	ldr	r3, [pc, #60]	; (1ab0 <prvIdleTask+0x6c>)
    1a74:	4699      	mov	r9, r3
    1a76:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    1a78:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    1a7a:	1d20      	adds	r0, r4, #4
    1a7c:	4b10      	ldr	r3, [pc, #64]	; (1ac0 <prvIdleTask+0x7c>)
    1a7e:	4798      	blx	r3
					--uxCurrentNumberOfTasks;
    1a80:	4a0d      	ldr	r2, [pc, #52]	; (1ab8 <prvIdleTask+0x74>)
    1a82:	6b93      	ldr	r3, [r2, #56]	; 0x38
    1a84:	3b01      	subs	r3, #1
    1a86:	6393      	str	r3, [r2, #56]	; 0x38
					--uxTasksDeleted;
    1a88:	464b      	mov	r3, r9
    1a8a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    1a8c:	3b01      	subs	r3, #1
    1a8e:	464a      	mov	r2, r9
    1a90:	6693      	str	r3, [r2, #104]	; 0x68
				taskEXIT_CRITICAL();
    1a92:	4b0c      	ldr	r3, [pc, #48]	; (1ac4 <prvIdleTask+0x80>)
    1a94:	4798      	blx	r3
		vPortFreeAligned( pxTCB->pxStack );
    1a96:	6b20      	ldr	r0, [r4, #48]	; 0x30
    1a98:	4b0b      	ldr	r3, [pc, #44]	; (1ac8 <prvIdleTask+0x84>)
    1a9a:	4699      	mov	r9, r3
    1a9c:	4798      	blx	r3
		vPortFree( pxTCB );
    1a9e:	0020      	movs	r0, r4
    1aa0:	47c8      	blx	r9
    1aa2:	e7dc      	b.n	1a5e <prvIdleTask+0x1a>
				taskYIELD();
    1aa4:	4b09      	ldr	r3, [pc, #36]	; (1acc <prvIdleTask+0x88>)
    1aa6:	4798      	blx	r3
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    1aa8:	4d01      	ldr	r5, [pc, #4]	; (1ab0 <prvIdleTask+0x6c>)
    1aaa:	e7d8      	b.n	1a5e <prvIdleTask+0x1a>
    1aac:	000017c1 	.word	0x000017c1
    1ab0:	20003fdc 	.word	0x20003fdc
    1ab4:	00001901 	.word	0x00001901
    1ab8:	20003f5c 	.word	0x20003f5c
    1abc:	00000c79 	.word	0x00000c79
    1ac0:	00000e6d 	.word	0x00000e6d
    1ac4:	00000c91 	.word	0x00000c91
    1ac8:	00000e01 	.word	0x00000e01
    1acc:	00000c61 	.word	0x00000c61

00001ad0 <vTaskSwitchContext>:
{
    1ad0:	b510      	push	{r4, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    1ad2:	4b25      	ldr	r3, [pc, #148]	; (1b68 <vTaskSwitchContext+0x98>)
    1ad4:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    1ad6:	2b00      	cmp	r3, #0
    1ad8:	d122      	bne.n	1b20 <vTaskSwitchContext+0x50>
		xYieldPending = pdFALSE;
    1ada:	4b23      	ldr	r3, [pc, #140]	; (1b68 <vTaskSwitchContext+0x98>)
    1adc:	2200      	movs	r2, #0
    1ade:	679a      	str	r2, [r3, #120]	; 0x78
		taskSELECT_HIGHEST_PRIORITY_TASK();
    1ae0:	6e5a      	ldr	r2, [r3, #100]	; 0x64
    1ae2:	0093      	lsls	r3, r2, #2
    1ae4:	189b      	adds	r3, r3, r2
    1ae6:	009b      	lsls	r3, r3, #2
    1ae8:	4a20      	ldr	r2, [pc, #128]	; (1b6c <vTaskSwitchContext+0x9c>)
    1aea:	18d3      	adds	r3, r2, r3
    1aec:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    1aee:	2b00      	cmp	r3, #0
    1af0:	d11a      	bne.n	1b28 <vTaskSwitchContext+0x58>
    1af2:	4b1d      	ldr	r3, [pc, #116]	; (1b68 <vTaskSwitchContext+0x98>)
    1af4:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    1af6:	2b00      	cmp	r3, #0
    1af8:	d010      	beq.n	1b1c <vTaskSwitchContext+0x4c>
    1afa:	4a1b      	ldr	r2, [pc, #108]	; (1b68 <vTaskSwitchContext+0x98>)
    1afc:	4c1b      	ldr	r4, [pc, #108]	; (1b6c <vTaskSwitchContext+0x9c>)
    1afe:	0010      	movs	r0, r2
    1b00:	6e53      	ldr	r3, [r2, #100]	; 0x64
    1b02:	3b01      	subs	r3, #1
    1b04:	6653      	str	r3, [r2, #100]	; 0x64
    1b06:	6e51      	ldr	r1, [r2, #100]	; 0x64
    1b08:	008b      	lsls	r3, r1, #2
    1b0a:	185b      	adds	r3, r3, r1
    1b0c:	009b      	lsls	r3, r3, #2
    1b0e:	18e3      	adds	r3, r4, r3
    1b10:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    1b12:	2b00      	cmp	r3, #0
    1b14:	d108      	bne.n	1b28 <vTaskSwitchContext+0x58>
    1b16:	6e43      	ldr	r3, [r0, #100]	; 0x64
    1b18:	2b00      	cmp	r3, #0
    1b1a:	d1f1      	bne.n	1b00 <vTaskSwitchContext+0x30>
    1b1c:	b672      	cpsid	i
    1b1e:	e7fe      	b.n	1b1e <vTaskSwitchContext+0x4e>
		xYieldPending = pdTRUE;
    1b20:	2201      	movs	r2, #1
    1b22:	4b11      	ldr	r3, [pc, #68]	; (1b68 <vTaskSwitchContext+0x98>)
    1b24:	679a      	str	r2, [r3, #120]	; 0x78
}
    1b26:	bd10      	pop	{r4, pc}
		taskSELECT_HIGHEST_PRIORITY_TASK();
    1b28:	4b0f      	ldr	r3, [pc, #60]	; (1b68 <vTaskSwitchContext+0x98>)
    1b2a:	6e5a      	ldr	r2, [r3, #100]	; 0x64
    1b2c:	4b0f      	ldr	r3, [pc, #60]	; (1b6c <vTaskSwitchContext+0x9c>)
    1b2e:	0091      	lsls	r1, r2, #2
    1b30:	1888      	adds	r0, r1, r2
    1b32:	0080      	lsls	r0, r0, #2
    1b34:	1818      	adds	r0, r3, r0
    1b36:	6c04      	ldr	r4, [r0, #64]	; 0x40
    1b38:	6864      	ldr	r4, [r4, #4]
    1b3a:	6404      	str	r4, [r0, #64]	; 0x40
    1b3c:	1889      	adds	r1, r1, r2
    1b3e:	0089      	lsls	r1, r1, #2
    1b40:	0003      	movs	r3, r0
    1b42:	3344      	adds	r3, #68	; 0x44
    1b44:	429c      	cmp	r4, r3
    1b46:	d008      	beq.n	1b5a <vTaskSwitchContext+0x8a>
    1b48:	4908      	ldr	r1, [pc, #32]	; (1b6c <vTaskSwitchContext+0x9c>)
    1b4a:	0093      	lsls	r3, r2, #2
    1b4c:	189b      	adds	r3, r3, r2
    1b4e:	009b      	lsls	r3, r3, #2
    1b50:	18cb      	adds	r3, r1, r3
    1b52:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    1b54:	68db      	ldr	r3, [r3, #12]
    1b56:	62cb      	str	r3, [r1, #44]	; 0x2c
}
    1b58:	e7e5      	b.n	1b26 <vTaskSwitchContext+0x56>
		taskSELECT_HIGHEST_PRIORITY_TASK();
    1b5a:	6860      	ldr	r0, [r4, #4]
    1b5c:	000b      	movs	r3, r1
    1b5e:	4903      	ldr	r1, [pc, #12]	; (1b6c <vTaskSwitchContext+0x9c>)
    1b60:	18cb      	adds	r3, r1, r3
    1b62:	6418      	str	r0, [r3, #64]	; 0x40
    1b64:	e7f0      	b.n	1b48 <vTaskSwitchContext+0x78>
    1b66:	46c0      	nop			; (mov r8, r8)
    1b68:	20003fdc 	.word	0x20003fdc
    1b6c:	20003f5c 	.word	0x20003f5c

00001b70 <vTaskPlaceOnEventList>:
{
    1b70:	b570      	push	{r4, r5, r6, lr}
    1b72:	000c      	movs	r4, r1
	configASSERT( pxEventList );
    1b74:	2800      	cmp	r0, #0
    1b76:	d010      	beq.n	1b9a <vTaskPlaceOnEventList+0x2a>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1b78:	4d0c      	ldr	r5, [pc, #48]	; (1bac <vTaskPlaceOnEventList+0x3c>)
    1b7a:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
    1b7c:	3118      	adds	r1, #24
    1b7e:	4b0c      	ldr	r3, [pc, #48]	; (1bb0 <vTaskPlaceOnEventList+0x40>)
    1b80:	4798      	blx	r3
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1b82:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
    1b84:	3004      	adds	r0, #4
    1b86:	4b0b      	ldr	r3, [pc, #44]	; (1bb4 <vTaskPlaceOnEventList+0x44>)
    1b88:	4798      	blx	r3
		if( xTicksToWait == portMAX_DELAY )
    1b8a:	1c63      	adds	r3, r4, #1
    1b8c:	d007      	beq.n	1b9e <vTaskPlaceOnEventList+0x2e>
			xTimeToWake = xTickCount + xTicksToWait;
    1b8e:	4b07      	ldr	r3, [pc, #28]	; (1bac <vTaskPlaceOnEventList+0x3c>)
    1b90:	6b18      	ldr	r0, [r3, #48]	; 0x30
    1b92:	1820      	adds	r0, r4, r0
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1b94:	4b08      	ldr	r3, [pc, #32]	; (1bb8 <vTaskPlaceOnEventList+0x48>)
    1b96:	4798      	blx	r3
}
    1b98:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT( pxEventList );
    1b9a:	b672      	cpsid	i
    1b9c:	e7fe      	b.n	1b9c <vTaskPlaceOnEventList+0x2c>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    1b9e:	4803      	ldr	r0, [pc, #12]	; (1bac <vTaskPlaceOnEventList+0x3c>)
    1ba0:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
    1ba2:	3104      	adds	r1, #4
    1ba4:	4b05      	ldr	r3, [pc, #20]	; (1bbc <vTaskPlaceOnEventList+0x4c>)
    1ba6:	4798      	blx	r3
    1ba8:	e7f6      	b.n	1b98 <vTaskPlaceOnEventList+0x28>
    1baa:	46c0      	nop			; (mov r8, r8)
    1bac:	20003f5c 	.word	0x20003f5c
    1bb0:	00000e3f 	.word	0x00000e3f
    1bb4:	00000e6d 	.word	0x00000e6d
    1bb8:	00001545 	.word	0x00001545
    1bbc:	00000e27 	.word	0x00000e27

00001bc0 <vTaskPlaceOnEventListRestricted>:
	{
    1bc0:	b570      	push	{r4, r5, r6, lr}
    1bc2:	000d      	movs	r5, r1
		configASSERT( pxEventList );
    1bc4:	2800      	cmp	r0, #0
    1bc6:	d101      	bne.n	1bcc <vTaskPlaceOnEventListRestricted+0xc>
    1bc8:	b672      	cpsid	i
    1bca:	e7fe      	b.n	1bca <vTaskPlaceOnEventListRestricted+0xa>
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1bcc:	4c06      	ldr	r4, [pc, #24]	; (1be8 <vTaskPlaceOnEventListRestricted+0x28>)
    1bce:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    1bd0:	3118      	adds	r1, #24
    1bd2:	4b06      	ldr	r3, [pc, #24]	; (1bec <vTaskPlaceOnEventListRestricted+0x2c>)
    1bd4:	4798      	blx	r3
		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1bd6:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    1bd8:	3004      	adds	r0, #4
    1bda:	4b05      	ldr	r3, [pc, #20]	; (1bf0 <vTaskPlaceOnEventListRestricted+0x30>)
    1bdc:	4798      	blx	r3
		xTimeToWake = xTickCount + xTicksToWait;
    1bde:	6b20      	ldr	r0, [r4, #48]	; 0x30
    1be0:	1940      	adds	r0, r0, r5
		prvAddCurrentTaskToDelayedList( xTimeToWake );
    1be2:	4b04      	ldr	r3, [pc, #16]	; (1bf4 <vTaskPlaceOnEventListRestricted+0x34>)
    1be4:	4798      	blx	r3
	}
    1be6:	bd70      	pop	{r4, r5, r6, pc}
    1be8:	20003f5c 	.word	0x20003f5c
    1bec:	00000e27 	.word	0x00000e27
    1bf0:	00000e6d 	.word	0x00000e6d
    1bf4:	00001545 	.word	0x00001545

00001bf8 <xTaskRemoveFromEventList>:
{
    1bf8:	b570      	push	{r4, r5, r6, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1bfa:	68c3      	ldr	r3, [r0, #12]
    1bfc:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
    1bfe:	2c00      	cmp	r4, #0
    1c00:	d028      	beq.n	1c54 <xTaskRemoveFromEventList+0x5c>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1c02:	0025      	movs	r5, r4
    1c04:	3518      	adds	r5, #24
    1c06:	0028      	movs	r0, r5
    1c08:	4b16      	ldr	r3, [pc, #88]	; (1c64 <xTaskRemoveFromEventList+0x6c>)
    1c0a:	4798      	blx	r3
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1c0c:	4b16      	ldr	r3, [pc, #88]	; (1c68 <xTaskRemoveFromEventList+0x70>)
    1c0e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    1c10:	2b00      	cmp	r3, #0
    1c12:	d121      	bne.n	1c58 <xTaskRemoveFromEventList+0x60>
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1c14:	1d25      	adds	r5, r4, #4
    1c16:	0028      	movs	r0, r5
    1c18:	4b12      	ldr	r3, [pc, #72]	; (1c64 <xTaskRemoveFromEventList+0x6c>)
    1c1a:	4798      	blx	r3
		prvAddTaskToReadyList( pxUnblockedTCB );
    1c1c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    1c1e:	4a12      	ldr	r2, [pc, #72]	; (1c68 <xTaskRemoveFromEventList+0x70>)
    1c20:	6e52      	ldr	r2, [r2, #100]	; 0x64
    1c22:	4293      	cmp	r3, r2
    1c24:	d901      	bls.n	1c2a <xTaskRemoveFromEventList+0x32>
    1c26:	4a10      	ldr	r2, [pc, #64]	; (1c68 <xTaskRemoveFromEventList+0x70>)
    1c28:	6653      	str	r3, [r2, #100]	; 0x64
    1c2a:	0098      	lsls	r0, r3, #2
    1c2c:	18c3      	adds	r3, r0, r3
    1c2e:	009b      	lsls	r3, r3, #2
    1c30:	480e      	ldr	r0, [pc, #56]	; (1c6c <xTaskRemoveFromEventList+0x74>)
    1c32:	303c      	adds	r0, #60	; 0x3c
    1c34:	18c0      	adds	r0, r0, r3
    1c36:	0029      	movs	r1, r5
    1c38:	4b0d      	ldr	r3, [pc, #52]	; (1c70 <xTaskRemoveFromEventList+0x78>)
    1c3a:	4798      	blx	r3
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1c3c:	4b0b      	ldr	r3, [pc, #44]	; (1c6c <xTaskRemoveFromEventList+0x74>)
    1c3e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1c40:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    1c42:	6adb      	ldr	r3, [r3, #44]	; 0x2c
		xReturn = pdFALSE;
    1c44:	2000      	movs	r0, #0
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1c46:	429a      	cmp	r2, r3
    1c48:	d903      	bls.n	1c52 <xTaskRemoveFromEventList+0x5a>
		xYieldPending = pdTRUE;
    1c4a:	2201      	movs	r2, #1
    1c4c:	4b06      	ldr	r3, [pc, #24]	; (1c68 <xTaskRemoveFromEventList+0x70>)
    1c4e:	679a      	str	r2, [r3, #120]	; 0x78
		xReturn = pdTRUE;
    1c50:	3001      	adds	r0, #1
}
    1c52:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT( pxUnblockedTCB );
    1c54:	b672      	cpsid	i
    1c56:	e7fe      	b.n	1c56 <xTaskRemoveFromEventList+0x5e>
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1c58:	0029      	movs	r1, r5
    1c5a:	4804      	ldr	r0, [pc, #16]	; (1c6c <xTaskRemoveFromEventList+0x74>)
    1c5c:	3014      	adds	r0, #20
    1c5e:	4b04      	ldr	r3, [pc, #16]	; (1c70 <xTaskRemoveFromEventList+0x78>)
    1c60:	4798      	blx	r3
    1c62:	e7eb      	b.n	1c3c <xTaskRemoveFromEventList+0x44>
    1c64:	00000e6d 	.word	0x00000e6d
    1c68:	20003fdc 	.word	0x20003fdc
    1c6c:	20003f5c 	.word	0x20003f5c
    1c70:	00000e27 	.word	0x00000e27

00001c74 <vTaskSetTimeOutState>:
	configASSERT( pxTimeOut );
    1c74:	2800      	cmp	r0, #0
    1c76:	d006      	beq.n	1c86 <vTaskSetTimeOutState+0x12>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1c78:	4b04      	ldr	r3, [pc, #16]	; (1c8c <vTaskSetTimeOutState+0x18>)
    1c7a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    1c7c:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    1c7e:	4b04      	ldr	r3, [pc, #16]	; (1c90 <vTaskSetTimeOutState+0x1c>)
    1c80:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    1c82:	6043      	str	r3, [r0, #4]
}
    1c84:	4770      	bx	lr
	configASSERT( pxTimeOut );
    1c86:	b672      	cpsid	i
    1c88:	e7fe      	b.n	1c88 <vTaskSetTimeOutState+0x14>
    1c8a:	46c0      	nop			; (mov r8, r8)
    1c8c:	20003fdc 	.word	0x20003fdc
    1c90:	20003f5c 	.word	0x20003f5c

00001c94 <xTaskCheckForTimeOut>:
{
    1c94:	b570      	push	{r4, r5, r6, lr}
    1c96:	0004      	movs	r4, r0
    1c98:	000e      	movs	r6, r1
	configASSERT( pxTimeOut );
    1c9a:	2800      	cmp	r0, #0
    1c9c:	d01a      	beq.n	1cd4 <xTaskCheckForTimeOut+0x40>
	configASSERT( pxTicksToWait );
    1c9e:	2900      	cmp	r1, #0
    1ca0:	d01a      	beq.n	1cd8 <xTaskCheckForTimeOut+0x44>
	taskENTER_CRITICAL();
    1ca2:	4b13      	ldr	r3, [pc, #76]	; (1cf0 <xTaskCheckForTimeOut+0x5c>)
    1ca4:	4798      	blx	r3
		const TickType_t xConstTickCount = xTickCount;
    1ca6:	4b13      	ldr	r3, [pc, #76]	; (1cf4 <xTaskCheckForTimeOut+0x60>)
    1ca8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
			if( *pxTicksToWait == portMAX_DELAY )
    1caa:	6833      	ldr	r3, [r6, #0]
    1cac:	1c59      	adds	r1, r3, #1
    1cae:	d01d      	beq.n	1cec <xTaskCheckForTimeOut+0x58>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1cb0:	4911      	ldr	r1, [pc, #68]	; (1cf8 <xTaskCheckForTimeOut+0x64>)
    1cb2:	6f09      	ldr	r1, [r1, #112]	; 0x70
    1cb4:	6820      	ldr	r0, [r4, #0]
    1cb6:	4288      	cmp	r0, r1
    1cb8:	d003      	beq.n	1cc2 <xTaskCheckForTimeOut+0x2e>
			xReturn = pdTRUE;
    1cba:	2501      	movs	r5, #1
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1cbc:	6861      	ldr	r1, [r4, #4]
    1cbe:	428a      	cmp	r2, r1
    1cc0:	d204      	bcs.n	1ccc <xTaskCheckForTimeOut+0x38>
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    1cc2:	6861      	ldr	r1, [r4, #4]
    1cc4:	1a50      	subs	r0, r2, r1
			xReturn = pdTRUE;
    1cc6:	2501      	movs	r5, #1
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    1cc8:	4283      	cmp	r3, r0
    1cca:	d807      	bhi.n	1cdc <xTaskCheckForTimeOut+0x48>
	taskEXIT_CRITICAL();
    1ccc:	4b0b      	ldr	r3, [pc, #44]	; (1cfc <xTaskCheckForTimeOut+0x68>)
    1cce:	4798      	blx	r3
}
    1cd0:	0028      	movs	r0, r5
    1cd2:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT( pxTimeOut );
    1cd4:	b672      	cpsid	i
    1cd6:	e7fe      	b.n	1cd6 <xTaskCheckForTimeOut+0x42>
	configASSERT( pxTicksToWait );
    1cd8:	b672      	cpsid	i
    1cda:	e7fe      	b.n	1cda <xTaskCheckForTimeOut+0x46>
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    1cdc:	1a9b      	subs	r3, r3, r2
    1cde:	185b      	adds	r3, r3, r1
    1ce0:	6033      	str	r3, [r6, #0]
			vTaskSetTimeOutState( pxTimeOut );
    1ce2:	0020      	movs	r0, r4
    1ce4:	4b06      	ldr	r3, [pc, #24]	; (1d00 <xTaskCheckForTimeOut+0x6c>)
    1ce6:	4798      	blx	r3
			xReturn = pdFALSE;
    1ce8:	2500      	movs	r5, #0
    1cea:	e7ef      	b.n	1ccc <xTaskCheckForTimeOut+0x38>
				xReturn = pdFALSE;
    1cec:	2500      	movs	r5, #0
    1cee:	e7ed      	b.n	1ccc <xTaskCheckForTimeOut+0x38>
    1cf0:	00000c79 	.word	0x00000c79
    1cf4:	20003f5c 	.word	0x20003f5c
    1cf8:	20003fdc 	.word	0x20003fdc
    1cfc:	00000c91 	.word	0x00000c91
    1d00:	00001c75 	.word	0x00001c75

00001d04 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
    1d04:	2201      	movs	r2, #1
    1d06:	4b01      	ldr	r3, [pc, #4]	; (1d0c <vTaskMissedYield+0x8>)
    1d08:	679a      	str	r2, [r3, #120]	; 0x78
}
    1d0a:	4770      	bx	lr
    1d0c:	20003fdc 	.word	0x20003fdc

00001d10 <xTaskGetCurrentTaskHandle>:
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    1d10:	4b01      	ldr	r3, [pc, #4]	; (1d18 <xTaskGetCurrentTaskHandle+0x8>)
    1d12:	6ad8      	ldr	r0, [r3, #44]	; 0x2c

		return xReturn;
	}
    1d14:	4770      	bx	lr
    1d16:	46c0      	nop			; (mov r8, r8)
    1d18:	20003f5c 	.word	0x20003f5c

00001d1c <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    1d1c:	4b05      	ldr	r3, [pc, #20]	; (1d34 <xTaskGetSchedulerState+0x18>)
    1d1e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    1d20:	2001      	movs	r0, #1
		if( xSchedulerRunning == pdFALSE )
    1d22:	2b00      	cmp	r3, #0
    1d24:	d004      	beq.n	1d30 <xTaskGetSchedulerState+0x14>
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1d26:	4b03      	ldr	r3, [pc, #12]	; (1d34 <xTaskGetSchedulerState+0x18>)
    1d28:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    1d2a:	4243      	negs	r3, r0
    1d2c:	4158      	adcs	r0, r3
    1d2e:	0040      	lsls	r0, r0, #1
			}
		}

		return xReturn;
	}
    1d30:	4770      	bx	lr
    1d32:	46c0      	nop			; (mov r8, r8)
    1d34:	20003fdc 	.word	0x20003fdc

00001d38 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    1d38:	b570      	push	{r4, r5, r6, lr}
    1d3a:	1e04      	subs	r4, r0, #0
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    1d3c:	d01b      	beq.n	1d76 <vTaskPriorityInherit+0x3e>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    1d3e:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
    1d40:	4b19      	ldr	r3, [pc, #100]	; (1da8 <vTaskPriorityInherit+0x70>)
    1d42:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1d44:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1d46:	4299      	cmp	r1, r3
    1d48:	d215      	bcs.n	1d76 <vTaskPriorityInherit+0x3e>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    1d4a:	6983      	ldr	r3, [r0, #24]
    1d4c:	2b00      	cmp	r3, #0
    1d4e:	db05      	blt.n	1d5c <vTaskPriorityInherit+0x24>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1d50:	4b15      	ldr	r3, [pc, #84]	; (1da8 <vTaskPriorityInherit+0x70>)
    1d52:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1d54:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1d56:	2305      	movs	r3, #5
    1d58:	1a9b      	subs	r3, r3, r2
    1d5a:	6183      	str	r3, [r0, #24]
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1d5c:	008b      	lsls	r3, r1, #2
    1d5e:	1859      	adds	r1, r3, r1
    1d60:	0089      	lsls	r1, r1, #2
    1d62:	4b11      	ldr	r3, [pc, #68]	; (1da8 <vTaskPriorityInherit+0x70>)
    1d64:	333c      	adds	r3, #60	; 0x3c
    1d66:	185b      	adds	r3, r3, r1
    1d68:	6962      	ldr	r2, [r4, #20]
    1d6a:	429a      	cmp	r2, r3
    1d6c:	d004      	beq.n	1d78 <vTaskPriorityInherit+0x40>
					prvAddTaskToReadyList( pxTCB );
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1d6e:	4b0e      	ldr	r3, [pc, #56]	; (1da8 <vTaskPriorityInherit+0x70>)
    1d70:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1d72:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1d74:	62e3      	str	r3, [r4, #44]	; 0x2c
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1d76:	bd70      	pop	{r4, r5, r6, pc}
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1d78:	1d25      	adds	r5, r4, #4
    1d7a:	0028      	movs	r0, r5
    1d7c:	4b0b      	ldr	r3, [pc, #44]	; (1dac <vTaskPriorityInherit+0x74>)
    1d7e:	4798      	blx	r3
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1d80:	4b09      	ldr	r3, [pc, #36]	; (1da8 <vTaskPriorityInherit+0x70>)
    1d82:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1d84:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1d86:	62e2      	str	r2, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
    1d88:	4b09      	ldr	r3, [pc, #36]	; (1db0 <vTaskPriorityInherit+0x78>)
    1d8a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    1d8c:	429a      	cmp	r2, r3
    1d8e:	d901      	bls.n	1d94 <vTaskPriorityInherit+0x5c>
    1d90:	4b07      	ldr	r3, [pc, #28]	; (1db0 <vTaskPriorityInherit+0x78>)
    1d92:	665a      	str	r2, [r3, #100]	; 0x64
    1d94:	0090      	lsls	r0, r2, #2
    1d96:	1882      	adds	r2, r0, r2
    1d98:	0092      	lsls	r2, r2, #2
    1d9a:	4803      	ldr	r0, [pc, #12]	; (1da8 <vTaskPriorityInherit+0x70>)
    1d9c:	303c      	adds	r0, #60	; 0x3c
    1d9e:	1880      	adds	r0, r0, r2
    1da0:	0029      	movs	r1, r5
    1da2:	4b04      	ldr	r3, [pc, #16]	; (1db4 <vTaskPriorityInherit+0x7c>)
    1da4:	4798      	blx	r3
    1da6:	e7e6      	b.n	1d76 <vTaskPriorityInherit+0x3e>
    1da8:	20003f5c 	.word	0x20003f5c
    1dac:	00000e6d 	.word	0x00000e6d
    1db0:	20003fdc 	.word	0x20003fdc
    1db4:	00000e27 	.word	0x00000e27

00001db8 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    1db8:	b570      	push	{r4, r5, r6, lr}
    1dba:	1e04      	subs	r4, r0, #0
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    1dbc:	d01e      	beq.n	1dfc <vTaskPriorityDisinherit+0x44>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1dbe:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    1dc0:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
    1dc2:	4293      	cmp	r3, r2
    1dc4:	d01a      	beq.n	1dfc <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1dc6:	1d05      	adds	r5, r0, #4
    1dc8:	0028      	movs	r0, r5
    1dca:	4b0d      	ldr	r3, [pc, #52]	; (1e00 <vTaskPriorityDisinherit+0x48>)
    1dcc:	4798      	blx	r3
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    1dce:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    1dd0:	62e0      	str	r0, [r4, #44]	; 0x2c

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    1dd2:	69a3      	ldr	r3, [r4, #24]
    1dd4:	2b00      	cmp	r3, #0
    1dd6:	db02      	blt.n	1dde <vTaskPriorityDisinherit+0x26>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1dd8:	2305      	movs	r3, #5
    1dda:	1a1b      	subs	r3, r3, r0
    1ddc:	61a3      	str	r3, [r4, #24]
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddTaskToReadyList( pxTCB );
    1dde:	4b09      	ldr	r3, [pc, #36]	; (1e04 <vTaskPriorityDisinherit+0x4c>)
    1de0:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    1de2:	4298      	cmp	r0, r3
    1de4:	d901      	bls.n	1dea <vTaskPriorityDisinherit+0x32>
    1de6:	4b07      	ldr	r3, [pc, #28]	; (1e04 <vTaskPriorityDisinherit+0x4c>)
    1de8:	6658      	str	r0, [r3, #100]	; 0x64
    1dea:	0082      	lsls	r2, r0, #2
    1dec:	1812      	adds	r2, r2, r0
    1dee:	0092      	lsls	r2, r2, #2
    1df0:	4805      	ldr	r0, [pc, #20]	; (1e08 <vTaskPriorityDisinherit+0x50>)
    1df2:	303c      	adds	r0, #60	; 0x3c
    1df4:	1880      	adds	r0, r0, r2
    1df6:	0029      	movs	r1, r5
    1df8:	4b04      	ldr	r3, [pc, #16]	; (1e0c <vTaskPriorityDisinherit+0x54>)
    1dfa:	4798      	blx	r3
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1dfc:	bd70      	pop	{r4, r5, r6, pc}
    1dfe:	46c0      	nop			; (mov r8, r8)
    1e00:	00000e6d 	.word	0x00000e6d
    1e04:	20003fdc 	.word	0x20003fdc
    1e08:	20003f5c 	.word	0x20003f5c
    1e0c:	00000e27 	.word	0x00000e27

00001e10 <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
    1e10:	b510      	push	{r4, lr}
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    1e12:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    1e14:	6100      	str	r0, [r0, #16]

	if( xNextExpiryTime <= xTimeNow )
    1e16:	4291      	cmp	r1, r2
    1e18:	d80b      	bhi.n	1e32 <prvInsertTimerInActiveList+0x22>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
    1e1a:	1ad2      	subs	r2, r2, r3
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    1e1c:	2401      	movs	r4, #1
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
    1e1e:	6983      	ldr	r3, [r0, #24]
    1e20:	429a      	cmp	r2, r3
    1e22:	d211      	bcs.n	1e48 <prvInsertTimerInActiveList+0x38>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    1e24:	1d01      	adds	r1, r0, #4
    1e26:	4b09      	ldr	r3, [pc, #36]	; (1e4c <prvInsertTimerInActiveList+0x3c>)
    1e28:	6818      	ldr	r0, [r3, #0]
    1e2a:	4b09      	ldr	r3, [pc, #36]	; (1e50 <prvInsertTimerInActiveList+0x40>)
    1e2c:	4798      	blx	r3
BaseType_t xProcessTimerNow = pdFALSE;
    1e2e:	2400      	movs	r4, #0
    1e30:	e00a      	b.n	1e48 <prvInsertTimerInActiveList+0x38>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    1e32:	429a      	cmp	r2, r3
    1e34:	d202      	bcs.n	1e3c <prvInsertTimerInActiveList+0x2c>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
    1e36:	2401      	movs	r4, #1
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    1e38:	4299      	cmp	r1, r3
    1e3a:	d205      	bcs.n	1e48 <prvInsertTimerInActiveList+0x38>
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    1e3c:	1d01      	adds	r1, r0, #4
    1e3e:	4b03      	ldr	r3, [pc, #12]	; (1e4c <prvInsertTimerInActiveList+0x3c>)
    1e40:	6858      	ldr	r0, [r3, #4]
    1e42:	4b03      	ldr	r3, [pc, #12]	; (1e50 <prvInsertTimerInActiveList+0x40>)
    1e44:	4798      	blx	r3
BaseType_t xProcessTimerNow = pdFALSE;
    1e46:	2400      	movs	r4, #0
		}
	}

	return xProcessTimerNow;
}
    1e48:	0020      	movs	r0, r4
    1e4a:	bd10      	pop	{r4, pc}
    1e4c:	20004058 	.word	0x20004058
    1e50:	00000e3f 	.word	0x00000e3f

00001e54 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
    1e54:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    1e56:	4b10      	ldr	r3, [pc, #64]	; (1e98 <prvCheckForValidListAndQueue+0x44>)
    1e58:	4798      	blx	r3
	{
		if( xTimerQueue == NULL )
    1e5a:	4b10      	ldr	r3, [pc, #64]	; (1e9c <prvCheckForValidListAndQueue+0x48>)
    1e5c:	689b      	ldr	r3, [r3, #8]
    1e5e:	2b00      	cmp	r3, #0
    1e60:	d002      	beq.n	1e68 <prvCheckForValidListAndQueue+0x14>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    1e62:	4b0f      	ldr	r3, [pc, #60]	; (1ea0 <prvCheckForValidListAndQueue+0x4c>)
    1e64:	4798      	blx	r3
}
    1e66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			vListInitialise( &xActiveTimerList1 );
    1e68:	4c0c      	ldr	r4, [pc, #48]	; (1e9c <prvCheckForValidListAndQueue+0x48>)
    1e6a:	0026      	movs	r6, r4
    1e6c:	360c      	adds	r6, #12
    1e6e:	0030      	movs	r0, r6
    1e70:	4f0c      	ldr	r7, [pc, #48]	; (1ea4 <prvCheckForValidListAndQueue+0x50>)
    1e72:	47b8      	blx	r7
			vListInitialise( &xActiveTimerList2 );
    1e74:	0025      	movs	r5, r4
    1e76:	3520      	adds	r5, #32
    1e78:	0028      	movs	r0, r5
    1e7a:	47b8      	blx	r7
			pxCurrentTimerList = &xActiveTimerList1;
    1e7c:	6066      	str	r6, [r4, #4]
			pxOverflowTimerList = &xActiveTimerList2;
    1e7e:	6025      	str	r5, [r4, #0]
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    1e80:	2200      	movs	r2, #0
    1e82:	210c      	movs	r1, #12
    1e84:	2002      	movs	r0, #2
    1e86:	4b08      	ldr	r3, [pc, #32]	; (1ea8 <prvCheckForValidListAndQueue+0x54>)
    1e88:	4798      	blx	r3
			configASSERT( xTimerQueue );
    1e8a:	2800      	cmp	r0, #0
    1e8c:	d002      	beq.n	1e94 <prvCheckForValidListAndQueue+0x40>
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    1e8e:	4b03      	ldr	r3, [pc, #12]	; (1e9c <prvCheckForValidListAndQueue+0x48>)
    1e90:	6098      	str	r0, [r3, #8]
    1e92:	e7e6      	b.n	1e62 <prvCheckForValidListAndQueue+0xe>
			configASSERT( xTimerQueue );
    1e94:	b672      	cpsid	i
    1e96:	e7fe      	b.n	1e96 <prvCheckForValidListAndQueue+0x42>
    1e98:	00000c79 	.word	0x00000c79
    1e9c:	20004058 	.word	0x20004058
    1ea0:	00000c91 	.word	0x00000c91
    1ea4:	00000e0b 	.word	0x00000e0b
    1ea8:	000010b5 	.word	0x000010b5

00001eac <xTimerCreateTimerTask>:
{
    1eac:	b510      	push	{r4, lr}
    1eae:	b084      	sub	sp, #16
	prvCheckForValidListAndQueue();
    1eb0:	4b0b      	ldr	r3, [pc, #44]	; (1ee0 <xTimerCreateTimerTask+0x34>)
    1eb2:	4798      	blx	r3
	if( xTimerQueue != NULL )
    1eb4:	4b0b      	ldr	r3, [pc, #44]	; (1ee4 <xTimerCreateTimerTask+0x38>)
    1eb6:	689b      	ldr	r3, [r3, #8]
    1eb8:	2b00      	cmp	r3, #0
    1eba:	d00f      	beq.n	1edc <xTimerCreateTimerTask+0x30>
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
    1ebc:	2300      	movs	r3, #0
    1ebe:	9303      	str	r3, [sp, #12]
    1ec0:	9302      	str	r3, [sp, #8]
    1ec2:	9301      	str	r3, [sp, #4]
    1ec4:	3302      	adds	r3, #2
    1ec6:	9300      	str	r3, [sp, #0]
    1ec8:	2300      	movs	r3, #0
    1eca:	2250      	movs	r2, #80	; 0x50
    1ecc:	4906      	ldr	r1, [pc, #24]	; (1ee8 <xTimerCreateTimerTask+0x3c>)
    1ece:	4807      	ldr	r0, [pc, #28]	; (1eec <xTimerCreateTimerTask+0x40>)
    1ed0:	4c07      	ldr	r4, [pc, #28]	; (1ef0 <xTimerCreateTimerTask+0x44>)
    1ed2:	47a0      	blx	r4
	configASSERT( xReturn );
    1ed4:	2800      	cmp	r0, #0
    1ed6:	d001      	beq.n	1edc <xTimerCreateTimerTask+0x30>
}
    1ed8:	b004      	add	sp, #16
    1eda:	bd10      	pop	{r4, pc}
	configASSERT( xReturn );
    1edc:	b672      	cpsid	i
    1ede:	e7fe      	b.n	1ede <xTimerCreateTimerTask+0x32>
    1ee0:	00001e55 	.word	0x00001e55
    1ee4:	20004058 	.word	0x20004058
    1ee8:	00002668 	.word	0x00002668
    1eec:	00002009 	.word	0x00002009
    1ef0:	00001589 	.word	0x00001589

00001ef4 <xTimerGenericCommand>:
{
    1ef4:	b530      	push	{r4, r5, lr}
    1ef6:	b085      	sub	sp, #20
    1ef8:	001d      	movs	r5, r3
	if( xTimerQueue != NULL )
    1efa:	4b13      	ldr	r3, [pc, #76]	; (1f48 <xTimerGenericCommand+0x54>)
    1efc:	689c      	ldr	r4, [r3, #8]
    1efe:	2c00      	cmp	r4, #0
    1f00:	d020      	beq.n	1f44 <xTimerGenericCommand+0x50>
		xMessage.xMessageID = xCommandID;
    1f02:	9101      	str	r1, [sp, #4]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    1f04:	9202      	str	r2, [sp, #8]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    1f06:	9003      	str	r0, [sp, #12]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    1f08:	2905      	cmp	r1, #5
    1f0a:	dc13      	bgt.n	1f34 <xTimerGenericCommand+0x40>
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    1f0c:	4b0f      	ldr	r3, [pc, #60]	; (1f4c <xTimerGenericCommand+0x58>)
    1f0e:	4798      	blx	r3
    1f10:	2802      	cmp	r0, #2
    1f12:	d007      	beq.n	1f24 <xTimerGenericCommand+0x30>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    1f14:	4b0c      	ldr	r3, [pc, #48]	; (1f48 <xTimerGenericCommand+0x54>)
    1f16:	6898      	ldr	r0, [r3, #8]
    1f18:	2300      	movs	r3, #0
    1f1a:	2200      	movs	r2, #0
    1f1c:	a901      	add	r1, sp, #4
    1f1e:	4c0c      	ldr	r4, [pc, #48]	; (1f50 <xTimerGenericCommand+0x5c>)
    1f20:	47a0      	blx	r4
    1f22:	e00d      	b.n	1f40 <xTimerGenericCommand+0x4c>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    1f24:	4b08      	ldr	r3, [pc, #32]	; (1f48 <xTimerGenericCommand+0x54>)
    1f26:	6898      	ldr	r0, [r3, #8]
    1f28:	2300      	movs	r3, #0
    1f2a:	9a08      	ldr	r2, [sp, #32]
    1f2c:	a901      	add	r1, sp, #4
    1f2e:	4c08      	ldr	r4, [pc, #32]	; (1f50 <xTimerGenericCommand+0x5c>)
    1f30:	47a0      	blx	r4
    1f32:	e005      	b.n	1f40 <xTimerGenericCommand+0x4c>
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    1f34:	2300      	movs	r3, #0
    1f36:	002a      	movs	r2, r5
    1f38:	a901      	add	r1, sp, #4
    1f3a:	0020      	movs	r0, r4
    1f3c:	4c05      	ldr	r4, [pc, #20]	; (1f54 <xTimerGenericCommand+0x60>)
    1f3e:	47a0      	blx	r4
}
    1f40:	b005      	add	sp, #20
    1f42:	bd30      	pop	{r4, r5, pc}
BaseType_t xReturn = pdFAIL;
    1f44:	2000      	movs	r0, #0
	return xReturn;
    1f46:	e7fb      	b.n	1f40 <xTimerGenericCommand+0x4c>
    1f48:	20004058 	.word	0x20004058
    1f4c:	00001d1d 	.word	0x00001d1d
    1f50:	00001105 	.word	0x00001105
    1f54:	00001279 	.word	0x00001279

00001f58 <prvSampleTimeNow>:
{
    1f58:	b5f0      	push	{r4, r5, r6, r7, lr}
    1f5a:	46d6      	mov	lr, sl
    1f5c:	464f      	mov	r7, r9
    1f5e:	4646      	mov	r6, r8
    1f60:	b5c0      	push	{r6, r7, lr}
    1f62:	b082      	sub	sp, #8
    1f64:	4681      	mov	r9, r0
	xTimeNow = xTaskGetTickCount();
    1f66:	4b23      	ldr	r3, [pc, #140]	; (1ff4 <prvSampleTimeNow+0x9c>)
    1f68:	4798      	blx	r3
    1f6a:	4680      	mov	r8, r0
	if( xTimeNow < xLastTime )
    1f6c:	4b22      	ldr	r3, [pc, #136]	; (1ff8 <prvSampleTimeNow+0xa0>)
    1f6e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    1f70:	4298      	cmp	r0, r3
    1f72:	d317      	bcc.n	1fa4 <prvSampleTimeNow+0x4c>
		*pxTimerListsWereSwitched = pdFALSE;
    1f74:	2300      	movs	r3, #0
    1f76:	464a      	mov	r2, r9
    1f78:	6013      	str	r3, [r2, #0]
	xLastTime = xTimeNow;
    1f7a:	4b1f      	ldr	r3, [pc, #124]	; (1ff8 <prvSampleTimeNow+0xa0>)
    1f7c:	4642      	mov	r2, r8
    1f7e:	635a      	str	r2, [r3, #52]	; 0x34
}
    1f80:	4640      	mov	r0, r8
    1f82:	b002      	add	sp, #8
    1f84:	bc1c      	pop	{r2, r3, r4}
    1f86:	4690      	mov	r8, r2
    1f88:	4699      	mov	r9, r3
    1f8a:	46a2      	mov	sl, r4
    1f8c:	bdf0      	pop	{r4, r5, r6, r7, pc}
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    1f8e:	2300      	movs	r3, #0
    1f90:	9300      	str	r3, [sp, #0]
    1f92:	4652      	mov	r2, sl
    1f94:	2100      	movs	r1, #0
    1f96:	0020      	movs	r0, r4
    1f98:	4c18      	ldr	r4, [pc, #96]	; (1ffc <prvSampleTimeNow+0xa4>)
    1f9a:	47a0      	blx	r4
				configASSERT( xResult );
    1f9c:	2800      	cmp	r0, #0
    1f9e:	d103      	bne.n	1fa8 <prvSampleTimeNow+0x50>
    1fa0:	b672      	cpsid	i
    1fa2:	e7fe      	b.n	1fa2 <prvSampleTimeNow+0x4a>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    1fa4:	4e14      	ldr	r6, [pc, #80]	; (1ff8 <prvSampleTimeNow+0xa0>)
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1fa6:	4f16      	ldr	r7, [pc, #88]	; (2000 <STACK_SIZE>)
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    1fa8:	6873      	ldr	r3, [r6, #4]
    1faa:	681a      	ldr	r2, [r3, #0]
    1fac:	2a00      	cmp	r2, #0
    1fae:	d018      	beq.n	1fe2 <prvSampleTimeNow+0x8a>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1fb0:	68db      	ldr	r3, [r3, #12]
    1fb2:	681a      	ldr	r2, [r3, #0]
    1fb4:	4692      	mov	sl, r2
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    1fb6:	68dc      	ldr	r4, [r3, #12]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1fb8:	1d25      	adds	r5, r4, #4
    1fba:	0028      	movs	r0, r5
    1fbc:	47b8      	blx	r7
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1fbe:	0020      	movs	r0, r4
    1fc0:	6a63      	ldr	r3, [r4, #36]	; 0x24
    1fc2:	4798      	blx	r3
		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1fc4:	69e3      	ldr	r3, [r4, #28]
    1fc6:	2b01      	cmp	r3, #1
    1fc8:	d1ee      	bne.n	1fa8 <prvSampleTimeNow+0x50>
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    1fca:	69a3      	ldr	r3, [r4, #24]
    1fcc:	4453      	add	r3, sl
			if( xReloadTime > xNextExpireTime )
    1fce:	459a      	cmp	sl, r3
    1fd0:	d2dd      	bcs.n	1f8e <prvSampleTimeNow+0x36>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    1fd2:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    1fd4:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    1fd6:	4b08      	ldr	r3, [pc, #32]	; (1ff8 <prvSampleTimeNow+0xa0>)
    1fd8:	6858      	ldr	r0, [r3, #4]
    1fda:	0029      	movs	r1, r5
    1fdc:	4b09      	ldr	r3, [pc, #36]	; (2004 <STACK_SIZE+0x4>)
    1fde:	4798      	blx	r3
    1fe0:	e7e2      	b.n	1fa8 <prvSampleTimeNow+0x50>
	pxCurrentTimerList = pxOverflowTimerList;
    1fe2:	4a05      	ldr	r2, [pc, #20]	; (1ff8 <prvSampleTimeNow+0xa0>)
    1fe4:	6811      	ldr	r1, [r2, #0]
    1fe6:	6051      	str	r1, [r2, #4]
	pxOverflowTimerList = pxTemp;
    1fe8:	6013      	str	r3, [r2, #0]
		*pxTimerListsWereSwitched = pdTRUE;
    1fea:	2301      	movs	r3, #1
    1fec:	464a      	mov	r2, r9
    1fee:	6013      	str	r3, [r2, #0]
    1ff0:	e7c3      	b.n	1f7a <prvSampleTimeNow+0x22>
    1ff2:	46c0      	nop			; (mov r8, r8)
    1ff4:	000017d1 	.word	0x000017d1
    1ff8:	20004058 	.word	0x20004058
    1ffc:	00001ef5 	.word	0x00001ef5
    2000:	00000e6d 	.word	0x00000e6d
    2004:	00000e3f 	.word	0x00000e3f

00002008 <prvTimerTask>:
{
    2008:	b5f0      	push	{r4, r5, r6, r7, lr}
    200a:	b089      	sub	sp, #36	; 0x24
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    200c:	4f50      	ldr	r7, [pc, #320]	; (2150 <prvTimerTask+0x148>)
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    200e:	4b51      	ldr	r3, [pc, #324]	; (2154 <prvTimerTask+0x14c>)
    2010:	685b      	ldr	r3, [r3, #4]
	if( *pxListWasEmpty == pdFALSE )
    2012:	681a      	ldr	r2, [r3, #0]
    2014:	2a00      	cmp	r2, #0
    2016:	d100      	bne.n	201a <prvTimerTask+0x12>
    2018:	e08c      	b.n	2134 <prvTimerTask+0x12c>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    201a:	68db      	ldr	r3, [r3, #12]
    201c:	681d      	ldr	r5, [r3, #0]
	vTaskSuspendAll();
    201e:	4b4e      	ldr	r3, [pc, #312]	; (2158 <prvTimerTask+0x150>)
    2020:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2022:	a805      	add	r0, sp, #20
    2024:	4b4d      	ldr	r3, [pc, #308]	; (215c <prvTimerTask+0x154>)
    2026:	4798      	blx	r3
    2028:	0004      	movs	r4, r0
		if( xTimerListsWereSwitched == pdFALSE )
    202a:	9b05      	ldr	r3, [sp, #20]
    202c:	2b00      	cmp	r3, #0
    202e:	d000      	beq.n	2032 <prvTimerTask+0x2a>
    2030:	e08b      	b.n	214a <prvTimerTask+0x142>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2032:	42a8      	cmp	r0, r5
    2034:	d225      	bcs.n	2082 <prvTimerTask+0x7a>
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
    2036:	1b29      	subs	r1, r5, r4
    2038:	4b46      	ldr	r3, [pc, #280]	; (2154 <prvTimerTask+0x14c>)
    203a:	6898      	ldr	r0, [r3, #8]
    203c:	4b48      	ldr	r3, [pc, #288]	; (2160 <prvTimerTask+0x158>)
    203e:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
    2040:	4b48      	ldr	r3, [pc, #288]	; (2164 <prvTimerTask+0x15c>)
    2042:	4798      	blx	r3
    2044:	2800      	cmp	r0, #0
    2046:	d040      	beq.n	20ca <prvTimerTask+0xc2>
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2048:	4d42      	ldr	r5, [pc, #264]	; (2154 <prvTimerTask+0x14c>)
    204a:	4c47      	ldr	r4, [pc, #284]	; (2168 <prvTimerTask+0x160>)
    204c:	2300      	movs	r3, #0
    204e:	2200      	movs	r2, #0
    2050:	a905      	add	r1, sp, #20
    2052:	68a8      	ldr	r0, [r5, #8]
    2054:	47a0      	blx	r4
    2056:	2800      	cmp	r0, #0
    2058:	d0d9      	beq.n	200e <prvTimerTask+0x6>
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    205a:	9b05      	ldr	r3, [sp, #20]
    205c:	9303      	str	r3, [sp, #12]
    205e:	2b00      	cmp	r3, #0
    2060:	dbf4      	blt.n	204c <prvTimerTask+0x44>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    2062:	9e07      	ldr	r6, [sp, #28]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    2064:	6973      	ldr	r3, [r6, #20]
    2066:	2b00      	cmp	r3, #0
    2068:	d001      	beq.n	206e <prvTimerTask+0x66>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    206a:	1d30      	adds	r0, r6, #4
    206c:	47b8      	blx	r7
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    206e:	a804      	add	r0, sp, #16
    2070:	4b3a      	ldr	r3, [pc, #232]	; (215c <prvTimerTask+0x154>)
    2072:	4798      	blx	r3
			switch( xMessage.xMessageID )
    2074:	9b05      	ldr	r3, [sp, #20]
    2076:	2b09      	cmp	r3, #9
    2078:	d8e8      	bhi.n	204c <prvTimerTask+0x44>
    207a:	009b      	lsls	r3, r3, #2
    207c:	4a3b      	ldr	r2, [pc, #236]	; (216c <prvTimerTask+0x164>)
    207e:	58d3      	ldr	r3, [r2, r3]
    2080:	469f      	mov	pc, r3
				( void ) xTaskResumeAll();
    2082:	4b38      	ldr	r3, [pc, #224]	; (2164 <prvTimerTask+0x15c>)
    2084:	4798      	blx	r3
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    2086:	4b33      	ldr	r3, [pc, #204]	; (2154 <prvTimerTask+0x14c>)
    2088:	685b      	ldr	r3, [r3, #4]
    208a:	68db      	ldr	r3, [r3, #12]
    208c:	68de      	ldr	r6, [r3, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    208e:	1d30      	adds	r0, r6, #4
    2090:	4b2f      	ldr	r3, [pc, #188]	; (2150 <prvTimerTask+0x148>)
    2092:	4798      	blx	r3
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2094:	69f3      	ldr	r3, [r6, #28]
    2096:	2b01      	cmp	r3, #1
    2098:	d003      	beq.n	20a2 <prvTimerTask+0x9a>
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    209a:	6a73      	ldr	r3, [r6, #36]	; 0x24
    209c:	0030      	movs	r0, r6
    209e:	4798      	blx	r3
    20a0:	e7d2      	b.n	2048 <prvTimerTask+0x40>
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
    20a2:	69b3      	ldr	r3, [r6, #24]
    20a4:	18e9      	adds	r1, r5, r3
    20a6:	002b      	movs	r3, r5
    20a8:	0022      	movs	r2, r4
    20aa:	0030      	movs	r0, r6
    20ac:	4c30      	ldr	r4, [pc, #192]	; (2170 <prvTimerTask+0x168>)
    20ae:	47a0      	blx	r4
    20b0:	2801      	cmp	r0, #1
    20b2:	d1f2      	bne.n	209a <prvTimerTask+0x92>
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    20b4:	2300      	movs	r3, #0
    20b6:	9300      	str	r3, [sp, #0]
    20b8:	002a      	movs	r2, r5
    20ba:	2100      	movs	r1, #0
    20bc:	0030      	movs	r0, r6
    20be:	4c2d      	ldr	r4, [pc, #180]	; (2174 <prvTimerTask+0x16c>)
    20c0:	47a0      	blx	r4
			configASSERT( xResult );
    20c2:	2800      	cmp	r0, #0
    20c4:	d1e9      	bne.n	209a <prvTimerTask+0x92>
    20c6:	b672      	cpsid	i
    20c8:	e7fe      	b.n	20c8 <prvTimerTask+0xc0>
					portYIELD_WITHIN_API();
    20ca:	4b2b      	ldr	r3, [pc, #172]	; (2178 <prvTimerTask+0x170>)
    20cc:	4798      	blx	r3
    20ce:	e7bb      	b.n	2048 <prvTimerTask+0x40>
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
    20d0:	9b06      	ldr	r3, [sp, #24]
    20d2:	69b2      	ldr	r2, [r6, #24]
    20d4:	4694      	mov	ip, r2
    20d6:	4463      	add	r3, ip
    20d8:	0019      	movs	r1, r3
    20da:	9b06      	ldr	r3, [sp, #24]
    20dc:	0002      	movs	r2, r0
    20de:	0030      	movs	r0, r6
    20e0:	4c23      	ldr	r4, [pc, #140]	; (2170 <prvTimerTask+0x168>)
    20e2:	47a0      	blx	r4
    20e4:	2801      	cmp	r0, #1
    20e6:	d1b0      	bne.n	204a <prvTimerTask+0x42>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    20e8:	0030      	movs	r0, r6
    20ea:	6a73      	ldr	r3, [r6, #36]	; 0x24
    20ec:	4798      	blx	r3
						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    20ee:	69f3      	ldr	r3, [r6, #28]
    20f0:	2b01      	cmp	r3, #1
    20f2:	d1aa      	bne.n	204a <prvTimerTask+0x42>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    20f4:	9b06      	ldr	r3, [sp, #24]
    20f6:	69b1      	ldr	r1, [r6, #24]
    20f8:	468c      	mov	ip, r1
    20fa:	4463      	add	r3, ip
    20fc:	001a      	movs	r2, r3
    20fe:	2300      	movs	r3, #0
    2100:	9300      	str	r3, [sp, #0]
    2102:	2100      	movs	r1, #0
    2104:	0030      	movs	r0, r6
    2106:	4c1b      	ldr	r4, [pc, #108]	; (2174 <prvTimerTask+0x16c>)
    2108:	47a0      	blx	r4
							configASSERT( xResult );
    210a:	2800      	cmp	r0, #0
    210c:	d19d      	bne.n	204a <prvTimerTask+0x42>
    210e:	b672      	cpsid	i
    2110:	e7fe      	b.n	2110 <prvTimerTask+0x108>
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    2112:	9906      	ldr	r1, [sp, #24]
    2114:	61b1      	str	r1, [r6, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    2116:	2900      	cmp	r1, #0
    2118:	d006      	beq.n	2128 <prvTimerTask+0x120>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    211a:	1841      	adds	r1, r0, r1
    211c:	0003      	movs	r3, r0
    211e:	0002      	movs	r2, r0
    2120:	0030      	movs	r0, r6
    2122:	4c13      	ldr	r4, [pc, #76]	; (2170 <prvTimerTask+0x168>)
    2124:	47a0      	blx	r4
    2126:	e790      	b.n	204a <prvTimerTask+0x42>
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    2128:	b672      	cpsid	i
    212a:	e7fe      	b.n	212a <prvTimerTask+0x122>
					vPortFree( pxTimer );
    212c:	0030      	movs	r0, r6
    212e:	4b13      	ldr	r3, [pc, #76]	; (217c <prvTimerTask+0x174>)
    2130:	4798      	blx	r3
    2132:	e78a      	b.n	204a <prvTimerTask+0x42>
	vTaskSuspendAll();
    2134:	4b08      	ldr	r3, [pc, #32]	; (2158 <prvTimerTask+0x150>)
    2136:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2138:	a805      	add	r0, sp, #20
    213a:	4b08      	ldr	r3, [pc, #32]	; (215c <prvTimerTask+0x154>)
    213c:	4798      	blx	r3
    213e:	0004      	movs	r4, r0
		xNextExpireTime = ( TickType_t ) 0U;
    2140:	2500      	movs	r5, #0
		if( xTimerListsWereSwitched == pdFALSE )
    2142:	9b05      	ldr	r3, [sp, #20]
    2144:	2b00      	cmp	r3, #0
    2146:	d100      	bne.n	214a <prvTimerTask+0x142>
    2148:	e775      	b.n	2036 <prvTimerTask+0x2e>
			( void ) xTaskResumeAll();
    214a:	4b06      	ldr	r3, [pc, #24]	; (2164 <prvTimerTask+0x15c>)
    214c:	4798      	blx	r3
    214e:	e77b      	b.n	2048 <prvTimerTask+0x40>
    2150:	00000e6d 	.word	0x00000e6d
    2154:	20004058 	.word	0x20004058
    2158:	000017c1 	.word	0x000017c1
    215c:	00001f59 	.word	0x00001f59
    2160:	000014c9 	.word	0x000014c9
    2164:	00001901 	.word	0x00001901
    2168:	00001341 	.word	0x00001341
    216c:	00002640 	.word	0x00002640
    2170:	00001e11 	.word	0x00001e11
    2174:	00001ef5 	.word	0x00001ef5
    2178:	00000c61 	.word	0x00000c61
    217c:	00000e01 	.word	0x00000e01

00002180 <__aeabi_idiv0>:
    2180:	4770      	bx	lr
    2182:	46c0      	nop			; (mov r8, r8)

00002184 <__aeabi_uldivmod>:
    2184:	2b00      	cmp	r3, #0
    2186:	d111      	bne.n	21ac <__aeabi_uldivmod+0x28>
    2188:	2a00      	cmp	r2, #0
    218a:	d10f      	bne.n	21ac <__aeabi_uldivmod+0x28>
    218c:	2900      	cmp	r1, #0
    218e:	d100      	bne.n	2192 <__aeabi_uldivmod+0xe>
    2190:	2800      	cmp	r0, #0
    2192:	d002      	beq.n	219a <__aeabi_uldivmod+0x16>
    2194:	2100      	movs	r1, #0
    2196:	43c9      	mvns	r1, r1
    2198:	1c08      	adds	r0, r1, #0
    219a:	b407      	push	{r0, r1, r2}
    219c:	4802      	ldr	r0, [pc, #8]	; (21a8 <__aeabi_uldivmod+0x24>)
    219e:	a102      	add	r1, pc, #8	; (adr r1, 21a8 <__aeabi_uldivmod+0x24>)
    21a0:	1840      	adds	r0, r0, r1
    21a2:	9002      	str	r0, [sp, #8]
    21a4:	bd03      	pop	{r0, r1, pc}
    21a6:	46c0      	nop			; (mov r8, r8)
    21a8:	ffffffd9 	.word	0xffffffd9
    21ac:	b403      	push	{r0, r1}
    21ae:	4668      	mov	r0, sp
    21b0:	b501      	push	{r0, lr}
    21b2:	9802      	ldr	r0, [sp, #8]
    21b4:	f000 f806 	bl	21c4 <__udivmoddi4>
    21b8:	9b01      	ldr	r3, [sp, #4]
    21ba:	469e      	mov	lr, r3
    21bc:	b002      	add	sp, #8
    21be:	bc0c      	pop	{r2, r3}
    21c0:	4770      	bx	lr
    21c2:	46c0      	nop			; (mov r8, r8)

000021c4 <__udivmoddi4>:
    21c4:	b5f0      	push	{r4, r5, r6, r7, lr}
    21c6:	4657      	mov	r7, sl
    21c8:	464e      	mov	r6, r9
    21ca:	4645      	mov	r5, r8
    21cc:	46de      	mov	lr, fp
    21ce:	b5e0      	push	{r5, r6, r7, lr}
    21d0:	0004      	movs	r4, r0
    21d2:	b083      	sub	sp, #12
    21d4:	000d      	movs	r5, r1
    21d6:	4692      	mov	sl, r2
    21d8:	4699      	mov	r9, r3
    21da:	428b      	cmp	r3, r1
    21dc:	d82f      	bhi.n	223e <__udivmoddi4+0x7a>
    21de:	d02c      	beq.n	223a <__udivmoddi4+0x76>
    21e0:	4649      	mov	r1, r9
    21e2:	4650      	mov	r0, sl
    21e4:	f000 f8ae 	bl	2344 <__clzdi2>
    21e8:	0029      	movs	r1, r5
    21ea:	0006      	movs	r6, r0
    21ec:	0020      	movs	r0, r4
    21ee:	f000 f8a9 	bl	2344 <__clzdi2>
    21f2:	1a33      	subs	r3, r6, r0
    21f4:	4698      	mov	r8, r3
    21f6:	3b20      	subs	r3, #32
    21f8:	469b      	mov	fp, r3
    21fa:	d500      	bpl.n	21fe <__udivmoddi4+0x3a>
    21fc:	e074      	b.n	22e8 <__udivmoddi4+0x124>
    21fe:	4653      	mov	r3, sl
    2200:	465a      	mov	r2, fp
    2202:	4093      	lsls	r3, r2
    2204:	001f      	movs	r7, r3
    2206:	4653      	mov	r3, sl
    2208:	4642      	mov	r2, r8
    220a:	4093      	lsls	r3, r2
    220c:	001e      	movs	r6, r3
    220e:	42af      	cmp	r7, r5
    2210:	d829      	bhi.n	2266 <__udivmoddi4+0xa2>
    2212:	d026      	beq.n	2262 <__udivmoddi4+0x9e>
    2214:	465b      	mov	r3, fp
    2216:	1ba4      	subs	r4, r4, r6
    2218:	41bd      	sbcs	r5, r7
    221a:	2b00      	cmp	r3, #0
    221c:	da00      	bge.n	2220 <__udivmoddi4+0x5c>
    221e:	e079      	b.n	2314 <__udivmoddi4+0x150>
    2220:	2200      	movs	r2, #0
    2222:	2300      	movs	r3, #0
    2224:	9200      	str	r2, [sp, #0]
    2226:	9301      	str	r3, [sp, #4]
    2228:	2301      	movs	r3, #1
    222a:	465a      	mov	r2, fp
    222c:	4093      	lsls	r3, r2
    222e:	9301      	str	r3, [sp, #4]
    2230:	2301      	movs	r3, #1
    2232:	4642      	mov	r2, r8
    2234:	4093      	lsls	r3, r2
    2236:	9300      	str	r3, [sp, #0]
    2238:	e019      	b.n	226e <__udivmoddi4+0xaa>
    223a:	4282      	cmp	r2, r0
    223c:	d9d0      	bls.n	21e0 <__udivmoddi4+0x1c>
    223e:	2200      	movs	r2, #0
    2240:	2300      	movs	r3, #0
    2242:	9200      	str	r2, [sp, #0]
    2244:	9301      	str	r3, [sp, #4]
    2246:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    2248:	2b00      	cmp	r3, #0
    224a:	d001      	beq.n	2250 <__udivmoddi4+0x8c>
    224c:	601c      	str	r4, [r3, #0]
    224e:	605d      	str	r5, [r3, #4]
    2250:	9800      	ldr	r0, [sp, #0]
    2252:	9901      	ldr	r1, [sp, #4]
    2254:	b003      	add	sp, #12
    2256:	bc3c      	pop	{r2, r3, r4, r5}
    2258:	4690      	mov	r8, r2
    225a:	4699      	mov	r9, r3
    225c:	46a2      	mov	sl, r4
    225e:	46ab      	mov	fp, r5
    2260:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2262:	42a3      	cmp	r3, r4
    2264:	d9d6      	bls.n	2214 <__udivmoddi4+0x50>
    2266:	2200      	movs	r2, #0
    2268:	2300      	movs	r3, #0
    226a:	9200      	str	r2, [sp, #0]
    226c:	9301      	str	r3, [sp, #4]
    226e:	4643      	mov	r3, r8
    2270:	2b00      	cmp	r3, #0
    2272:	d0e8      	beq.n	2246 <__udivmoddi4+0x82>
    2274:	07fb      	lsls	r3, r7, #31
    2276:	0872      	lsrs	r2, r6, #1
    2278:	431a      	orrs	r2, r3
    227a:	4646      	mov	r6, r8
    227c:	087b      	lsrs	r3, r7, #1
    227e:	e00e      	b.n	229e <__udivmoddi4+0xda>
    2280:	42ab      	cmp	r3, r5
    2282:	d101      	bne.n	2288 <__udivmoddi4+0xc4>
    2284:	42a2      	cmp	r2, r4
    2286:	d80c      	bhi.n	22a2 <__udivmoddi4+0xde>
    2288:	1aa4      	subs	r4, r4, r2
    228a:	419d      	sbcs	r5, r3
    228c:	2001      	movs	r0, #1
    228e:	1924      	adds	r4, r4, r4
    2290:	416d      	adcs	r5, r5
    2292:	2100      	movs	r1, #0
    2294:	3e01      	subs	r6, #1
    2296:	1824      	adds	r4, r4, r0
    2298:	414d      	adcs	r5, r1
    229a:	2e00      	cmp	r6, #0
    229c:	d006      	beq.n	22ac <__udivmoddi4+0xe8>
    229e:	42ab      	cmp	r3, r5
    22a0:	d9ee      	bls.n	2280 <__udivmoddi4+0xbc>
    22a2:	3e01      	subs	r6, #1
    22a4:	1924      	adds	r4, r4, r4
    22a6:	416d      	adcs	r5, r5
    22a8:	2e00      	cmp	r6, #0
    22aa:	d1f8      	bne.n	229e <__udivmoddi4+0xda>
    22ac:	465b      	mov	r3, fp
    22ae:	9800      	ldr	r0, [sp, #0]
    22b0:	9901      	ldr	r1, [sp, #4]
    22b2:	1900      	adds	r0, r0, r4
    22b4:	4169      	adcs	r1, r5
    22b6:	2b00      	cmp	r3, #0
    22b8:	db22      	blt.n	2300 <__udivmoddi4+0x13c>
    22ba:	002b      	movs	r3, r5
    22bc:	465a      	mov	r2, fp
    22be:	40d3      	lsrs	r3, r2
    22c0:	002a      	movs	r2, r5
    22c2:	4644      	mov	r4, r8
    22c4:	40e2      	lsrs	r2, r4
    22c6:	001c      	movs	r4, r3
    22c8:	465b      	mov	r3, fp
    22ca:	0015      	movs	r5, r2
    22cc:	2b00      	cmp	r3, #0
    22ce:	db2c      	blt.n	232a <__udivmoddi4+0x166>
    22d0:	0026      	movs	r6, r4
    22d2:	409e      	lsls	r6, r3
    22d4:	0033      	movs	r3, r6
    22d6:	0026      	movs	r6, r4
    22d8:	4647      	mov	r7, r8
    22da:	40be      	lsls	r6, r7
    22dc:	0032      	movs	r2, r6
    22de:	1a80      	subs	r0, r0, r2
    22e0:	4199      	sbcs	r1, r3
    22e2:	9000      	str	r0, [sp, #0]
    22e4:	9101      	str	r1, [sp, #4]
    22e6:	e7ae      	b.n	2246 <__udivmoddi4+0x82>
    22e8:	4642      	mov	r2, r8
    22ea:	2320      	movs	r3, #32
    22ec:	1a9b      	subs	r3, r3, r2
    22ee:	4652      	mov	r2, sl
    22f0:	40da      	lsrs	r2, r3
    22f2:	4641      	mov	r1, r8
    22f4:	0013      	movs	r3, r2
    22f6:	464a      	mov	r2, r9
    22f8:	408a      	lsls	r2, r1
    22fa:	0017      	movs	r7, r2
    22fc:	431f      	orrs	r7, r3
    22fe:	e782      	b.n	2206 <__udivmoddi4+0x42>
    2300:	4642      	mov	r2, r8
    2302:	2320      	movs	r3, #32
    2304:	1a9b      	subs	r3, r3, r2
    2306:	002a      	movs	r2, r5
    2308:	4646      	mov	r6, r8
    230a:	409a      	lsls	r2, r3
    230c:	0023      	movs	r3, r4
    230e:	40f3      	lsrs	r3, r6
    2310:	4313      	orrs	r3, r2
    2312:	e7d5      	b.n	22c0 <__udivmoddi4+0xfc>
    2314:	4642      	mov	r2, r8
    2316:	2320      	movs	r3, #32
    2318:	2100      	movs	r1, #0
    231a:	1a9b      	subs	r3, r3, r2
    231c:	2200      	movs	r2, #0
    231e:	9100      	str	r1, [sp, #0]
    2320:	9201      	str	r2, [sp, #4]
    2322:	2201      	movs	r2, #1
    2324:	40da      	lsrs	r2, r3
    2326:	9201      	str	r2, [sp, #4]
    2328:	e782      	b.n	2230 <__udivmoddi4+0x6c>
    232a:	4642      	mov	r2, r8
    232c:	2320      	movs	r3, #32
    232e:	0026      	movs	r6, r4
    2330:	1a9b      	subs	r3, r3, r2
    2332:	40de      	lsrs	r6, r3
    2334:	002f      	movs	r7, r5
    2336:	46b4      	mov	ip, r6
    2338:	4097      	lsls	r7, r2
    233a:	4666      	mov	r6, ip
    233c:	003b      	movs	r3, r7
    233e:	4333      	orrs	r3, r6
    2340:	e7c9      	b.n	22d6 <__udivmoddi4+0x112>
    2342:	46c0      	nop			; (mov r8, r8)

00002344 <__clzdi2>:
    2344:	b510      	push	{r4, lr}
    2346:	2900      	cmp	r1, #0
    2348:	d103      	bne.n	2352 <__clzdi2+0xe>
    234a:	f000 f807 	bl	235c <__clzsi2>
    234e:	3020      	adds	r0, #32
    2350:	e002      	b.n	2358 <__clzdi2+0x14>
    2352:	1c08      	adds	r0, r1, #0
    2354:	f000 f802 	bl	235c <__clzsi2>
    2358:	bd10      	pop	{r4, pc}
    235a:	46c0      	nop			; (mov r8, r8)

0000235c <__clzsi2>:
    235c:	211c      	movs	r1, #28
    235e:	2301      	movs	r3, #1
    2360:	041b      	lsls	r3, r3, #16
    2362:	4298      	cmp	r0, r3
    2364:	d301      	bcc.n	236a <__clzsi2+0xe>
    2366:	0c00      	lsrs	r0, r0, #16
    2368:	3910      	subs	r1, #16
    236a:	0a1b      	lsrs	r3, r3, #8
    236c:	4298      	cmp	r0, r3
    236e:	d301      	bcc.n	2374 <__clzsi2+0x18>
    2370:	0a00      	lsrs	r0, r0, #8
    2372:	3908      	subs	r1, #8
    2374:	091b      	lsrs	r3, r3, #4
    2376:	4298      	cmp	r0, r3
    2378:	d301      	bcc.n	237e <__clzsi2+0x22>
    237a:	0900      	lsrs	r0, r0, #4
    237c:	3904      	subs	r1, #4
    237e:	a202      	add	r2, pc, #8	; (adr r2, 2388 <__clzsi2+0x2c>)
    2380:	5c10      	ldrb	r0, [r2, r0]
    2382:	1840      	adds	r0, r0, r1
    2384:	4770      	bx	lr
    2386:	46c0      	nop			; (mov r8, r8)
    2388:	02020304 	.word	0x02020304
    238c:	01010101 	.word	0x01010101
	...

00002398 <__libc_init_array>:
    2398:	b570      	push	{r4, r5, r6, lr}
    239a:	4e0d      	ldr	r6, [pc, #52]	; (23d0 <__libc_init_array+0x38>)
    239c:	4d0d      	ldr	r5, [pc, #52]	; (23d4 <__libc_init_array+0x3c>)
    239e:	2400      	movs	r4, #0
    23a0:	1bad      	subs	r5, r5, r6
    23a2:	10ad      	asrs	r5, r5, #2
    23a4:	d005      	beq.n	23b2 <__libc_init_array+0x1a>
    23a6:	00a3      	lsls	r3, r4, #2
    23a8:	58f3      	ldr	r3, [r6, r3]
    23aa:	3401      	adds	r4, #1
    23ac:	4798      	blx	r3
    23ae:	42a5      	cmp	r5, r4
    23b0:	d1f9      	bne.n	23a6 <__libc_init_array+0xe>
    23b2:	f000 f95f 	bl	2674 <_init>
    23b6:	4e08      	ldr	r6, [pc, #32]	; (23d8 <__libc_init_array+0x40>)
    23b8:	4d08      	ldr	r5, [pc, #32]	; (23dc <__libc_init_array+0x44>)
    23ba:	2400      	movs	r4, #0
    23bc:	1bad      	subs	r5, r5, r6
    23be:	10ad      	asrs	r5, r5, #2
    23c0:	d005      	beq.n	23ce <__libc_init_array+0x36>
    23c2:	00a3      	lsls	r3, r4, #2
    23c4:	58f3      	ldr	r3, [r6, r3]
    23c6:	3401      	adds	r4, #1
    23c8:	4798      	blx	r3
    23ca:	42a5      	cmp	r5, r4
    23cc:	d1f9      	bne.n	23c2 <__libc_init_array+0x2a>
    23ce:	bd70      	pop	{r4, r5, r6, pc}
    23d0:	00002680 	.word	0x00002680
    23d4:	00002680 	.word	0x00002680
    23d8:	00002680 	.word	0x00002680
    23dc:	00002688 	.word	0x00002688

000023e0 <memcpy>:
    23e0:	b5f0      	push	{r4, r5, r6, r7, lr}
    23e2:	0005      	movs	r5, r0
    23e4:	2a0f      	cmp	r2, #15
    23e6:	d92f      	bls.n	2448 <memcpy+0x68>
    23e8:	000b      	movs	r3, r1
    23ea:	4303      	orrs	r3, r0
    23ec:	079b      	lsls	r3, r3, #30
    23ee:	d134      	bne.n	245a <memcpy+0x7a>
    23f0:	0016      	movs	r6, r2
    23f2:	000c      	movs	r4, r1
    23f4:	0003      	movs	r3, r0
    23f6:	3e10      	subs	r6, #16
    23f8:	0935      	lsrs	r5, r6, #4
    23fa:	3501      	adds	r5, #1
    23fc:	012d      	lsls	r5, r5, #4
    23fe:	1945      	adds	r5, r0, r5
    2400:	6827      	ldr	r7, [r4, #0]
    2402:	601f      	str	r7, [r3, #0]
    2404:	6867      	ldr	r7, [r4, #4]
    2406:	605f      	str	r7, [r3, #4]
    2408:	68a7      	ldr	r7, [r4, #8]
    240a:	609f      	str	r7, [r3, #8]
    240c:	68e7      	ldr	r7, [r4, #12]
    240e:	3410      	adds	r4, #16
    2410:	60df      	str	r7, [r3, #12]
    2412:	3310      	adds	r3, #16
    2414:	429d      	cmp	r5, r3
    2416:	d1f3      	bne.n	2400 <memcpy+0x20>
    2418:	230f      	movs	r3, #15
    241a:	439e      	bics	r6, r3
    241c:	3610      	adds	r6, #16
    241e:	1985      	adds	r5, r0, r6
    2420:	1989      	adds	r1, r1, r6
    2422:	4013      	ands	r3, r2
    2424:	2b03      	cmp	r3, #3
    2426:	d91a      	bls.n	245e <memcpy+0x7e>
    2428:	1f1e      	subs	r6, r3, #4
    242a:	2300      	movs	r3, #0
    242c:	08b4      	lsrs	r4, r6, #2
    242e:	3401      	adds	r4, #1
    2430:	00a4      	lsls	r4, r4, #2
    2432:	58cf      	ldr	r7, [r1, r3]
    2434:	50ef      	str	r7, [r5, r3]
    2436:	3304      	adds	r3, #4
    2438:	42a3      	cmp	r3, r4
    243a:	d1fa      	bne.n	2432 <memcpy+0x52>
    243c:	2403      	movs	r4, #3
    243e:	43a6      	bics	r6, r4
    2440:	1d33      	adds	r3, r6, #4
    2442:	4022      	ands	r2, r4
    2444:	18c9      	adds	r1, r1, r3
    2446:	18ed      	adds	r5, r5, r3
    2448:	2a00      	cmp	r2, #0
    244a:	d005      	beq.n	2458 <memcpy+0x78>
    244c:	2300      	movs	r3, #0
    244e:	5ccc      	ldrb	r4, [r1, r3]
    2450:	54ec      	strb	r4, [r5, r3]
    2452:	3301      	adds	r3, #1
    2454:	4293      	cmp	r3, r2
    2456:	d1fa      	bne.n	244e <memcpy+0x6e>
    2458:	bdf0      	pop	{r4, r5, r6, r7, pc}
    245a:	0005      	movs	r5, r0
    245c:	e7f6      	b.n	244c <memcpy+0x6c>
    245e:	001a      	movs	r2, r3
    2460:	e7f2      	b.n	2448 <memcpy+0x68>
    2462:	46c0      	nop			; (mov r8, r8)

00002464 <register_fini>:
    2464:	4b03      	ldr	r3, [pc, #12]	; (2474 <register_fini+0x10>)
    2466:	b510      	push	{r4, lr}
    2468:	2b00      	cmp	r3, #0
    246a:	d002      	beq.n	2472 <register_fini+0xe>
    246c:	4802      	ldr	r0, [pc, #8]	; (2478 <register_fini+0x14>)
    246e:	f000 f805 	bl	247c <atexit>
    2472:	bd10      	pop	{r4, pc}
    2474:	00000000 	.word	0x00000000
    2478:	0000248d 	.word	0x0000248d

0000247c <atexit>:
    247c:	b510      	push	{r4, lr}
    247e:	0001      	movs	r1, r0
    2480:	2300      	movs	r3, #0
    2482:	2200      	movs	r2, #0
    2484:	2000      	movs	r0, #0
    2486:	f000 f81f 	bl	24c8 <__register_exitproc>
    248a:	bd10      	pop	{r4, pc}

0000248c <__libc_fini_array>:
    248c:	b570      	push	{r4, r5, r6, lr}
    248e:	4b09      	ldr	r3, [pc, #36]	; (24b4 <__libc_fini_array+0x28>)
    2490:	4c09      	ldr	r4, [pc, #36]	; (24b8 <__libc_fini_array+0x2c>)
    2492:	1ae4      	subs	r4, r4, r3
    2494:	10a4      	asrs	r4, r4, #2
    2496:	d009      	beq.n	24ac <__libc_fini_array+0x20>
    2498:	4a08      	ldr	r2, [pc, #32]	; (24bc <__libc_fini_array+0x30>)
    249a:	18a5      	adds	r5, r4, r2
    249c:	00ad      	lsls	r5, r5, #2
    249e:	18ed      	adds	r5, r5, r3
    24a0:	682b      	ldr	r3, [r5, #0]
    24a2:	3c01      	subs	r4, #1
    24a4:	4798      	blx	r3
    24a6:	3d04      	subs	r5, #4
    24a8:	2c00      	cmp	r4, #0
    24aa:	d1f9      	bne.n	24a0 <__libc_fini_array+0x14>
    24ac:	f000 f8ec 	bl	2688 <_fini>
    24b0:	bd70      	pop	{r4, r5, r6, pc}
    24b2:	46c0      	nop			; (mov r8, r8)
    24b4:	00002694 	.word	0x00002694
    24b8:	00002698 	.word	0x00002698
    24bc:	3fffffff 	.word	0x3fffffff

000024c0 <__retarget_lock_acquire_recursive>:
    24c0:	4770      	bx	lr
    24c2:	46c0      	nop			; (mov r8, r8)

000024c4 <__retarget_lock_release_recursive>:
    24c4:	4770      	bx	lr
    24c6:	46c0      	nop			; (mov r8, r8)

000024c8 <__register_exitproc>:
    24c8:	b5f0      	push	{r4, r5, r6, r7, lr}
    24ca:	464e      	mov	r6, r9
    24cc:	4645      	mov	r5, r8
    24ce:	46de      	mov	lr, fp
    24d0:	4657      	mov	r7, sl
    24d2:	b5e0      	push	{r5, r6, r7, lr}
    24d4:	4d36      	ldr	r5, [pc, #216]	; (25b0 <__register_exitproc+0xe8>)
    24d6:	b083      	sub	sp, #12
    24d8:	0006      	movs	r6, r0
    24da:	6828      	ldr	r0, [r5, #0]
    24dc:	4698      	mov	r8, r3
    24de:	000f      	movs	r7, r1
    24e0:	4691      	mov	r9, r2
    24e2:	f7ff ffed 	bl	24c0 <__retarget_lock_acquire_recursive>
    24e6:	4b33      	ldr	r3, [pc, #204]	; (25b4 <__register_exitproc+0xec>)
    24e8:	681c      	ldr	r4, [r3, #0]
    24ea:	23a4      	movs	r3, #164	; 0xa4
    24ec:	005b      	lsls	r3, r3, #1
    24ee:	58e0      	ldr	r0, [r4, r3]
    24f0:	2800      	cmp	r0, #0
    24f2:	d052      	beq.n	259a <__register_exitproc+0xd2>
    24f4:	6843      	ldr	r3, [r0, #4]
    24f6:	2b1f      	cmp	r3, #31
    24f8:	dc13      	bgt.n	2522 <__register_exitproc+0x5a>
    24fa:	1c5a      	adds	r2, r3, #1
    24fc:	9201      	str	r2, [sp, #4]
    24fe:	2e00      	cmp	r6, #0
    2500:	d128      	bne.n	2554 <__register_exitproc+0x8c>
    2502:	9a01      	ldr	r2, [sp, #4]
    2504:	3302      	adds	r3, #2
    2506:	009b      	lsls	r3, r3, #2
    2508:	6042      	str	r2, [r0, #4]
    250a:	501f      	str	r7, [r3, r0]
    250c:	6828      	ldr	r0, [r5, #0]
    250e:	f7ff ffd9 	bl	24c4 <__retarget_lock_release_recursive>
    2512:	2000      	movs	r0, #0
    2514:	b003      	add	sp, #12
    2516:	bc3c      	pop	{r2, r3, r4, r5}
    2518:	4690      	mov	r8, r2
    251a:	4699      	mov	r9, r3
    251c:	46a2      	mov	sl, r4
    251e:	46ab      	mov	fp, r5
    2520:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2522:	4b25      	ldr	r3, [pc, #148]	; (25b8 <__register_exitproc+0xf0>)
    2524:	2b00      	cmp	r3, #0
    2526:	d03d      	beq.n	25a4 <__register_exitproc+0xdc>
    2528:	20c8      	movs	r0, #200	; 0xc8
    252a:	0040      	lsls	r0, r0, #1
    252c:	e000      	b.n	2530 <__register_exitproc+0x68>
    252e:	bf00      	nop
    2530:	2800      	cmp	r0, #0
    2532:	d037      	beq.n	25a4 <__register_exitproc+0xdc>
    2534:	22a4      	movs	r2, #164	; 0xa4
    2536:	2300      	movs	r3, #0
    2538:	0052      	lsls	r2, r2, #1
    253a:	58a1      	ldr	r1, [r4, r2]
    253c:	6043      	str	r3, [r0, #4]
    253e:	6001      	str	r1, [r0, #0]
    2540:	50a0      	str	r0, [r4, r2]
    2542:	3240      	adds	r2, #64	; 0x40
    2544:	5083      	str	r3, [r0, r2]
    2546:	3204      	adds	r2, #4
    2548:	5083      	str	r3, [r0, r2]
    254a:	3301      	adds	r3, #1
    254c:	9301      	str	r3, [sp, #4]
    254e:	2300      	movs	r3, #0
    2550:	2e00      	cmp	r6, #0
    2552:	d0d6      	beq.n	2502 <__register_exitproc+0x3a>
    2554:	009a      	lsls	r2, r3, #2
    2556:	4692      	mov	sl, r2
    2558:	4482      	add	sl, r0
    255a:	464a      	mov	r2, r9
    255c:	2188      	movs	r1, #136	; 0x88
    255e:	4654      	mov	r4, sl
    2560:	5062      	str	r2, [r4, r1]
    2562:	22c4      	movs	r2, #196	; 0xc4
    2564:	0052      	lsls	r2, r2, #1
    2566:	4691      	mov	r9, r2
    2568:	4481      	add	r9, r0
    256a:	464a      	mov	r2, r9
    256c:	3987      	subs	r1, #135	; 0x87
    256e:	4099      	lsls	r1, r3
    2570:	6812      	ldr	r2, [r2, #0]
    2572:	468b      	mov	fp, r1
    2574:	430a      	orrs	r2, r1
    2576:	4694      	mov	ip, r2
    2578:	464a      	mov	r2, r9
    257a:	4661      	mov	r1, ip
    257c:	6011      	str	r1, [r2, #0]
    257e:	2284      	movs	r2, #132	; 0x84
    2580:	4641      	mov	r1, r8
    2582:	0052      	lsls	r2, r2, #1
    2584:	50a1      	str	r1, [r4, r2]
    2586:	2e02      	cmp	r6, #2
    2588:	d1bb      	bne.n	2502 <__register_exitproc+0x3a>
    258a:	0002      	movs	r2, r0
    258c:	465c      	mov	r4, fp
    258e:	328d      	adds	r2, #141	; 0x8d
    2590:	32ff      	adds	r2, #255	; 0xff
    2592:	6811      	ldr	r1, [r2, #0]
    2594:	430c      	orrs	r4, r1
    2596:	6014      	str	r4, [r2, #0]
    2598:	e7b3      	b.n	2502 <__register_exitproc+0x3a>
    259a:	0020      	movs	r0, r4
    259c:	304d      	adds	r0, #77	; 0x4d
    259e:	30ff      	adds	r0, #255	; 0xff
    25a0:	50e0      	str	r0, [r4, r3]
    25a2:	e7a7      	b.n	24f4 <__register_exitproc+0x2c>
    25a4:	6828      	ldr	r0, [r5, #0]
    25a6:	f7ff ff8d 	bl	24c4 <__retarget_lock_release_recursive>
    25aa:	2001      	movs	r0, #1
    25ac:	4240      	negs	r0, r0
    25ae:	e7b1      	b.n	2514 <__register_exitproc+0x4c>
    25b0:	20000470 	.word	0x20000470
    25b4:	00002670 	.word	0x00002670
    25b8:	00000000 	.word	0x00000000
    25bc:	64256425 	.word	0x64256425
    25c0:	2564252f 	.word	0x2564252f
    25c4:	30322f64 	.word	0x30322f64
    25c8:	64256425 	.word	0x64256425
    25cc:	0000002f 	.word	0x0000002f
    25d0:	64256425 	.word	0x64256425
    25d4:	2564253a 	.word	0x2564253a
    25d8:	64253a64 	.word	0x64253a64
    25dc:	50206425 	.word	0x50206425
    25e0:	00000a4d 	.word	0x00000a4d
    25e4:	64256425 	.word	0x64256425
    25e8:	2564253a 	.word	0x2564253a
    25ec:	64253a64 	.word	0x64253a64
    25f0:	41206425 	.word	0x41206425
    25f4:	00000a4d 	.word	0x00000a4d
    25f8:	64256425 	.word	0x64256425
    25fc:	2564253a 	.word	0x2564253a
    2600:	64253a64 	.word	0x64253a64
    2604:	0a2f6425 	.word	0x0a2f6425
    2608:	00000000 	.word	0x00000000
    260c:	00006425 	.word	0x00006425
    2610:	70435452 	.word	0x70435452
    2614:	006c6c75 	.word	0x006c6c75
    2618:	656d6954 	.word	0x656d6954
    261c:	6d617473 	.word	0x6d617473
    2620:	6e657370 	.word	0x6e657370
    2624:	00000064 	.word	0x00000064
    2628:	69726553 	.word	0x69726553
    262c:	72706c61 	.word	0x72706c61
    2630:	00746e69 	.word	0x00746e69

00002634 <UARTWRConfig.10011>:
    2634:	d30100c0 454c4449 00000000 000020d0     ....IDLE..... ..
    2644:	000020d0 000020d0 0000204c 00002112     . ... ..L ...!..
    2654:	0000212c 000020d0 000020d0 0000204c     ,!... ... ..L ..
    2664:	00002112 20726d54 00637653              .!..Tmr Svc.

00002670 <_global_impure_ptr>:
    2670:	20000048                                H.. 

00002674 <_init>:
    2674:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2676:	46c0      	nop			; (mov r8, r8)
    2678:	bcf8      	pop	{r3, r4, r5, r6, r7}
    267a:	bc08      	pop	{r3}
    267c:	469e      	mov	lr, r3
    267e:	4770      	bx	lr

00002680 <__init_array_start>:
    2680:	00002465 	.word	0x00002465

00002684 <__frame_dummy_init_array_entry>:
    2684:	000000dd                                ....

00002688 <_fini>:
    2688:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    268a:	46c0      	nop			; (mov r8, r8)
    268c:	bcf8      	pop	{r3, r4, r5, r6, r7}
    268e:	bc08      	pop	{r3}
    2690:	469e      	mov	lr, r3
    2692:	4770      	bx	lr

00002694 <__fini_array_start>:
    2694:	000000b5 	.word	0x000000b5
